<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/lisp/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-05-16T06:32:46+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fooling around with array memory ...]]></title>
    <link href="http://agam.github.io/blog/2015/04/10/fooling-around-with-array-memory-dot-dot-dot/"/>
    <updated>2015-04-10T23:42:23+00:00</updated>
    <id>http://agam.github.io/blog/2015/04/10/fooling-around-with-array-memory-dot-dot-dot</id>
    <content type="html"><![CDATA[<p>Something I saved in a scratch buffer once &hellip;</p>

<p>```lisp
* (room)</p>

<p>Dynamic space usage is: 43,629,232 bytes.
Read-only space usage is: 6,736 bytes.
Static space usage is: 4,000 bytes.
Control stack usage is: 2,976 bytes.
Binding stack usage is: 800 bytes.
Control and binding stack usage is for the current thread only.
Garbage collection is currently enabled.</p>

<p>Breakdown for dynamic space:
13,392,016 bytes for 12,550 code objects.
7,629,616 bytes for 87,920 instance objects.
7,108,736 bytes for 444,296 cons objects.
7,093,664 bytes for 59,224 simple-vector objects.
2,268,928 bytes for 35,452 symbol objects.
6,136,272 bytes for 115,793 other objects.
43,629,232 bytes for 755,235 dynamic objects (space total.)</p>

<ul>
<li>(defparameter <em>a</em> (make-array &lsquo;(3000 3000) :element-type &rsquo;(unsigned-byte 8) :initial-element 0))</li>
</ul>


<p><em>A</em>
* (room)</p>

<p>Dynamic space usage is: 52,662,000 bytes.
Read-only space usage is: 6,736 bytes.
Static space usage is: 4,000 bytes.
Control stack usage is: 2,976 bytes.
Binding stack usage is: 800 bytes.
Control and binding stack usage is for the current thread only.
Garbage collection is currently enabled.</p>

<p>Breakdown for dynamic space:
13,392,016 bytes for 12,550 code objects.
9,221,424 bytes for 1,914 simple-array-unsigned-byte-8 objects.
7,644,768 bytes for 88,074 instance objects.
7,123,088 bytes for 445,193 cons objects.
7,096,224 bytes for 59,245 simple-vector objects.
8,217,248 bytes for 149,969 other objects.
52,694,768 bytes for 756,945 dynamic objects (space total.)</p>

<ul>
<li>(gc)</li>
</ul>


<p>NIL
* (room)</p>

<p>Dynamic space usage is: 43,810,864 bytes.
Read-only space usage is: 6,736 bytes.
Static space usage is: 4,000 bytes.
Control stack usage is: 2,976 bytes.
Binding stack usage is: 800 bytes.
Control and binding stack usage is for the current thread only.
Garbage collection is currently enabled.</p>

<p>Breakdown for dynamic space:
13,392,016 bytes for 12,550 code objects.
7,687,200 bytes for 88,515 instance objects.
7,144,528 bytes for 59,470 simple-vector objects.
7,134,528 bytes for 445,908 cons objects.
2,269,312 bytes for 35,458 symbol objects.
6,183,280 bytes for 116,551 other objects.
43,810,864 bytes for 758,452 dynamic objects (space total.)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 42: Pandigitals with sub-string divisibility]]></title>
    <link href="http://agam.github.io/blog/2015/03/25/euler-42-pandigitals-with-sub-string-divisibility/"/>
    <updated>2015-03-25T23:33:56+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/25/euler-42-pandigitals-with-sub-string-divisibility</id>
    <content type="html"><![CDATA[<p>These brute force solutions are getting a bit worrying, but here is another one. (I keep promising myself to get out of my comfort zone, but (<em>unfortunately!</em>) code like this is too easy to write).</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```lisp
;; For all 0-9 pandigital numbers, find the ones which have successive
;; substrings of length 3 diisible by 2,3,&hellip;,17.</p>

<p>(defparameter <em>prime-divisors</em> #(17 13 11 7 5 3 2))</p>

<p>;; A number is 0-9 pandigital if it (a) is 10 digits long, and (b) has every digit from 0-9
(defun is-pandigital (num)
  (declare (type fixnum num))
  (let ((digits-seen (make-array 10 :element-type &lsquo;bit :initial-element 0)))</p>

<pre><code>(do* ((n num (floor (/ n 10)))
      (d (mod n 10) (mod n 10))
      (num-digits 0 (1+ num-digits)))
     ((= n 0) (and (= num-digits 10)
                   (every (lambda (x) (= x 1)) digits-seen)))
  (setf (bit digits-seen d) 1))))
</code></pre>

<p>(defun check-divisibility (num div-index)
  (= 0 (mod num (aref <em>prime-divisors</em> div-index))))</p>

<p>(defun get-three-digit-num (num)
  (let ((ones (mod num 10))</p>

<pre><code>    (tens (mod (floor (/ num 10)) 10))
    (hundreds (mod (floor (/ num 100)) 10)))
(+ ones
   (* 10 tens)
   (* 100 hundreds))))
</code></pre>

<p>;; Go backwards in groups of three digits and check divisibility
(defun has-divisible-substrings (num)
  (do* ((n num (floor (/ n 10)))</p>

<pre><code>    (div-index 0 (1+ div-index))
    (dividend (get-three-digit-num n) (get-three-digit-num n))
    (div-p (check-divisibility dividend div-index)
           (and div-p (check-divisibility dividend div-index))))
   ((&lt; n 10000) div-p)))
</code></pre>

<p>(defun check-substring-pandigital-range (start end)
  (declare (type fixnum start end))
  (let ((candidates &lsquo;()))</p>

<pre><code>(loop for num from start to end do
     (if (and (is-pandigital num)
              (has-divisible-substrings num))
         (push num candidates)))
candidates))
</code></pre>

<p>(defun euler43 ()
  (let ((candidates (check-substring-pandigital-range 1234567890 9876543210)))</p>

<pre><code>(print candidates)
(apply #'+ candidates)))
</code></pre>

<p>```</p>

<p>As before, evaluating <code>(euler43)</code> shows the final solution (sum), along with the (six!) candidate numbers making up the sum. This took a whopping <code>4.3 hours</code> to churn through the 8.5 billion numbers. Maybe I need to create a new constraint for these problems: either pen-and-paper, or something <em>slow</em> (like Python ?! :P), so that brute force is never tempting again.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 42: Coded triangle numbers]]></title>
    <link href="http://agam.github.io/blog/2015/03/23/euler-42-coded-triangle-numbers/"/>
    <updated>2015-03-23T01:11:01+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/23/euler-42-coded-triangle-numbers</id>
    <content type="html"><![CDATA[<p>Very straightforward, this one. And I don&rsquo;t need to feel bad that I did it the simple way. If you&rsquo;re wondering where <code>split-sequence-if</code> and <code>read-file</code> came from, the answer is <code>rutils</code>, which is a good general-purpose utility package, a sort of superset of <code>alexandria</code>, and just a <code>(ql:quickload 'rutils)</code> away. As before, the final answer is obtained by evaluating <code>(euler42)</code>.</p>

<p><strong>Statutory Warning</strong>: <em>spoilers ahead</em></p>

<p>```lisp
;; If x = 0.5 * n * (n+1) is a triangle number, then there is an
;; integral solution for n<sup>2</sup> + n &ndash; 2<em>x = 0.
(defun quadratic-solution (a b c)
  (let ((det (sqrt (&ndash; (</em> b b) (* 4 a c))))</p>

<pre><code>    (denom (* 2 a)))
(cons (/ (- (- b) det) denom)
      (/ (+ (- b) det) denom))))
</code></pre>

<p>(defun positive-int (num)
  (and (integerp num)</p>

<pre><code>   (plusp num)))
</code></pre>

<p>(defun is-triangle-number (num)
  (let ((soln (quadratic-solution 1 1 (* (&ndash; 2) num))))</p>

<pre><code>(or (positive-int (car soln))
    (positive-int (cdr soln)))))
</code></pre>

<p>(defun char->number (char)
  (1+ (&ndash; (char-code char) (char-code #\A))))</p>

<p>(defun is-triangle-word (word)
  (let ((value (loop for char across word</p>

<pre><code>              summing (char-&gt;number char))))
(is-triangle-number value)))       
</code></pre>

<p>(defun euler42 ()
  ;; Read in the file, split on the commas, remove the quotes
  (let* ((file-text (read-file &ldquo;/home/agam/Downloads/p042_words.txt&rdquo;))</p>

<pre><code>     (words-with-quotes (split-sequence-if
                         (lambda (char) (eq char #\,))
                         file-text))
     (words (mapcar (lambda (w) (remove #\" w))
                    words-with-quotes)))
(loop for w in words count
     (is-triangle-word w))))
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 41: Pandigital primes]]></title>
    <link href="http://agam.github.io/blog/2015/03/22/euler-41-pandigital-primes/"/>
    <updated>2015-03-22T04:35:08+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/22/euler-41-pandigital-primes</id>
    <content type="html"><![CDATA[<p>Yet another <em>brute-force</em> solution, pushing the line a bit at <em>1991 seconds</em>. But hey, it works, and was quick to write, so &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>spoilers ahead</em></p>

<p>```lisp
(defparameter <em>max-num-limit</em> 1000000000)
(defparameter <em>all-numbers</em> (make-array (list <em>max-num-limit</em>) :element-type &lsquo;bit :initial-element 1))</p>

<p>(defun mark-primes (&amp;optional (n <em>max-num-limit</em>))
  ;; 0 and 1 are not prime
  (mark-not-prime 0)
  (mark-not-prime 1)
  ;; Mark 2 as prime, then do the following:
  ;; (1) Mark all multiples of the prime number,
  ;; (2) Find next available prime number, mark it as prime,
  ;; Repeat (1) until n
  (let ((prime 2))</p>

<pre><code>(loop while (&lt; prime n) do
     (mark-prime-multiples prime n)
     (setf prime (find-next-prime prime n)))))
</code></pre>

<p>(defun mark-not-prime (idx)
  (setf (bit <em>all-numbers</em> idx) 0))</p>

<p>(defun mark-prime-multiples (prime limit)
  (do ((i (* prime 2) (+ i prime)))</p>

<pre><code>  ((&gt;= i limit))
(mark-not-prime i)))
</code></pre>

<p>(defun find-next-prime (prev-prime limit)
  (do ((i (1+ prev-prime) (1+ i)))</p>

<pre><code>  ((or (= i limit) (= 1 (bit *all-numbers* i))) i)))
</code></pre>

<p>(defun is-prime (n)
  (= 1 (bit <em>all-numbers</em> n)))</p>

<p>(defun get-num-digits (n)
  (ceiling (log n 10)))</p>

<p>(defun is-pandigital (n)
  (let* ((num-digits (get-num-digits n))</p>

<pre><code>     (digits (make-array num-digits :element-type 'bit :initial-element 0)))
(loop while (and (&gt; n 0)
                 (&gt; (mod n 10) 0)
                 (&lt;= (mod n 10) num-digits)) do
     (setf (bit digits (1- (mod n 10))) 1)
     (setf n (floor (/ n 10))))
(= (length digits) (count 1 digits))))
</code></pre>

<p>(defun euler41 ()
  (mark-primes)
  (do ((n 987654321 (1- n)))</p>

<pre><code>  ((and (is-pandigital n) (is-prime n)) n)))
</code></pre>

<p>```</p>

<p>Everything is wrapped up in the call to <code>(euler41)</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 40: Champernowne's Constant]]></title>
    <link href="http://agam.github.io/blog/2015/03/21/euler-40-champernownes-constant/"/>
    <updated>2015-03-21T19:34:12+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/21/euler-40-champernownes-constant</id>
    <content type="html"><![CDATA[<p>I was too lazy to avoid the brute-force approach here, especially since it took less than a second to run. The following seems longer than it should be, partly because I left in some helper and debugging functions &hellip;</p>

<p><em>Edit</em>: There is obviously a very nice paper-and-pen solution to this &mdash; the 10th place is &lsquo;1&rsquo; (for 10), then the 100th place is &lsquo;5&rsquo; (for 55), and so on &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```lisp
(defparameter <em>max-digits</em> 2000000)</p>

<p>(defun digits (n)
  (declare (type fixnum n))
  (nreverse (loop</p>

<pre><code>           for tmp = n then (floor (/ tmp 10))
           until (= tmp 0)
           collect (mod tmp 10))))
</code></pre>

<p>(defun set-digits (d start all-digits)
  (loop</p>

<pre><code> for elem in d
 for idx = start then (1+ idx) do
   (setf (aref all-digits idx) elem)))
</code></pre>

<p>;; Fills out the array of digits and returns an accessor function
;; Note: the index increments by the length of the number of
;; digits of the <em>previous</em> number.
(let ((all-digits (make-array (list <em>max-digits</em>) :element-type &lsquo;(integer 0 9) :initial-element 0)))
  (defun populate-digits (n)</p>

<pre><code>(progn
  (loop
     for num = 1 then (1+ num)
     for d = (digits num)
     for i = 0 then (+ i (length (digits (1- num))))
     while (&lt; i n) do
       (set-digits d i all-digits))
(lambda (idx)
  (aref all-digits idx)))))
</code></pre>

<p>(defun power-list ()
  (let ((champer (populate-digits 1000000)))</p>

<pre><code>(loop for p from 0 to 6 collect
     (funcall champer (1- (expt 10 p))))))
</code></pre>

<p>(defun euler40 ()
  (apply &lsquo;* (power-list)))</p>

<p>;; Useful debugging tool
(defun scan-list (start end)
  (let ((champer (populate-digits)))</p>

<pre><code>(loop for i from start to end do
     (print (cons i (funcall champer i))))))
</code></pre>

<p>```</p>

<p>The &ldquo;final answer&rdquo; is given by <code>(euler40)</code>, and the intermediate digits themselves by <code>(power-list)</code>. I found <code>(scan-list)</code> useful to debug an embarassing off-by-one error in the loop.</p>
]]></content>
  </entry>
  
</feed>
