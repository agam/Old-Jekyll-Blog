<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/lisp/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-03-23T01:18:37+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 42: Coded triangle numbers]]></title>
    <link href="http://agam.github.io/blog/2015/03/23/euler-42-coded-triangle-numbers/"/>
    <updated>2015-03-23T01:11:01+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/23/euler-42-coded-triangle-numbers</id>
    <content type="html"><![CDATA[<p>Very straightforward, this one. And I don&rsquo;t need to feel bad that I did it the simple way. If you&rsquo;re wondering where <code>split-sequence-if</code> and <code>read-file</code> came from, the answer is <code>rutils</code>, which is a good general-purpose utility package, a sort of superset of <code>alexandria</code>, and just a <code>(ql:quickload 'rutils)</code> away. As before, the final answer is obtained by evaluating <code>(euler42)</code>.</p>

<p><strong>Statutory Warning</strong>: <em>spoilers ahead</em></p>

<p>```lisp
;; If x = 0.5 * n * (n+1) is a triangle number, then there is an
;; integral solution for n<sup>2</sup> + n &ndash; 2<em>x = 0.
(defun quadratic-solution (a b c)
  (let ((det (sqrt (&ndash; (</em> b b) (* 4 a c))))</p>

<pre><code>    (denom (* 2 a)))
(cons (/ (- (- b) det) denom)
      (/ (+ (- b) det) denom))))
</code></pre>

<p>(defun positive-int (num)
  (and (integerp num)</p>

<pre><code>   (plusp num)))
</code></pre>

<p>(defun is-triangle-number (num)
  (let ((soln (quadratic-solution 1 1 (* (&ndash; 2) num))))</p>

<pre><code>(or (positive-int (car soln))
    (positive-int (cdr soln)))))
</code></pre>

<p>(defun char->number (char)
  (1+ (&ndash; (char-code char) (char-code #\A))))</p>

<p>(defun is-triangle-word (word)
  (let ((value (loop for char across word</p>

<pre><code>              summing (char-&gt;number char))))
(is-triangle-number value)))       
</code></pre>

<p>(defun un-quote (str)
  (remove #\&ldquo; str))</p>

<p>(defun euler42 ()
  ;; Read in the file, split on the commas, remove the quotes
  (let* ((file-text (read-file &ldquo;/home/agam/Downloads/p042_words.txt&rdquo;))</p>

<pre><code>     (words-with-quotes (split-sequence-if
                         (lambda (char) (eq char #\,))
                         file-text))
     (words (mapcar (lambda (w) (remove #\" w))
                    words-with-quotes)))
(loop for w in words count
     (is-triangle-word w))))
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 41: Pandigital primes]]></title>
    <link href="http://agam.github.io/blog/2015/03/22/euler-41-pandigital-primes/"/>
    <updated>2015-03-22T04:35:08+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/22/euler-41-pandigital-primes</id>
    <content type="html"><![CDATA[<p>Yet another <em>brute-force</em> solution, pushing the line a bit at <em>1991 seconds</em>. But hey, it works, and was quick to write, so &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>spoilers ahead</em></p>

<p>```lisp
(defparameter <em>max-num-limit</em> 1000000000)
(defparameter <em>all-numbers</em> (make-array (list <em>max-num-limit</em>) :element-type &lsquo;bit :initial-element 1))</p>

<p>(defun mark-primes (&amp;optional (n <em>max-num-limit</em>))
  ;; 0 and 1 are not prime
  (mark-not-prime 0)
  (mark-not-prime 1)
  ;; Mark 2 as prime, then do the following:
  ;; (1) Mark all multiples of the prime number,
  ;; (2) Find next available prime number, mark it as prime,
  ;; Repeat (1) until n
  (let ((prime 2))</p>

<pre><code>(loop while (&lt; prime n) do
     (mark-prime-multiples prime n)
     (setf prime (find-next-prime prime n)))))
</code></pre>

<p>(defun mark-not-prime (idx)
  (setf (bit <em>all-numbers</em> idx) 0))</p>

<p>(defun mark-prime-multiples (prime limit)
  (do ((i (* prime 2) (+ i prime)))</p>

<pre><code>  ((&gt;= i limit))
(mark-not-prime i)))
</code></pre>

<p>(defun find-next-prime (prev-prime limit)
  (do ((i (1+ prev-prime) (1+ i)))</p>

<pre><code>  ((or (= i limit) (= 1 (bit *all-numbers* i))) i)))
</code></pre>

<p>(defun is-prime (n)
  (= 1 (bit <em>all-numbers</em> n)))</p>

<p>(defun get-num-digits (n)
  (ceiling (log n 10)))</p>

<p>(defun is-pandigital (n)
  (let* ((num-digits (get-num-digits n))</p>

<pre><code>     (digits (make-array num-digits :element-type 'bit :initial-element 0)))
(loop while (and (&gt; n 0)
                 (&gt; (mod n 10) 0)
                 (&lt;= (mod n 10) num-digits)) do
     (setf (bit digits (1- (mod n 10))) 1)
     (setf n (floor (/ n 10))))
(= (length digits) (count 1 digits))))
</code></pre>

<p>(defun euler41 ()
  (mark-primes)
  (do ((n 987654321 (1- n)))</p>

<pre><code>  ((and (is-pandigital n) (is-prime n)) n)))
</code></pre>

<p>```</p>

<p>Everything is wrapped up in the call to <code>(euler41)</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 40: Champernowne's Constant]]></title>
    <link href="http://agam.github.io/blog/2015/03/21/euler-40-champernownes-constant/"/>
    <updated>2015-03-21T19:34:12+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/21/euler-40-champernownes-constant</id>
    <content type="html"><![CDATA[<p>I was too lazy to avoid the brute-force approach here, especially since it took less than a second to run. The following seems longer than it should be, partly because I left in some helper and debugging functions &hellip;</p>

<p><em>Edit</em>: There is obviously a very nice paper-and-pen solution to this &mdash; the 10th place is &lsquo;1&rsquo; (for 10), then the 100th place is &lsquo;5&rsquo; (for 55), and so on &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```lisp
(defparameter <em>max-digits</em> 2000000)</p>

<p>(defun digits (n)
  (declare (type fixnum n))
  (nreverse (loop</p>

<pre><code>           for tmp = n then (floor (/ tmp 10))
           until (= tmp 0)
           collect (mod tmp 10))))
</code></pre>

<p>(defun set-digits (d start all-digits)
  (loop</p>

<pre><code> for elem in d
 for idx = start then (1+ idx) do
   (setf (aref all-digits idx) elem)))
</code></pre>

<p>;; Fills out the array of digits and returns an accessor function
;; Note: the index increments by the length of the number of
;; digits of the <em>previous</em> number.
(let ((all-digits (make-array (list <em>max-digits</em>) :element-type &lsquo;(integer 0 9) :initial-element 0)))
  (defun populate-digits (n)</p>

<pre><code>(progn
  (loop
     for num = 1 then (1+ num)
     for d = (digits num)
     for i = 0 then (+ i (length (digits (1- num))))
     while (&lt; i n) do
       (set-digits d i all-digits))
(lambda (idx)
  (aref all-digits idx)))))
</code></pre>

<p>(defun power-list ()
  (let ((champer (populate-digits 1000000)))</p>

<pre><code>(loop for p from 0 to 6 collect
     (funcall champer (1- (expt 10 p))))))
</code></pre>

<p>(defun euler40 ()
  (apply &lsquo;* (power-list)))</p>

<p>;; Useful debugging tool
(defun scan-list (start end)
  (let ((champer (populate-digits)))</p>

<pre><code>(loop for i from start to end do
     (print (cons i (funcall champer i))))))
</code></pre>

<p>```</p>

<p>The &ldquo;final answer&rdquo; is given by <code>(euler40)</code>, and the intermediate digits themselves by <code>(power-list)</code>. I found <code>(scan-list)</code> useful to debug an embarassing off-by-one error in the loop.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 39: Integer Right Triangles]]></title>
    <link href="http://agam.github.io/blog/2015/03/20/euler-39-integer-right-triangles/"/>
    <updated>2015-03-20T23:09:44+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/20/euler-39-integer-right-triangles</id>
    <content type="html"><![CDATA[<p>Straightfoward, this. An interesting insight into speed difference between <code>SBCL</code> and <code>Clozure</code>: the former took <em>0.75 seconds</em> to run this, while the latter took about <em>4 seconds</em> (without the type annotations, <code>SBCL</code> takes <em>33 seconds</em>).</p>

<p>```lisp
(defun is-right-triangle (n1 n2 n3)
  (declare (type fixnum n1 n2 n3))
  (= (+ (expt n1 2) (expt n2 2)) (expt n3 2)))</p>

<p>(defun triangle-solutions (n)
  (declare (type fixnum n))
  ;; Largest side (hyp) can&rsquo;t be less than a third of the total
  (loop for hyp from (floor (/ n 3)) upto (&ndash; n 2)</p>

<pre><code> ;; Avoid repeating combinations, so WLOG let one side
 ;; be greater than the other
 for sides-sum = (- n hyp)
 when (loop for side1 from (ceiling (/ sides-sum 2)) to (1- sides-sum)
         for side2 = (- sides-sum side1) 
         when (is-right-triangle side1 side2 hyp)
         collect (list side1 side2 hyp))
 collect it))
</code></pre>

<p>(defun max-triangle-solutions (n)
  (declare (type fixnum n))
  ;; n cannot be less than 3
  (let* ((solutions (loop for i from 3 to n</p>

<pre><code>                   collect (length (triangle-solutions i))))
     (max-solution (loop for elem in solutions maximizing elem)))
(cons max-solution (+ 3 (position max-solution solutions)))))
</code></pre>

<p>```</p>

<p>The answer needed is given by <code>(max-triangle-solutions 1000)</code>, while any specific solution can be got by (e.g.) running <code>(triangle-solutions 120)</code> which yields <code>(((40 30 50)) ((45 24 51)) ((48 20 52)))</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 26: Reciprocal Cycles]]></title>
    <link href="http://agam.github.io/blog/2015/02/11/euler-26-reciprocal-cycles/"/>
    <updated>2015-02-11T18:07:38+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/11/euler-26-reciprocal-cycles</id>
    <content type="html"><![CDATA[<p><strong>Statutory Warning</strong>: Spoilers ahead</p>

<p><em>Problem: find the number less than 1000 with the largest repeating cycle of digits in the decimal expansion of its reciprocal</em></p>

<p>As always, the initial reacion was on the lines of <em>aha! this is obvious!</em>:</p>

<p>```lisp
(defun get-repeated-substring-length (str len)
  (let* ((rev-str (reverse str))</p>

<pre><code> (offset (- (length str) (* 2 len)))
 (match (equal (subseq rev-str 0 len)
           (reverse (subseq str offset (+ offset len))))))
(if match
len
0)))
</code></pre>

<p>(defun get-cycle-length (dec)
  (declare (type double-float dec))
  (let* ((dec-str (princ-to-string dec))</p>

<pre><code> (exp-str (subseq dec-str
          (1+ (position #\. dec-str))
          (position #\d dec-str))))
(do ((i 0 (1+ i))
 (cycle-length 0 (get-repeated-substring-length exp-str i)))
((or (&gt; cycle-length 0) (&gt; i (/ (length exp-str) 2))) cycle-length))))
</code></pre>

<p>(defun inverse-cycle-digits (n)
  (let ((inverse (/ 1.0 (coerce n &lsquo;double-float))))</p>

<pre><code>(do* ((i 0 (1+ i))
 (dec (* 1.0 inverse) (* 10.0 dec))
 (cycle-length 0 (get-cycle-length dec)))
 ((&gt; cycle-length 0) cycle-length))))
</code></pre>

<p>(defun euler-26-fail ()
  (let ((all-cycles (mapcar #&lsquo;inverse-cycle-digits (loop for i from 1 to 1000 collect i))))</p>

<pre><code>(reduce #'max all-cycles)))
</code></pre>

<p>```</p>

<p>But the aptly named <code>euler-26-fail</code> fails to do what we want, because once again, the largest reciprocal when expanded fully, lies beyond the standard <em>double-float</em> range. So, we hand-roll &hellip;</p>

<p>```lisp</p>

<p>(defun inverse (n &amp;key (precision))
  (do* ((i 0 (1+ i))</p>

<pre><code>(numerator 10 (* 10 (mod numerator n)))
(dec (floor (/ 10 n)) (floor (/ numerator n)))
(declist (list dec) (cons dec declist)))
   ((&gt; i precision) (nreverse declist))))
</code></pre>

<p>(defun cycle-length-helper (declist)
  (do ((i 0 (1+ i))</p>

<pre><code>   (cycle-length 0 (get-repeated-substring-length declist i)))
  ((or (&gt; cycle-length 0) (&gt; i (/ (length declist) 2))) cycle-length)))
</code></pre>

<p>(defun cycle-length (declist)
  (loop for length in (loop for i from 1 to (length declist)</p>

<pre><code>         collect (cycle-length-helper (subseq declist 0 i)))
   maximizing length))
</code></pre>

<p>(defun get-all-inverse-lengths (lst max-precision)
  (mapcar #&lsquo;(lambda (n) (cycle-length (inverse n :precision max-precision)))</p>

<pre><code>  lst))
</code></pre>

<p>(defun unique-max (list)
  (let ((max (reduce #&lsquo;max list)))</p>

<pre><code>(if (= 1 (count max list))
max
0)))
</code></pre>

<p>(defun biggest-cycle (max-num prec)
  (let* ((lst (loop for i from 1 to  max-num collect i))</p>

<pre><code> (lengths (get-all-inverse-lengths lst prec))
 (max-len (reduce #'max lengths)))
;;(format t "Debug: lengths = ~A, max = ~A~%" lengths max-len)
(nth (position max-len lengths) lst)))
</code></pre>

<p>```</p>

<p>The idea is to loop over all numbers with a given precision, find the max, then maybe increase the precision and try again. This is a terrible idea, relying on the ability to submit multiple answers at the Project Euler website :(</p>

<p>But more than that, it&rsquo;s terribly slow. It becomes marginally faster if we restrict our search to primes.</p>

<p>```lisp
(defun biggest-cycle (max-num prec)
  (let* ((lst (eratosthenes max-num))</p>

<pre><code> (lengths (get-all-inverse-lengths lst prec))
 (max-len (reduce #'max lengths)))
;;(format t "Debug: lengths = ~A, max = ~A~%" lengths max-len)
(nth (position max-len lengths) lst)))
</code></pre>

<p>(defun sieve (prime list)
  (if (null list)</p>

<pre><code>  (list prime)
  (cons prime (sieve (first list)
         (remove-if #'(lambda (n)
                (= 0 (mod n prime)))
                (rest list))))))
</code></pre>

<p>(defun eratosthenes (max-num)
  (let ((all-numbers (loop for i from 2 to max-num collect i)))</p>

<pre><code>(sieve (first all-numbers) (rest all-numbers))))
</code></pre>

<p>```</p>

<p>With this change, <code>(biggest-cycle 1000 1000)</code> yielded <code>499</code> (in <em>211 seconds</em>), but it turned out to be incorrect. <code>(biggest-cycle 1000 10000)</code> took <em>22810 seconds</em>, which is shameful, but yielded the right answer.</p>

<h3>Update</h3>

<p>Here is an effort to redeem myself:</p>

<p>```haskell
import qualified Data.List as L
import qualified Data.Vector as V</p>

<p>eratosthenes :: Int &ndash;> [Int]
&mdash; ^Get a list of prime numbers less than the given number.              <br/>
eratosthenes n =
  let x = [2 .. n] in
  sieve (head x) (tail x)</p>

<p>sieve :: Int &ndash;> [Int] &ndash;> [Int]
sieve p nums =
  let rest = filter (\x &ndash;> x <code>mod</code> p > 0) nums
  in if null rest</p>

<pre><code> then [p]
 else p : sieve (head rest) (tail rest)
</code></pre>

<p>inverse :: Int &ndash;> Int &ndash;> V.Vector Int      <br/>
&mdash; ^Given a number and the required precision, calculate the decimal expansion of its reciprocal.
inverse n prec =
  let truncate x y = (x <code>div</code> y, x <code>mod</code> y)</p>

<pre><code>  nextDigit x count
    | count == 0 = []
    | otherwise = let (d,m) = truncate (x * 10) n
                  in d : nextDigit m (count - 1)
</code></pre>

<p>  in
   V.fromList $ nextDigit 1 prec</p>

<p>getInverses :: Int &ndash;> Int &ndash;> [V.Vector Int]
&mdash; ^Get a list of all the inverses of all numbers upto a given number, for a given precision
getInverses maxNum maxPrec = [inverse x maxPrec | x &lt;&ndash; [1 .. maxNum]]</p>

<p>checkRepeatLength :: V.Vector Int &ndash;> Int &ndash;> Int &ndash;> Int
checkRepeatLength expansion end len =
  let s1 = V.slice (end &ndash; len) len expansion</p>

<pre><code>  s2 = V.slice (end - len - len) len expansion
  c = V.zipWith (==) s1 s2
</code></pre>

<p>  in
   if V.and c
   then len
   else 0</p>

<p>checkCycles :: V.Vector Int &ndash;> Int &ndash;> Int
&mdash; ^Check if a cycle exists at a given end point with a given length; if it does, returns the length itself, otherwise 0
checkCycles expansion end =
  let l = quot end 2</p>

<pre><code>  cycles = filter (&gt; 0) $ map (checkRepeatLength expansion end) [1 .. l]
</code></pre>

<p>  in
   case cycles of</p>

<pre><code>x:xs -&gt; x
otherwise -&gt; 0
</code></pre>

<p>findCycleLength :: V.Vector Int &ndash;> Int
&mdash; ^Get the length of a cycle at a certain end point; if none found, returns 0
findCycleLength expansion =
  let l = V.length expansion</p>

<pre><code>  minEnd = quot l 2
  cycles = filter (&gt; 0) $ map (checkCycles expansion) [l, l-1 .. minEnd]
</code></pre>

<p>  in
   case cycles of</p>

<pre><code>x:xs -&gt; x
otherwise -&gt; 0
</code></pre>

<p>euler26 :: Int &ndash;> Int
&mdash; ^Attempts to solve Euler Problem #26 for a given precision
euler26 prec =
  let nums = [2 .. 1000]</p>

<pre><code>  cycles = map (\x -&gt; findCycleLength $ inverse x prec) nums
  maxPos = L.elemIndex (maximum cycles) cycles
</code></pre>

<p>  in
   case maxPos of</p>

<pre><code>Just n -&gt; nums !! n
_ -&gt; 0
</code></pre>

<p>```</p>

<p>This gives the same answer (<code>euler26 10000</code>) in <code>7.5 seconds</code> (which is a 3000x speedup). Just to make sure you don&rsquo;t jump to that conclusion, it isn&rsquo;t a Haskell vs Lisp thing, it&rsquo;s just <em>calculating less stuff</em>, and doing it with <em>vectors instead of lists</em>.</p>

<p>In particular, the first version was running for <em>12 hours</em> before I killed it out of disgust, and realized that instead of checking if the <code>length</code> of the list was greater than 0, I should do a <code>case</code> match instead since I only needed the first element. This made a <em>big</em> difference. Also, this is the first time I <em>didn&rsquo;t</em> have to rely on <code>Debug.Trace</code>, so I feel good about that :)</p>
]]></content>
  </entry>
  
</feed>
