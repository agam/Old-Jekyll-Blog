<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cpp | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/cpp/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-03-19T03:52:17+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 38: Pandigital multiples]]></title>
    <link href="http://agam.github.io/blog/2015/03/19/euler-38-pandigital-multiples/"/>
    <updated>2015-03-19T03:41:10+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/19/euler-38-pandigital-multiples</id>
    <content type="html"><![CDATA[<p>I&rsquo;m embarassed at how ridiculously naive my solution is. In hindsight, it&rsquo;s so <em>obvious</em> that the solution <em>has</em> to be a four-digit number and its double, and that the first digit is going to be a 9.</p>

<p>Still, C++ makes you lazy. This took <code>24 milliseconds</code>, and I didn&rsquo;t feel the need to speed it up :)</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
static const long kMaxNumbers = 10000;</p>

<p>int main() {
  long largestPanDigital = 0;
  for (long num = 2; num &lt; kMaxNumbers; ++num) {</p>

<pre><code>vector&lt;int&gt; pandigits;
int o = 1;
while (o &lt;= 20) {
  long product = num * o;
  vector&lt;int&gt; pd;
  while (product &gt; 0) {
    int d = product % 10;
    if (d == 0 ||
        (std::find(pandigits.begin(), pandigits.end(), d) != pandigits.end()) ||
        (std::find(pd.begin(), pd.end(), d) != pd.end())) {
      break;
    }
    pd.push_back(d);
    product /= 10;
  }
  if (product &gt; 0) {
    // Found an existing digit
    break;
  }
  // We formed a new product; keep going!
  for (auto it = pd.rbegin(); it != pd.rend(); ++it) {
    pandigits.push_back(*it);
  }
  ++o;
}
if (pandigits.size() == 9 &amp;&amp; o &gt; 1) {
  long panDigital = 0L;
  std::cout &lt;&lt; "Found: ";
  for (auto&amp; d : pandigits) {
    std::cout &lt;&lt; d;
    panDigital = panDigital * 10 + d;
  }
  std::cout &lt;&lt; " = " &lt;&lt; num &lt;&lt; " * " &lt;&lt; o-1 &lt;&lt; std::endl;
  if (panDigital &gt; largestPanDigital) {
    largestPanDigital = panDigital;
  }
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;The largest one is &rdquo; &lt;&lt; largestPanDigital &lt;&lt; std::endl;
}
```</p>

<p>It runs as follows:</p>

<p><code>sh
$ ~/cpp/Test
Found: 918273645 = 9 * 5
Found: 192384576 = 192 * 3
Found: 219438657 = 219 * 3
Found: 273546819 = 273 * 3
Found: 327654981 = 327 * 3
Found: 672913458 = 6729 * 2
Found: 679213584 = 6792 * 2
Found: 692713854 = 6927 * 2
Found: 726914538 = 7269 * 2
Found: 729314586 = 7293 * 2
Found: 732914658 = 7329 * 2
Found: 769215384 = 7692 * 2
Found: 792315846 = 7923 * 2
Found: 793215864 = 7932 * 2
Found: 926718534 = 9267 * 2
Found: 927318546 = 9273 * 2
Found: 932718654 = 9327 * 2
The largest one is &lt;redacted&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 37: Truncatable Primes]]></title>
    <link href="http://agam.github.io/blog/2015/03/13/euler-37-truncatable-primes/"/>
    <updated>2015-03-13T07:04:08+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/13/euler-37-truncatable-primes</id>
    <content type="html"><![CDATA[<p>I realize using <em>C++</em> is a bit like cheating since the initial motive of doing ProjectEuler was to explore a new <em>language</em>. But I reserve the right to &ldquo;revise&rdquo; that motive :P. Besides, I find it hard to overrule the part of myself that just wants to know the answer <em>now</em>, <em>quickly</em>.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
static const int kMaxNumbers = 1000000;</p>

<p>void filterPrimes(vector<bool>* numbers) {
  for (int candidate = 2; candidate &lt; kMaxNumbers; ) {</p>

<pre><code>int multiple = candidate * 2;
while (multiple &lt; kMaxNumbers) {
  numbers-&gt;at(multiple) = false;
  multiple += candidate;
}
++candidate;
while (candidate &lt; kMaxNumbers &amp;&amp; !numbers-&gt;at(candidate)) {
  ++candidate;
}
if (candidate == kMaxNumbers) {
  return;
}
</code></pre>

<p>  }
}</p>

<p>int getNumber(const vector<int>&amp; digits, int start, int end) {
  int num = 0;
  for (int i = end; i >= start; &mdash;i) {</p>

<pre><code>num = num * 10 + digits[i];
</code></pre>

<p>  }
  return num;
}</p>

<p>bool isTruncatablePrime(int num, const vector<bool>&amp; primes) {
  if (num == 2 || num == 3 || num == 5 || num == 7) {</p>

<pre><code>return false;
</code></pre>

<p>  }
  assert(primes.size() == kMaxNumbers);
  vector<int> digits;
  for (int t = num; t > 0; t /= 10) {</p>

<pre><code>digits.push_back(t % 10);
</code></pre>

<p>  }
  for (int i = 0; i &lt; digits.size(); ++i) {</p>

<pre><code>int n1 = getNumber(digits, 0, i);
int n2 = getNumber(digits, i, digits.size() - 1);
if (!primes[n1] || !primes[n2]) {
  return false;
}
</code></pre>

<p>  }
  return true;
}</p>

<p>int main() {
  vector<bool> prime_candidates(kMaxNumbers, true);
  prime_candidates[0] = false;
  prime_candidates[1] = false;
  filterPrimes(&amp;prime_candidates);
  int sum_truncatables = 0;
  for (int i = 13; i &lt; kMaxNumbers; ++i) {</p>

<pre><code>if (prime_candidates[i]) {
  if (isTruncatablePrime(i, prime_candidates)) {
    std::cout &lt;&lt; "Debug: found " &lt;&lt; i &lt;&lt; std::endl;
    sum_truncatables += i;
  }
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;The sum is: &rdquo; &lt;&lt; sum_truncatables &lt;&lt; std::endl;
}
```</p>

<p>which runs as</p>

<p><code>sh
Debug: found 23
Debug: found 37
Debug: found 53
Debug: found 73
Debug: found 313
Debug: found 317
Debug: found 373
Debug: found 797
Debug: found 3137
Debug: found 3797
Debug: found 739397
The sum is: &lt;redacted&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 36: Palindromic Numbers]]></title>
    <link href="http://agam.github.io/blog/2015/03/05/euler-36-palindromic-numbers/"/>
    <updated>2015-03-05T06:10:59+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/05/euler-36-palindromic-numbers</id>
    <content type="html"><![CDATA[<p>Wha &hellip; this is getting boring.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
using std::vector;
static const int kMaxNumbers = 1000000;</p>

<p>bool isPalindromic(int n, int base) {
  vector<int> digits;
  while (n > 0) {</p>

<pre><code>digits.push_back(n % base);
n /= base;
</code></pre>

<p>  }
  int length = digits.size();
  for (int i = 0; i &lt; length/2; ++i) {</p>

<pre><code>if (digits[i] != digits[length-1-i]) {
  return false;
}
</code></pre>

<p>  }
  return true;
}</p>

<p>int main() {
  int sum = 0;
  for (int i = 1; i &lt; kMaxNumbers; ++i) {</p>

<pre><code>if (isPalindromic(i, 10) &amp;&amp; isPalindromic(i, 2)) {
  sum += i;
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;Sum of palindromic numbers = &rdquo; &lt;&lt; sum &lt;&lt; std::endl;
}
```</p>

<p>(runs in <code>931 milliseconds</code>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 35: Circular Primes]]></title>
    <link href="http://agam.github.io/blog/2015/03/04/euler-35-circular-primes/"/>
    <updated>2015-03-04T23:49:53+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/04/euler-35-circular-primes</id>
    <content type="html"><![CDATA[<p>The easy solutions continue (or, I&rsquo;ve just gotten used to C++ for these)</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
// Euler 35: A number is a circular prime if all the <em>rotations</em> of
// its digits are prime numbers.</p>

<p>using std::vector;</p>

<p>const int kMaxNumbers = 1000000;
typedef std::bitset<kMaxNumbers> AllNumbers;</p>

<p>void markMultiples(AllNumbers* v, int n) {
  const int kStart = 2 * n;
  if (kStart >= kMaxNumbers) {</p>

<pre><code>return;
</code></pre>

<p>  }
  for (int i = kStart; i &lt; kMaxNumbers; i += n) {</p>

<pre><code>v-&gt;set(i, false);
</code></pre>

<p>  }
}</p>

<p>void markPrimes(AllNumbers* v) {
  v->set(0, false);
  v->set(1, false);
  int i = 2;
  while (true) {</p>

<pre><code>markMultiples(v, i);
++i;
for (; i &lt; kMaxNumbers &amp;&amp; !v-&gt;test(i); ++i) {}
if (i == kMaxNumbers) {
  return;
}
</code></pre>

<p>  }
}</p>

<p>vector<int> getDigits(int n) {
  vector<int> v;
  while (n > 0) {</p>

<pre><code>v.push_back(n % 10);
n /= 10;
</code></pre>

<p>  }
  return v;
}</p>

<p>int getNumber(const vector<int>&amp; v) {
  int n = 0;
  for (int i = v.size()-1; i >=0; &mdash;i) {</p>

<pre><code>n = n*10 + v[i];
</code></pre>

<p>  }
  return n;
}</p>

<p>vector<int> getRotatedNumbers(int n) {
  auto v = getDigits(n);
  vector<int> numbers;
  for (int i = 0; i &lt; v.size(); ++i) {</p>

<pre><code>numbers.push_back(getNumber(v));
std::rotate(v.begin(), v.end()-1, v.end());
</code></pre>

<p>  }
  return numbers;
}</p>

<p>int main() {
  AllNumbers v;
  for (int i = 0; i &lt; kMaxNumbers; ++i) {</p>

<pre><code>v.set(i, true);
</code></pre>

<p>  }
  markPrimes(&amp;v);
  int numCircularPrimes = 0;
  for (int i = 0; i &lt; kMaxNumbers; ++i) {</p>

<pre><code>// Fail early
if (!v.test(i)) {
  continue;
}
vector&lt;int&gt; ps = getRotatedNumbers(i);
if (std::all_of(ps.begin(), ps.end(), [&amp;v](int p){return v.test(p);})) {
  ++numCircularPrimes;
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;Number of circular primes = &rdquo; &lt;&lt; numCircularPrimes &lt;&lt; std::endl;
}
```</p>

<p>It runs in <code>335 milliseconds</code> &mdash; though I&rsquo;m not sure if it is a high or a low number.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 34: Curious Numbers]]></title>
    <link href="http://agam.github.io/blog/2015/03/04/euler-34-curious-numbers/"/>
    <updated>2015-03-04T21:33:28+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/04/euler-34-curious-numbers</id>
    <content type="html"><![CDATA[<p><em>Grumble</em> &hellip; I&rsquo;m missing the tougher problems we saw earlier. This is another easy one.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
using std::vector;</p>

<p>vector<int> getDigits(int number) {
  vector<int> v;
  while (number > 0) {</p>

<pre><code>v.push_back(number % 10);
number /= 10;
</code></pre>

<p>  }
  return v;
}</p>

<p>void printVector(const vector<int>&amp; v) {
  std::cout &lt;&lt; &ldquo;[ &rdquo;;
  for (const auto&amp; d : v) {</p>

<pre><code>std::cout &lt;&lt; d &lt;&lt; ", ";
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo; ]\n&rdquo;;
}</p>

<p>int factorial(int n) {
  // Yep, crude, but it works.
  static std::unordered_map&lt;int,int> memos;
  const auto&amp; it = memos.find(n);
  if (it != memos.end()) {</p>

<pre><code>return it-&gt;second;
</code></pre>

<p>  }
  int fact = 1;
  for (int i = 1; i &lt;= n; ++i) {</p>

<pre><code>fact *= i;
</code></pre>

<p>  }
  memos[n] = fact;
  return fact;
}</p>

<p>int sumFactDigits(const vector<int>&amp; v) {
  int sum = 0;
  for (const auto&amp; d : v) {</p>

<pre><code>sum += factorial(d);
</code></pre>

<p>  }
  return sum;
}</p>

<p>int main() {
  static const int kMaxTries = 1000000;
  long sum = 0;
  for (int i = 3; i &lt; kMaxTries; ++i) {</p>

<pre><code>vector&lt;int&gt; d = getDigits(i);
if (i == sumFactDigits(d)) {
  sum += i;
  std::cout &lt;&lt; "Debug: found ";
  std::reverse(d.begin(), d.end());
  printVector(d);
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;Required sum = &rdquo; &lt;&lt; sum &lt;&lt; std::endl;
}
```</p>

<p>&hellip; and it runs as</p>

<p><code>sh
Debug: found [ 1, 4, 5,  ]
Debug: found [ 4, 0, 5, 8, 5,  ]
Required sum = &lt;redacted&gt;
</code></p>
]]></content>
  </entry>
  
</feed>
