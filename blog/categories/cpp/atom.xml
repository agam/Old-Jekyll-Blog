<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cpp | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/cpp/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-05-16T06:32:46+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 49: Prime Permutations]]></title>
    <link href="http://agam.github.io/blog/2015/05/05/euler-49-prime-permutations/"/>
    <updated>2015-05-05T06:39:11+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/05/euler-49-prime-permutations</id>
    <content type="html"><![CDATA[<p>This one took way longer than expected. I initially misunderstood the question to require 4-digit numbers <em>unique digits</em> (because that&rsquo;s what the example has!) and I went crazy trying to figure out why the <em>only</em> answer I was getting was the example in the question. Anyway I later realized I&rsquo;d over-complicated my solution and I just needed to look at numbers between <code>1000</code> and <code>9999</code>. Given this, it&rsquo;s <em>absurd</em> to have a class called &ldquo;FourDigits&rdquo; (duh), but I figured there&rsquo;s no point hiding my initial mistake :)</p>

<p>The code fragment below is bloated because I&rsquo;ve left in old code from my first attempt (the functions suffixed with <code>...Old</code>), and half the code here is dead code.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em> (well, not really)</p>

<p>```cpp
bool IsPrime(int n) {
  // Rule out even numbers
  if ((n > 2) &amp;&amp; (n % 2 == 0)) return false;</p>

<p>  // Check divisibility by odd numbers starting from 3, uptil the
  // square root of the number.
  const int lim = sqrt(n);
  for (int i = 3; i &lt;= lim; i+=2) {</p>

<pre><code>if (n % i == 0) {
  return false;
}
</code></pre>

<p>  }
  return true;
}</p>

<p>bool HasArithmeticSequence(const vector<int>&amp; v) {
  assert(v.size() >= 3);
  // Assumes sorted vector of ints
  struct diff {</p>

<pre><code>int n1, n2, d;
</code></pre>

<p>  };
  vector<diff> diffs;
  // Get the diffs between all elements, then find two pairs with the
  // same diff (yes, N<sup>2</sup>, but will do). The two pairs must share a
  // number, i.e. V_i + d = V_j, and V_j + d = V_k.
  for (int i = 0; i &lt; v.size() &ndash; 1; ++i) {</p>

<pre><code>for (int j = i+1; j &lt; v.size(); ++j) {
  assert(v[j] &gt; v[i]);
  diffs.push_back( { v[i], v[j], v[j] - v[i] } );
}
</code></pre>

<p>  }
  std::sort(diffs.begin(), diffs.end(),</p>

<pre><code>        [](const diff&amp; df1, const diff&amp; df2) {
          return df1.d &lt; df2.d;
        });
</code></pre>

<p>  // Now that we have grouped elements by their difference, we can
  // analyze each &lsquo;cluster&rsquo; to find the pairs we want.
  for (int i = 0; i &lt; diffs.size() &ndash; 1; ++i) {</p>

<pre><code>// Yes, it's inefficient, but ...
int d = diffs[i].d;
for (int j = i + 1; diffs[j].d == d; ++j) {
  if (diffs[i].n2 == diffs[j].n1) {
    cout &lt;&lt; "Found arithmetic progression: "
         &lt;&lt; diffs[i].n1 &lt;&lt; " -&gt; "
         &lt;&lt; diffs[i].n2 &lt;&lt; " -&gt; "
         &lt;&lt; diffs[j].n2 &lt;&lt; endl;
    return true;
  }
}
</code></pre>

<p>  }
  return false;
}</p>

<p>class FourDigitCombinator {
public:
  FourDigitCombinator() : digits<em>({0,1,2,3}), number</em>(1000) {}</p>

<p>  string GetDigitsOld() {</p>

<pre><code>std::ostringstream stream;
for (int i = 0; i &lt; kNumDigits; ++i) {
  stream &lt;&lt; digits_[i];
}
return stream.str();
</code></pre>

<p>  }</p>

<p>  bool NextOld() {</p>

<pre><code>sanity_check();
// See if there is a prior number that can be incremented
for (int i = kNumDigits - 1; i &gt;= 0; --i) {
  // The last digit can go up to kMaxDigit, the previous one up to
  // kMaxDigit - 1, and so on ...
  const int digitMax = kMaxDigit - kNumDigits + i + 1;
  int digitValue = digits_[i];
  assert(digitValue &lt;= digitMax);
  if (digitValue == digitMax) {
    // We've hit the limit for this digit. If this is the first
    // digit, we've reached the end.
    if (i == 0) {
      return false;
    }
    // Otherwise, fall through to the previous digit ...
  } else {
    // Increment, and reset subsequent digits, if any.
    for (int j = i; j &lt; kNumDigits; ++j) {
      ++digitValue;
      digits_[j] = digitValue;
    }
    return true;
  }
}
assert(false);  // We should not get here!
</code></pre>

<p>  }</p>

<p>  bool HasPrimePermutationsOld() {</p>

<pre><code>array&lt;int, kNumDigits&gt; mutation = digits_;
vector&lt;int&gt; prime_mutations;
do {
  // Skip permutations with a leading zero.
  if (mutation[0] == 0) continue;

  // Create the corresponding number
  int number = 0;
  for (int i = 0; i &lt; kNumDigits; ++i) {
    number = number * 10 + mutation[i];
  }
  if (IsPrime(number)) {
    prime_mutations.push_back(number);
  }
} while (std::next_permutation(mutation.begin(), mutation.end()));

if ((prime_mutations.size() &gt;= 3) &amp;&amp; HasArithmeticSequence(prime_mutations)) {
  return true;
}
return false;
</code></pre>

<p>  }</p>

<p>  string GetDigits() {</p>

<pre><code>std::ostringstream stream;
stream &lt;&lt; number_;
return stream.str();
</code></pre>

<p>  }</p>

<p>  bool Next() {</p>

<pre><code>if (number_ &lt; 9999) {
  ++number_;
  return true;
}
return false;
</code></pre>

<p>  }</p>

<p>  bool HasPrimePermutations() {</p>

<pre><code>array&lt;int, kNumDigits&gt; mutation;
assert(number_ &gt;= 1000 &amp;&amp; number_ &lt;= 9999);

// Convert number into an array of digits ...
int n = number_;
int digit_index = kNumDigits - 1;
while (n &gt; 0) {
  mutation[digit_index--] = n % 10;
  n /= 10;
}

vector&lt;int&gt; prime_mutations;
do {
  // ... then convert the array of digits back into a number!
  int num = 0;
  for (int i = 0; i &lt; kNumDigits; ++i) {
    num = num * 10 + mutation[i];
  }
  assert(num &gt;= 1000 &amp;&amp; num &lt;= 9999);
  if (IsPrime(num)) {
    prime_mutations.push_back(num);
  }
} while (std::next_permutation(mutation.begin(), mutation.end()));

if ((prime_mutations.size() &gt;= 3) &amp;&amp; HasArithmeticSequence(prime_mutations)) {
  return true;
}
return false;
</code></pre>

<p>  }</p>

<p>private:
  static const int kNumDigits = 4;
  static const int kMaxDigit = 9;
  array&lt;int, kNumDigits> digits<em>;
  int number</em>;</p>

<p>  void sanity_check() {</p>

<pre><code>for (int i = 0; i &lt; kNumDigits - 1; ++i) {
  assert(digits_[i] &lt; digits_[i+1]);
}
</code></pre>

<p>  }
};</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #49 &hellip; \n&rdquo;;</p>

<p>  set<string> candidates;</p>

<p>  // Go over all sets of four digits, and consider the permutations of
  // each to see if any group of three permutations is prime.
  FourDigitCombinator four_digits;
  do {</p>

<pre><code>if (four_digits.HasPrimePermutations()) {
  candidates.insert(four_digits.GetDigits());
}
</code></pre>

<p>  } while (four_digits.Next());</p>

<p>  // Debugging aid &hellip; check if any combinations matched.
  for (const auto&amp; c : candidates) {</p>

<pre><code>cout &lt;&lt; "Debug: found : " &lt;&lt; c &lt;&lt; endl;
</code></pre>

<p>  }
}
```</p>

<p>And it runs as &hellip;</p>

<p>```sh
$ time ./Test
Euler #49 &hellip;
Found arithmetic progression: 1487 &ndash;> 4817 &ndash;> 8147
Found arithmetic progression: 1487 &ndash;> 4817 &ndash;> 8147
Found arithmetic progression: 2969 &ndash;> 6299 &ndash;> 9629
Found arithmetic progression: 2969 &ndash;> 6299 &ndash;> 9629
Debug: found : 1478
Debug: found : 1487
Debug: found : 2699
Debug: found : 2969</p>

<p>real    0m0.019s
user    0m0.016s
sys     0m0.000s
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 48: Self powers]]></title>
    <link href="http://agam.github.io/blog/2015/05/04/euler-48-self-powers/"/>
    <updated>2015-05-04T03:09:53+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/04/euler-48-self-powers</id>
    <content type="html"><![CDATA[<p>One of the simplest problems, that would be a one-liner in Python or Lisp. Decided to do it in C++ anyway, using the <code>GMP</code> library (verbose, but runs in <code>4 ms</code>)</p>

<p>For this to work, you&rsquo;ll need to add (e.g. for <code>CMake</code>) a line like <code>target_link_libraries(Test gmpxx gmp)</code>, and include <code>gmpxx.h</code>.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```cpp
int main() {
  cout &lt;&lt; &ldquo;Euler #48 &hellip; \n&rdquo;;
  const int kNumTerms = 1000;</p>

<p>  // GMP has a C++ interface, see the following link:
  // <a href="https://gmplib.org/manual/C_002b_002b-Interface-General.html">https://gmplib.org/manual/C_002b_002b-Interface-General.html</a>
  mpz_class sum = 0;</p>

<p>  // Loop from 1 to 1000
  for (int i = 1; i &lt;= kNumTerms; ++i) {</p>

<pre><code>mpz_class term = 0;

// GMP exponentiation function, see documentation at:
// https://gmplib.org/manual/Integer-Exponentiation.html
mpz_ui_pow_ui(term.get_mpz_t(), i, i);

sum = sum + term;
</code></pre>

<p>  }</p>

<p>  mpz_class last_ten_digits;</p>

<p>  // We&rsquo;re looking for sum modulo (10 ^ 10)
  mpz_class divisor;
  mpz_ui_pow_ui(divisor.get_mpz_t(), 10, 10);
  mpz_mod(last_ten_digits.get_mpz_t(), sum.get_mpz_t(), divisor.get_mpz_t());
  cout &lt;&lt; &ldquo;The final answer is : &rdquo; &lt;&lt; last_ten_digits &lt;&lt; endl;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 47: Distinct Prime Factors]]></title>
    <link href="http://agam.github.io/blog/2015/05/04/euler-47-distinct-prime-factors/"/>
    <updated>2015-05-04T01:00:00+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/04/euler-47-distinct-prime-factors</id>
    <content type="html"><![CDATA[<p>This one turned out to be very similar to the previous one (except for the small detail of iterating from the smallest prime upwards, instead of the other way round).</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```cpp
class PrimeIterator {
public:
  PrimeIterator() : prime_index_(-1) {}</p>

<p>  int getNextPrime() {</p>

<pre><code>assert((prime_index_ + 1) &lt; primes_.size());
return primes_[++prime_index_];
</code></pre>

<p>  }</p>

<p>  bool hasMorePrimes() {</p>

<pre><code>assert(prime_index_ &gt;= -1 &amp;&amp; (prime_index_ + 1) &lt;= primes_.size());
return (prime_index_ + 1) &lt; primes_.size();
</code></pre>

<p>  }</p>

<p>  void fillPrimes(int max) {</p>

<pre><code>while (primes_.back() &lt;= max) {
  addPrime();
}
// Reset to before the first element
prime_index_ = -1;
</code></pre>

<p>  }</p>

<p>private:
  static void addPrime() {</p>

<pre><code>assert(primes_.size() &gt; 0);
int n = primes_.back();
while (true) {
  ++n;
  bool is_prime = true;
  for (const int&amp; p : primes_) {
    if (n % p == 0) {
      is_prime = false;
      break;  // Try next number
    }
  }
  if (is_prime) {
    primes_.push_back(n);
    return;
  }
}
</code></pre>

<p>  }</p>

<p>  static vector<int> primes_;</p>

<p>  int prime_index_;
};</p>

<p>vector<int> PrimeIterator::primes_ = {2};</p>

<p>int getNumPrimeFactors(int n) {
  int numPrimeFactors = 0;
  PrimeIterator pit;
  pit.fillPrimes(n);
  while (n > 1 &amp;&amp; pit.hasMorePrimes()) {</p>

<pre><code>int p = pit.getNextPrime();
if (n % p == 0) {
  while (n % p == 0) {
    n /= p;
  }
  ++numPrimeFactors;
}
</code></pre>

<p>  }
  return numPrimeFactors;
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #47 &hellip; \n&rdquo;;</p>

<p>  int runLength = 0;
  for (int n = 2; ; ++n) {</p>

<pre><code>if (getNumPrimeFactors(n) == 4) {
  ++runLength;
} else {
  runLength = 0;
}
if (runLength == 4) {
  cout &lt;&lt; "Found a sequence of four numbers with four prime "
       &lt;&lt; "factors starting at : " &lt;&lt; n - 3 &lt;&lt; endl;
  return 0;
}
</code></pre>

<p>  }
}
```</p>

<p>Runs as follows:</p>

<p>```sh
$ time ./Test
Euler #47 &hellip;
Found a sequence of four numbers with four prime factors starting at : <redacted></p>

<p>real    0m3.814s
user    0m3.812s
sys     0m0.000s
```</p>

<p>(Yep, a noticeable delay, but anything under 5 seconds is good for me &hellip;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 46: Goldbach's Other Conjecture]]></title>
    <link href="http://agam.github.io/blog/2015/05/03/euler-46-goldbacks-other-conjecture/"/>
    <updated>2015-05-03T23:46:24+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/03/euler-46-goldbacks-other-conjecture</id>
    <content type="html"><![CDATA[<p>May the brute force be with you. Here is another one (sorry for the over-engineered code).</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
class PrimeIterator {
public:
  PrimeIterator() : prime_index<em>(primes</em>.size() &ndash; 1) {}</p>

<p>  int getNextPrime() {</p>

<pre><code>assert(prime_index_ &gt; 0);
return primes_[--prime_index_];
</code></pre>

<p>  }</p>

<p>  bool hasMorePrimes() {</p>

<pre><code>return prime_index_ &gt; 0;
</code></pre>

<p>  }</p>

<p>  void fillPrimes(int max) {</p>

<pre><code>while (primes_.back() &lt;= max) {
  addPrime();
}
// Reset to the last element
prime_index_ = primes_.size() - 1;
</code></pre>

<p>  }</p>

<p>private:
  static void addPrime() {</p>

<pre><code>assert(primes_.size() &gt; 0);
int n = primes_.back();
while (true) {
  ++n;
  bool is_prime = true;
  for (const int&amp; p : primes_) {
    if (n % p == 0) {
      is_prime = false;
      break;  // Try next number
    }
  }
  if (is_prime) {
    primes_.push_back(n);
    return;
  }
}
</code></pre>

<p>  }</p>

<p>  static vector<int> primes_;</p>

<p>  int prime_index_;
};</p>

<p>vector<int> PrimeIterator::primes_ = {2};</p>

<p>bool goldbachDecompositionExists(int n) {
  assert(n % 2 == 1);
  // n = p + 2<em>m<sup>2</sup>
  // Since 2</em>m<sup>2</sup> is always even, and n is odd, p must be odd too (so p has to be 3 or greater)</p>

<p>  // Use a generator to get more primes on demand.
  PrimeIterator pit;
  pit.fillPrimes(n);
  while (pit.hasMorePrimes()) {</p>

<pre><code>int p = pit.getNextPrime();
if (p == n) {
  // If n is a prime, then n = p + 2*(0*0)
  return true;
}
double sq = (n - p)/2.0;
if (sqrt(sq) == floor(sqrt(sq))) {
  // n = p + 2*sqrt(sq)
  return true;
}
</code></pre>

<p>  }
  return false;
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #46 &hellip; \n&rdquo;;</p>

<p>  // Loop over odd composite numbers &hellip;
  for (int i = 9; ; i+= 2) {</p>

<pre><code>if (!goldbachDecompositionExists(i)) {
  cout &lt;&lt; "Failed at " &lt;&lt; i &lt;&lt; endl;
  return -1;
}
</code></pre>

<p>  }
}
```</p>

<p>Runs as follows:</p>

<p>```sh
$ time ./Test
Euler #46 &hellip;
Failed at <redacted></p>

<p>real    0m0.007s
user    0m0.004s
sys     0m0.000s
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 45: Triangle, Pengagonal, Hexagonal Numbers]]></title>
    <link href="http://agam.github.io/blog/2015/04/28/euler-44-triangle/"/>
    <updated>2015-04-28T19:41:00+00:00</updated>
    <id>http://agam.github.io/blog/2015/04/28/euler-44-triangle</id>
    <content type="html"><![CDATA[<p>While we&rsquo;re doing brute force solutions, here&rsquo;s another one &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```c++
uint64_t get_triangle(uint64_t n) {
  return n * (n + 1) / 2;
}</p>

<p>bool is_pentagonal(uint64_t num) {
  // y = x * (3*x &ndash; 1) / 2
  // So x is an integral solution of 3x<sup>2</sup> + (-1)x + (-2y) = 0
  // &hellip; or (1 + sqrt(1 + 24y))/6</p>

<p>  double solution = (1 + sqrt(1 + 24 * num)) / 6.0;
  double dummy;
  return (std::modf(solution, &amp;dummy) == 0.0);
}</p>

<p>bool is_hexagonal(uint64_t num) {
  // y = x * (2*x &ndash; 1)
  // So x is an integral solution of 2x<sup>2</sup> + (-1)x + (-y) = 0
  // &hellip; or (1 + sqrt(1 + 8y))/4</p>

<p>  double solution = (1 + sqrt(1 + 8 * num)) / 4.0;
  double dummy;
  return (std::modf(solution, &amp;dummy) == 0.0);
}</p>

<p>void sanity_check() {
  uint64_t t285 = get_triangle(285);
  assert(t285 == 40755);
  assert(is_pentagonal(t285));
  assert(is_hexagonal(t285));
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler # 45 &hellip; \n\n&rdquo;;</p>

<p>  sanity_check();
  // We already now that T_285 is pentagonal and hexagonal, so start
  // from the next index;
  uint64_t i = 286;
  for (; ; ++i) {</p>

<pre><code>uint64_t num = get_triangle(i);
if (is_pentagonal(num) &amp;&amp; is_hexagonal(num)) {
  cout &lt;&lt; "Found triangle# " &lt;&lt; i &lt;&lt; "  (" &lt;&lt; num &lt;&lt; ")" &lt;&lt; endl;
  return 0;
}
if (i % 100000 == 0) {
  cout &lt;&lt; "Done testing " &lt;&lt; i &lt;&lt; endl;
}
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
</feed>
