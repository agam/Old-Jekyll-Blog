<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cpp | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/cpp/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-05-04T01:02:21+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 47: Distinct Prime Factors]]></title>
    <link href="http://agam.github.io/blog/2015/05/04/euler-47-distinct-prime-factors/"/>
    <updated>2015-05-04T01:00:00+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/04/euler-47-distinct-prime-factors</id>
    <content type="html"><![CDATA[<p>This one turned out to be very similar to the previous one (except for the small detail of iterating from the smallest prime upwards, instead of the other way round).</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```cpp
class PrimeIterator {
public:
  PrimeIterator() : prime_index_(-1) {}</p>

<p>  int getNextPrime() {</p>

<pre><code>assert((prime_index_ + 1) &lt; primes_.size());
return primes_[++prime_index_];
</code></pre>

<p>  }</p>

<p>  bool hasMorePrimes() {</p>

<pre><code>assert(prime_index_ &gt;= -1 &amp;&amp; (prime_index_ + 1) &lt;= primes_.size());
return (prime_index_ + 1) &lt; primes_.size();
</code></pre>

<p>  }</p>

<p>  void fillPrimes(int max) {</p>

<pre><code>while (primes_.back() &lt;= max) {
  addPrime();
}
// Reset to before the first element
prime_index_ = -1;
</code></pre>

<p>  }</p>

<p>private:
  static void addPrime() {</p>

<pre><code>assert(primes_.size() &gt; 0);
int n = primes_.back();
while (true) {
  ++n;
  bool is_prime = true;
  for (const int&amp; p : primes_) {
    if (n % p == 0) {
      is_prime = false;
      break;  // Try next number
    }
  }
  if (is_prime) {
    primes_.push_back(n);
    return;
  }
}
</code></pre>

<p>  }</p>

<p>  static vector<int> primes_;</p>

<p>  int prime_index_;
};</p>

<p>vector<int> PrimeIterator::primes_ = {2};</p>

<p>int getNumPrimeFactors(int n) {
  int numPrimeFactors = 0;
  PrimeIterator pit;
  pit.fillPrimes(n);
  while (n > 1 &amp;&amp; pit.hasMorePrimes()) {</p>

<pre><code>int p = pit.getNextPrime();
if (n % p == 0) {
  while (n % p == 0) {
    n /= p;
  }
  ++numPrimeFactors;
}
</code></pre>

<p>  }
  return numPrimeFactors;
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #47 &hellip; \n&rdquo;;</p>

<p>  int runLength = 0;
  for (int n = 2; ; ++n) {</p>

<pre><code>if (getNumPrimeFactors(n) == 4) {
  ++runLength;
} else {
  runLength = 0;
}
if (runLength == 4) {
  cout &lt;&lt; "Found a sequence of four numbers with four prime "
       &lt;&lt; "factors starting at : " &lt;&lt; n - 3 &lt;&lt; endl;
  return 0;
}
</code></pre>

<p>  }
}
```</p>

<p>Runs as follows:</p>

<p>```sh
$ time ./Test
Euler #47 &hellip;
Found a sequence of four numbers with four prime factors starting at : <redacted></p>

<p>real    0m3.814s
user    0m3.812s
sys     0m0.000s
```</p>

<p>(Yep, a noticeable delay, but anything under 5 seconds is good for me &hellip;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 46: Goldbach's Other Conjecture]]></title>
    <link href="http://agam.github.io/blog/2015/05/03/euler-46-goldbacks-other-conjecture/"/>
    <updated>2015-05-03T23:46:24+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/03/euler-46-goldbacks-other-conjecture</id>
    <content type="html"><![CDATA[<p>May the brute force be with you. Here is another one (sorry for the over-engineered code).</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
class PrimeIterator {
public:
  PrimeIterator() : prime_index<em>(primes</em>.size() &ndash; 1) {}</p>

<p>  int getNextPrime() {</p>

<pre><code>assert(prime_index_ &gt; 0);
return primes_[--prime_index_];
</code></pre>

<p>  }</p>

<p>  bool hasMorePrimes() {</p>

<pre><code>return prime_index_ &gt; 0;
</code></pre>

<p>  }</p>

<p>  void fillPrimes(int max) {</p>

<pre><code>while (primes_.back() &lt;= max) {
  addPrime();
}
// Reset to the last element
prime_index_ = primes_.size() - 1;
</code></pre>

<p>  }</p>

<p>private:
  static void addPrime() {</p>

<pre><code>assert(primes_.size() &gt; 0);
int n = primes_.back();
while (true) {
  ++n;
  bool is_prime = true;
  for (const int&amp; p : primes_) {
    if (n % p == 0) {
      is_prime = false;
      break;  // Try next number
    }
  }
  if (is_prime) {
    primes_.push_back(n);
    return;
  }
}
</code></pre>

<p>  }</p>

<p>  static vector<int> primes_;</p>

<p>  int prime_index_;
};</p>

<p>vector<int> PrimeIterator::primes_ = {2};</p>

<p>bool goldbachDecompositionExists(int n) {
  assert(n % 2 == 1);
  // n = p + 2<em>m<sup>2</sup>
  // Since 2</em>m<sup>2</sup> is always even, and n is odd, p must be odd too (so p has to be 3 or greater)</p>

<p>  // Use a generator to get more primes on demand.
  PrimeIterator pit;
  pit.fillPrimes(n);
  while (pit.hasMorePrimes()) {</p>

<pre><code>int p = pit.getNextPrime();
if (p == n) {
  // If n is a prime, then n = p + 2*(0*0)
  return true;
}
double sq = (n - p)/2.0;
if (sqrt(sq) == floor(sqrt(sq))) {
  // n = p + 2*sqrt(sq)
  return true;
}
</code></pre>

<p>  }
  return false;
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #46 &hellip; \n&rdquo;;</p>

<p>  // Loop over odd composite numbers &hellip;
  for (int i = 9; ; i+= 2) {</p>

<pre><code>if (!goldbachDecompositionExists(i)) {
  cout &lt;&lt; "Failed at " &lt;&lt; i &lt;&lt; endl;
  return -1;
}
</code></pre>

<p>  }
}
```</p>

<p>Runs as follows:</p>

<p>```sh
$ time ./Test
Euler #46 &hellip;
Failed at <redacted></p>

<p>real    0m0.007s
user    0m0.004s
sys     0m0.000s
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 45: Triangle, Pengagonal, Hexagonal Numbers]]></title>
    <link href="http://agam.github.io/blog/2015/04/28/euler-44-triangle/"/>
    <updated>2015-04-28T19:41:00+00:00</updated>
    <id>http://agam.github.io/blog/2015/04/28/euler-44-triangle</id>
    <content type="html"><![CDATA[<p>While we&rsquo;re doing brute force solutions, here&rsquo;s another one &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```c++
uint64_t get_triangle(uint64_t n) {
  return n * (n + 1) / 2;
}</p>

<p>bool is_pentagonal(uint64_t num) {
  // y = x * (3*x &ndash; 1) / 2
  // So x is an integral solution of 3x<sup>2</sup> + (-1)x + (-2y) = 0
  // &hellip; or (1 + sqrt(1 + 24y))/6</p>

<p>  double solution = (1 + sqrt(1 + 24 * num)) / 6.0;
  double dummy;
  return (std::modf(solution, &amp;dummy) == 0.0);
}</p>

<p>bool is_hexagonal(uint64_t num) {
  // y = x * (2*x &ndash; 1)
  // So x is an integral solution of 2x<sup>2</sup> + (-1)x + (-y) = 0
  // &hellip; or (1 + sqrt(1 + 8y))/4</p>

<p>  double solution = (1 + sqrt(1 + 8 * num)) / 4.0;
  double dummy;
  return (std::modf(solution, &amp;dummy) == 0.0);
}</p>

<p>void sanity_check() {
  uint64_t t285 = get_triangle(285);
  assert(t285 == 40755);
  assert(is_pentagonal(t285));
  assert(is_hexagonal(t285));
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler # 45 &hellip; \n\n&rdquo;;</p>

<p>  sanity_check();
  // We already now that T_285 is pentagonal and hexagonal, so start
  // from the next index;
  uint64_t i = 286;
  for (; ; ++i) {</p>

<pre><code>uint64_t num = get_triangle(i);
if (is_pentagonal(num) &amp;&amp; is_hexagonal(num)) {
  cout &lt;&lt; "Found triangle# " &lt;&lt; i &lt;&lt; "  (" &lt;&lt; num &lt;&lt; ")" &lt;&lt; endl;
  return 0;
}
if (i % 100000 == 0) {
  cout &lt;&lt; "Done testing " &lt;&lt; i &lt;&lt; endl;
}
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 44: Pentagonal Numbers]]></title>
    <link href="http://agam.github.io/blog/2015/04/28/euler-44-pentagonal-numbers/"/>
    <updated>2015-04-28T18:08:09+00:00</updated>
    <id>http://agam.github.io/blog/2015/04/28/euler-44-pentagonal-numbers</id>
    <content type="html"><![CDATA[<p>I said I&rsquo;d try to work out the next problem on paper, but I gave up and wrote a program for it again :(</p>

<p>I honestly thought it would take a long time to run, with the final answer some grotesquely long number &hellip; but I was mistaken. ProjectEuler agrees with this assessment, since this happens to be officially categorized as among the <em>fifty easiest problems</em> (!)</p>

<p>It took just <code>90ms</code> to run, which is simply too much of a tradeoff to pass up.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```c++
uint64_t get_pentagonal(int n) {
  assert(n > 0);
  return n * (3 * n &ndash; 1) / 2;
}</p>

<p>bool is_pentagonal(uint64_t num) {
  // y = x * (3*x &ndash; 1) / 2
  // So x is an integral solution of 3x<sup>2</sup> + (-1)x + (-2y) = 0
  // &hellip; or (1 + sqrt(1 + 24y))/6</p>

<p>  double solution = (1 + sqrt(1 + 24 * num)) / 6.0;
  double dummy;</p>

<p>  // Check if the solution is an integer
  return (std::modf(solution, &amp;dummy) == 0.0);
}</p>

<p>bool check_pentagonal(int i, int j) {
  assert(i > 0 &amp;&amp; j > 0);
  assert(j &lt; i);
  uint64_t penta_i = get_pentagonal(i);
  uint64_t penta_j = get_pentagonal(j);
  uint64_t sum = penta_i + penta_j;
  uint64_t diff = penta_i &ndash; penta_j;
  if (is_pentagonal(sum) &amp;&amp; is_pentagonal(diff)) {</p>

<pre><code>cout &lt;&lt; "Found match for i = " &lt;&lt; i
     &lt;&lt; " and j = " &lt;&lt; j
     &lt;&lt; ", with diff = " &lt;&lt; diff &lt;&lt; endl;
return true;
</code></pre>

<p>  } else {</p>

<pre><code>return false;
</code></pre>

<p>  }
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler # 44 &hellip; \n\n&rdquo;;
  int i = 0;
  for (int i = 0; ; ++i) {</p>

<pre><code>for (int j = i-1; j &gt; 0; --j) {
  if (check_pentagonal(i,j)) {
    return 0;
  }
}
if (i % 1000 == 0) {
  cout &lt;&lt; "Done testing " &lt;&lt; i &lt;&lt; endl;
}
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 38: Pandigital multiples]]></title>
    <link href="http://agam.github.io/blog/2015/03/19/euler-38-pandigital-multiples/"/>
    <updated>2015-03-19T03:41:10+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/19/euler-38-pandigital-multiples</id>
    <content type="html"><![CDATA[<p>I&rsquo;m embarassed at how ridiculously naive my solution is. In hindsight, it&rsquo;s so <em>obvious</em> that the solution <em>has</em> to be a four-digit number and its double, and that the first digit is going to be a 9.</p>

<p>Still, C++ makes you lazy. This took <code>24 milliseconds</code>, and I didn&rsquo;t feel the need to speed it up :)</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
static const long kMaxNumbers = 10000;</p>

<p>int main() {
  long largestPanDigital = 0;
  for (long num = 2; num &lt; kMaxNumbers; ++num) {</p>

<pre><code>vector&lt;int&gt; pandigits;
int o = 1;
while (o &lt;= 20) {
  long product = num * o;
  vector&lt;int&gt; pd;
  while (product &gt; 0) {
    int d = product % 10;
    if (d == 0 ||
        (std::find(pandigits.begin(), pandigits.end(), d) != pandigits.end()) ||
        (std::find(pd.begin(), pd.end(), d) != pd.end())) {
      break;
    }
    pd.push_back(d);
    product /= 10;
  }
  if (product &gt; 0) {
    // Found an existing digit
    break;
  }
  // We formed a new product; keep going!
  for (auto it = pd.rbegin(); it != pd.rend(); ++it) {
    pandigits.push_back(*it);
  }
  ++o;
}
if (pandigits.size() == 9 &amp;&amp; o &gt; 1) {
  long panDigital = 0L;
  std::cout &lt;&lt; "Found: ";
  for (auto&amp; d : pandigits) {
    std::cout &lt;&lt; d;
    panDigital = panDigital * 10 + d;
  }
  std::cout &lt;&lt; " = " &lt;&lt; num &lt;&lt; " * " &lt;&lt; o-1 &lt;&lt; std::endl;
  if (panDigital &gt; largestPanDigital) {
    largestPanDigital = panDigital;
  }
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;The largest one is &rdquo; &lt;&lt; largestPanDigital &lt;&lt; std::endl;
}
```</p>

<p>It runs as follows:</p>

<p><code>sh
$ ~/cpp/Test
Found: 918273645 = 9 * 5
Found: 192384576 = 192 * 3
Found: 219438657 = 219 * 3
Found: 273546819 = 273 * 3
Found: 327654981 = 327 * 3
Found: 672913458 = 6729 * 2
Found: 679213584 = 6792 * 2
Found: 692713854 = 6927 * 2
Found: 726914538 = 7269 * 2
Found: 729314586 = 7293 * 2
Found: 732914658 = 7329 * 2
Found: 769215384 = 7692 * 2
Found: 792315846 = 7923 * 2
Found: 793215864 = 7932 * 2
Found: 926718534 = 9267 * 2
Found: 927318546 = 9273 * 2
Found: 932718654 = 9327 * 2
The largest one is &lt;redacted&gt;
</code></p>
]]></content>
  </entry>
  
</feed>
