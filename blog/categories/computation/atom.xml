<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Computation, | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/computation/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2014-02-14T00:27:45+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Duality of Computation]]></title>
    <link href="http://agam.github.io/blog/2014/02/14/duality-of-computation/"/>
    <updated>2014-02-14T00:22:00+00:00</updated>
    <id>http://agam.github.io/blog/2014/02/14/duality-of-computation</id>
    <content type="html"><![CDATA[<p>The notion of computabilty includes two very different abstractions &mdash; turing machines, and lambda calculus. I like to think of them as representing two extreme ends of a spectrum.</p>

<h2>Turing&rsquo;s Zoo of Things</h2>

<p>One, the turing machine, deals very specifically with <em>things</em>. Things are encoded in some form, and by jumping back and forth, reading and writing individual <em>bits</em>, we can transform some things into different things, or &ldquo;create&rdquo; and &ldquo;destroy&rdquo; things.</p>

<h3>Doing, Doing, Always Doing</h3>

<p>All operations in the turing machine are essentially some sort of &ldquo;thing&rdquo; operations. An operation may or may not change the given representation of some object that is its nominal argument, but it has to <em>do</em> something. This <em>doing</em> has to be represented by the modification of <em>some</em> state, <em>somewhere</em>.</p>

<h3>Turingness, Complete</h3>

<p>The fact that we are able to construct large ordered sets of bits, trillions of them clustered in a tiny physical volume, is why the abstraction of the turing machine most closely matches our physical computers.</p>

<h2>Frozen Functions, Frozen Time</h2>

<p>Lambda Calculus exists at the other end of this computation spectrum. Here everything is a <em>pattern</em> (a <em>function</em>, but that name is so overloaded everywhere &mdash; how else to refrain from confusing these with the <em>operations</em> in the turing machine?).</p>

<p>&ldquo;Constants&rdquo; are patterns too. <code>One</code> and <code>Two</code> are just &ldquo;a pattern that looks like this&rdquo; or &ldquo;a pattern that looks like that&rdquo;. More complicated patterns might be composed of simpler ones, though what is &ldquo;complex&rdquo; vs &ldquo;simple&rdquo;, or &ldquo;large&rdquo; vs &ldquo;small&rdquo; is not readily apparent here.</p>

<p>So what is analogous to the turing machine&rsquo;s <em>doing</em>, here ? It might be <em>application</em>.</p>

<h3>(Apply This)</h3>

<p>Application is this strange (process? idea?) concept where the conjunction of two patterns can <em>result</em> in a new pattern. Except it doesn&rsquo;t really (or at least I don&rsquo;t think of it that way).</p>

<p>The application of pattern <code>X</code> to pattern <code>Y</code> may <em>result</em> in pattern <code>Z</code> (which by the way might be (representationally) vastly simpler than either, or more complicated than both), but this just means that <code>(X Y)</code> is a notation for <code>Z</code>, and if you had to refer to <code>Z</code> you would use whichever was shorter.</p>

<h2>Common ground: Agency</h2>

<p>The only common concept that I see between the two is (atleast conceptually) the necessity (?) of an <em>agent</em>.</p>

<p>That is to say, whatever is <em>doing</em> in a turing machine, is <em>applying</em> in lambda calculus.</p>

<h2>Differences, or Analogies</h2>

<p>One of the two <em>processes</em> (if I may call them that) results in large scale state change, while the other results in different patterns being (created? revealed?) referenced.</p>

<p>One has built into it an explicit notion of digital time (steps in a turing machine) while the other doesn&rsquo;t. You might say that given state <code>s1</code> and current position <code>p</code>, after time <code>t</code> you would find state <code>s2</code>, but it&rsquo;s not obvious to me what the analogous concept in lambda calculus would be.</p>

<p>All patterns (or <em>forms</em>) already exist (in some sense) and while the agent, as the result of successive application (or <em>evaluation</em>) of a given &ldquo;initial pattern&rdquo; might &ldquo;see&rdquo; a series of patterns over time, there is no equivalent mapping of a pattern to an instant of time (though in practice, we can speak of the &ldquo;representation&rdquo; of a given pattern being evaluated at the current tick).</p>

<p>One has <em>meaning</em> determined by some interpretation of the state at a given instant of time, the other has meaning determined by the <em>shape</em> of the current pattern.</p>

<h2>Conclusion</h2>

<p>I have none. This post ends abruptly, right here (again, apologies for being so vague; but thats why I posted my <a href="http://agam.github.io/blog/2014/02/13/sop/"><em>SOP</em></a>).</p>
]]></content>
  </entry>
  
</feed>
