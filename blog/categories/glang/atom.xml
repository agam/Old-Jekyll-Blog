<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: glang | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/glang/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-05-17T04:41:30+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Daily programming: logs down the river]]></title>
    <link href="http://agam.github.io/blog/2014/12/27/daily-programming-logs-down-the-river/"/>
    <updated>2014-12-27T02:11:28+00:00</updated>
    <id>http://agam.github.io/blog/2014/12/27/daily-programming-logs-down-the-river</id>
    <content type="html"><![CDATA[<p>Found <a href="http://www.reddit.com/r/dailyprogrammer/comments/2lljyq/11052014_challenge_187_hard_lumberjack_floating/">this problem</a> from about a month ago. I did a sloppy job on this one &mdash; it&rsquo;s correct, but mostly straight-line &ldquo;C &ndash; style&rdquo; code. I&rsquo;ll come up with a better way to do this later, <em>promise</em>. Meanwhile, here&rsquo;s the code.</p>

<p>```go
package main</p>

<p>import &ldquo;bufio&rdquo;
import &ldquo;fmt&rdquo;
import &ldquo;os&rdquo;</p>

<p>type nodelabel uint8</p>

<p>type link struct {</p>

<pre><code>next      *node
available int
</code></pre>

<p>}</p>

<p>type node struct {</p>

<pre><code>label    nodelabel
links    []link
hops     int
capacity int
isFinal  bool
</code></pre>

<p>}</p>

<p>type nodeset map[nodelabel]*node</p>

<p>func main() {</p>

<pre><code>nodes := make(nodeset)
scanner := bufio.NewScanner(os.Stdin)
var numNodes int
for scanner.Scan() {
    line := scanner.Text()
    if line[0] == '#' {
        continue
    }
    if numNodes == 0 {
        fmt.Sscanln(line, &amp;numNodes)
    } else {
        var startNode, endNode nodelabel
        var capacity int
        fmt.Sscanf(line, "%c %c %d", &amp;startNode, &amp;endNode, &amp;capacity)
        n := nodes.getNode(startNode)
        next := nodes.getNode(endNode)
        l := link{next: next, available: capacity}
        n.links = append(n.links, l)
    }
}
finalNodeLabel := nodelabel('A') + nodelabel(numNodes-1)

startNode := nodes.getNode('A')
numLogs := 0
for {
    nodes.updateHopsAndCapacities(finalNodeLabel)

    if startNode.capacity == 0 {
        break
    }
    path := startNode.sendOneLog()
    numLogs++

    // Print out path (in reverse)
    fmt.Printf("Log #%d takes ", numLogs)
    for i := len(path) - 1; i &gt; 0; i-- {
        fmt.Printf("%c -&gt; ", path[i])
    }
    fmt.Printf("%c -- path of %d\n", path[0], len(path))
}
fmt.Printf("River is now full. We could send %d logs\n", numLogs)
</code></pre>

<p>}</p>

<p>func (nodes nodeset) updateHopsAndCapacities(finalNodeLabel nodelabel) {</p>

<pre><code>for _, n := range nodes {
    n.hops = -1
}
for _, n := range nodes {
    n.computeHops(finalNodeLabel)
    n.capacity = 0
    for _, l := range n.links {
        n.capacity += l.available
    }
}
</code></pre>

<p>}</p>

<p>func (n *node) sendOneLog() []nodelabel {</p>

<pre><code>if n.isFinal {
    singlePath := make([]nodelabel, 1)
    singlePath[0] = n.label
    return singlePath
}

// Pick shortest path
minHops := -1
var nextLink *link
for i := 0; i &lt; len(n.links); i++ {
    l := &amp;n.links[i]
    if !l.next.isFinal &amp;&amp; l.next.capacity == 0 {
        continue
    }
    if minHops &lt; 0 || (l.available &gt; 0 &amp;&amp; l.next.hops &lt; minHops) {
        minHops = l.next.hops
        nextLink = l
    }
}

path := nextLink.next.sendOneLog()

// Update current node and link
n.capacity--
nextLink.available--

// TODO: avoid making a copy here (!)
newPath := make([]nodelabel, len(path)+1)
copy(newPath, path)
newPath[len(path)] = n.label
return newPath
</code></pre>

<p>}</p>

<p>func (nodes nodeset) getNode(r nodelabel) *node {</p>

<pre><code>n, ok := nodes[r]
if !ok {
    n = &amp;node{label: r, isFinal: false}
    nodes[r] = n
}
return n
</code></pre>

<p>}</p>

<p>func (n *node) computeHops(finish nodelabel) {</p>

<pre><code>if n.hops &gt;= 0 {
    return
}
if n.label == finish {
    n.hops = 0
    n.isFinal = true
    return
}
minHops := -1
for _, l := range n.links {
    l.next.computeHops(finish)
    if l.available == 0 {
        continue
    }
    if minHops &lt; 0 ||
        l.next.hops &lt; minHops {
        minHops = l.next.hops
    }
}
n.hops = minHops + 1
</code></pre>

<p>}
```</p>

<p>It was easy to read in a formatted text file, so I did that instead of storing the specified routes and weights as a data literal. Here is the input:</p>

<p>```sh</p>

<h1>Format:</h1>

<h1>Number of nodes on the first line</h1>

<h1>Each subsequent line contains</h1>

<h1><start node> <end node> capacity</h1>

<h1>Nodes are labelled starting with &lsquo;A&rsquo;</h1>

<p>9
A B 6
A C 2
B E 3
B D 3
D C 2
D F 1
C G 5
E H 1
E I 2
F H 1
G H 2
G I 2
H I 4
```</p>

<p>And here is how the program runs:</p>

<p>```sh
$ cat /tmp/logroutes  | go run src/reddit-prog/log-routes.go</p>

<p>Log #1 takes A &ndash;> B &ndash;> E &ndash;> I &mdash; path of 4
Log #2 takes A &ndash;> B &ndash;> E &ndash;> I &mdash; path of 4
Log #3 takes A &ndash;> C &ndash;> G &ndash;> I &mdash; path of 4
Log #4 takes A &ndash;> C &ndash;> G &ndash;> I &mdash; path of 4
Log #5 takes A &ndash;> B &ndash;> E &ndash;> H &ndash;> I &mdash; path of 5
Log #6 takes A &ndash;> B &ndash;> D &ndash;> F &ndash;> H &ndash;> I &mdash; path of 6
Log #7 takes A &ndash;> B &ndash;> D &ndash;> C &ndash;> G &ndash;> H &ndash;> I &mdash; path of 7
Log #8 takes A &ndash;> B &ndash;> D &ndash;> C &ndash;> G &ndash;> H &ndash;> I &mdash; path of 7
River is now full. We could send 8 logs.
```</p>
]]></content>
  </entry>
  
</feed>
