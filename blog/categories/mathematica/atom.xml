<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mathematica, | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/mathematica/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2014-03-31T10:48:03-07:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How fast can you factor ?]]></title>
    <link href="http://agam.github.io/blog/2014/02/04/how-fast-can-you-factor/"/>
    <updated>2014-02-04T18:52:00-08:00</updated>
    <id>http://agam.github.io/blog/2014/02/04/how-fast-can-you-factor</id>
    <content type="html"><![CDATA[<p>For no other reason than <em>because it&rsquo;s there</em>, here is the result of asking Mathematica to factor <a href="http://en.wikipedia.org/wiki/RSA_numbers#RSA-100">RSA 100</a>.</p>

<p>In 1991,</p>

<blockquote><p>&hellip; the factorization took a few days using the multiple-polynomial quadratic sieve algorithm on a MasPar parallel computer.</p></blockquote>

<p>and now,</p>

<blockquote><p>It takes four hours to repeat this factorization using the program Msieve on a 2200 MHz Athlon 64 processor.</p></blockquote>

<p>In comparison, Mathematica took little more than an hour. Unfortunately, it was not able to parallelize it (for a <em>real</em> comparison, the <a href="http://sourceforge.net/projects/msieve/files/msieve/Msieve%20v1.51/">Msieve code</a> would have to be ported over).</p>

<p>{% img center <a href="http://farm6.staticflickr.com/5510/12309071334_575cda01f9_z_d.jpg">http://farm6.staticflickr.com/5510/12309071334_575cda01f9_z_d.jpg</a>  %}</p>

<p><strong>Update:</strong> This has been much better documented on <a href="http://mathematica.stackexchange.com/questions/14964/time-approximation-of-decrypting-rsa-algorithm">this StackExchange thread</a>, which also links to <a href="http://reference.wolfram.com/mathematica/tutorial/SomeNotesOnInternalImplementation.html#12915">notes on internal implementation</a>, in case you&rsquo;re interested:</p>

<blockquote><p>FactorInteger switches between trial division, Pollard , Pollard rho, elliptic curve, and quadratic sieve algorithms.</p></blockquote>

<p>Finally, more on RSA Numbers, as well as a Mathematica Notebook, <a href="http://mathworld.wolfram.com/RSANumber.html">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Playing with the exponential curve]]></title>
    <link href="http://agam.github.io/blog/2014/02/01/playing-with-the-exponential-curve/"/>
    <updated>2014-02-01T06:35:00-08:00</updated>
    <id>http://agam.github.io/blog/2014/02/01/playing-with-the-exponential-curve</id>
    <content type="html"><![CDATA[<p>I remember hearing about the <a href="http://britton.disted.camosun.bc.ca/jbchessgrain.htm">apocryphal story</a> about doubling grains of rice on a chessboard. I even tried writing powers of 2 (which at my age then just meant adding <code>2+2</code> then <code>4+4</code> etc).</p>

<p>{% img center <a href="http://britton.disted.camosun.bc.ca/firdau1.jpg">http://britton.disted.camosun.bc.ca/firdau1.jpg</a> %}</p>

<p>This is obviously the <a href="http://www.wolframalpha.com/input/?i=e+%5E+x"><code>e^x</code></a> curve, but when you normally see it drawn its self-similarity is not obvious. Mathematica&rsquo;s <code>Manipulate</code> function can help in this regard &hellip;</p>

<p><code>
Manipulate[ListPlot[Table[Power[2, i], {i, 1, n}]], {n, 1, 64}]
</code></p>

<p>{% img center <a href="http://farm3.staticflickr.com/2853/12244178256_251f9fcfae_d.jpg">http://farm3.staticflickr.com/2853/12244178256_251f9fcfae_d.jpg</a> %}
{% img center <a href="http://farm6.staticflickr.com/5496/12243600435_e6faac3bbb_d.jpg">http://farm6.staticflickr.com/5496/12243600435_e6faac3bbb_d.jpg</a> %}
{% img center <a href="http://farm6.staticflickr.com/5547/12244178226_2258c2c2ce_d.jpg">http://farm6.staticflickr.com/5547/12244178226_2258c2c2ce_d.jpg</a> %}
{% img center <a href="http://farm3.staticflickr.com/2882/12243785163_3822d7299b_d.jpg">http://farm3.staticflickr.com/2882/12243785163_3822d7299b_d.jpg</a> %}
{% img center <a href="http://farm8.staticflickr.com/7332/12243785183_6243378edf_d.jpg">http://farm8.staticflickr.com/7332/12243785183_6243378edf_d.jpg</a> %}</p>

<p>These are screenshots for increasing values of <code>n</code>: Note how they all look the same (except for the first one, where the curve is just starting out), over several orders of magnitude!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mathematica: A simple ant]]></title>
    <link href="http://agam.github.io/blog/2014/01/30/mathematica-a-simple-ant/"/>
    <updated>2014-01-30T18:16:00-08:00</updated>
    <id>http://agam.github.io/blog/2014/01/30/mathematica-a-simple-ant</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s a simple, exploratory sketch: Imagine an ant which can either move left or right, or stay in its place.</p>

<p>For simplicity, we&rsquo;ll imagine the ant starts at the center of a scale from <code>1</code> to <code>100</code>, and moves one unit at a time.</p>

<p>```
Ant[k<em>, u</em>] :=
 If[ u &lt; 1/3, Min[k + 1, 100], If[u > 2/3, Max[0, k &ndash; 1], k]]</p>

<p>RecAnt[k_] := Ant[k, RandomReal[]]
```</p>

<p> {% img center <a href="http://farm8.staticflickr.com/7351/12224251723_4d24311967_d.jpg">http://farm8.staticflickr.com/7351/12224251723_4d24311967_d.jpg</a> %}</p>

<p> <code>
 ListPlot[NestList[RecAnt, 50, 100000], ImageSize -&gt; Large, Background -&gt; LightGray]
</code></p>

<p> {% img center <a href="http://farm8.staticflickr.com/7418/12224482144_6ef516fd03_z_d.jpg">http://farm8.staticflickr.com/7418/12224482144_6ef516fd03_z_d.jpg</a> %}</p>
]]></content>
  </entry>
  
</feed>
