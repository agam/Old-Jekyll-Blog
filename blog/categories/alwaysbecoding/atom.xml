<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: alwaysbecoding, | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/alwaysbecoding/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2014-12-16T21:58:29-08:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DailyProgramming: Markov chain]]></title>
    <link href="http://agam.github.io/blog/2014/12/16/dailyprogramming-markov-chain/"/>
    <updated>2014-12-16T12:13:06-08:00</updated>
    <id>http://agam.github.io/blog/2014/12/16/dailyprogramming-markov-chain</id>
    <content type="html"><![CDATA[<p>Been a long, <em>long</em> time since I looked at <a href="http://www.reddit.com/r/dailyprogrammer/">r/dailyprogrammer</a>, so I picked <a href="http://www.reddit.com/r/dailyprogrammer/comments/2ovt2i/20141210_challenge_192_intermediate_markov_chain/">this <em>intermediate</em> problem</a> from 5 days ago. Basically, given a dictionary, judge the likelihood of a word being a &ldquo;real word&rdquo;.</p>

<p>Here&rsquo;s my solution:</p>

<p>```go
package main</p>

<p>import (</p>

<pre><code>"bufio"
"flag"
"fmt"
"log"
"math"
"os"
</code></pre>

<p>)</p>

<p>type wordmap map[uint8]map[uint8]int</p>

<p>func MakeWordMap(w string, wm wordmap) {</p>

<pre><code>for i := range w {
    if i == len(w)-1 {
        break
    }
    c := w[i]
    cnext := w[i+1]
    if _, ok := wm[c]; !ok {
        wm[c] = make(map[uint8]int)
    }
    wm[c][cnext] = wm[c][cnext] + 1
}
</code></pre>

<p>}</p>

<p>func ReadWords(dictfile string, wm wordmap) {</p>

<pre><code>file, err := os.Open(dictfile)
if err != nil {
    log.Fatal(err)
}
defer file.Close()

scanner := bufio.NewScanner(file)
for scanner.Scan() {
    MakeWordMap(scanner.Text(), wm)
}
</code></pre>

<p>}</p>

<p>func CheckValidity(w string, wm wordmap) float64 {</p>

<pre><code>var c, cprev uint8
var wordScore float64 = 1.0
for i := range w {
    if i == 0 {
        cprev = w[i]
        continue
    }
    c = w[i]
    pairScore := wm[cprev][c]
    rowTotal := 0
    for _, count := range wm[cprev] {
        rowTotal += count
    }
    wordScore = wordScore * float64(pairScore) / float64(rowTotal)
    cprev = c
}
return wordScore
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>// Takes a dictionary and a single word, and returns the
// probability of that word being "good"
wm := make(wordmap)
dictfile := flag.String("dictfile", "", "Path to word list")
checkword := flag.String("checkword", "", "Word to spell-check")
flag.Parse()
ReadWords(*dictfile, wm)
prob := CheckValidity(*checkword, wm)
fmt.Printf("%s has a score of %.20f\n", *checkword, prob)
if prob &lt; math.Pow10(-len(*checkword)) {
    fmt.Println("It is probably not a word!")
} else {
    fmt.Println("It looks like a real word!")
}
</code></pre>

<p>}
```</p>

<p>It runs as follows:</p>

<p><code>sh
$ go run markov.go -dictfile=/usr/share/dict/american-english  -checkword=go
go has a score of 0.06318184860451107887
It looks like a real word!
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Fun: Graph distances]]></title>
    <link href="http://agam.github.io/blog/2014/02/03/programming-fun-graph-distances/"/>
    <updated>2014-02-03T23:12:00-08:00</updated>
    <id>http://agam.github.io/blog/2014/02/03/programming-fun-graph-distances</id>
    <content type="html"><![CDATA[<p>Interesting <a href="http://www.reddit.com/r/dailyprogrammer/comments/1tiz4z/122313_challenge_140_intermediate_graph_radius/">problem</a>: given a graph, find out the <em>minimum distance between any two nodes</em>.</p>

<p>```</p>

<h2>Input Description</h2>

<p>On standard console input you will be given an integer N, followed by an
Adjacency matrix. The graph is not directed, so the matrix will always be
reflected about the main diagonal.</p>

<h2>Output Description</h2>

<p>Print the radius of the graph as an integer.
```</p>

<p>There are a few ways to do this &mdash; you can run <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&rsquo;s algorithm</a> or <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall algorithm</a> on the graph to find the path from each node to each other node. I sort of took a short cut &mdash; when the graph is represented as a matrix (as it is here), multiplying the matrix with itself (and adding the result to itself, so as not to lose the <em>0-step</em> info) can be used as a way of checking whether or not two nodes are connected.</p>

<p>Concretely, after <code>k</code> steps, if <code>Graph[i][j]</code> is <code>0</code> this means there is no path from <code>i</code> to <code>j</code> in <code>k</code> steps. So if you repeat this multiplication and stop when there are no zero elements, the number of multiplication steps is the minimum distance you need.</p>

<p><div><script src='https://gist.github.com/8794234.js'></script>
<noscript><pre><code>// Omitting headers

using namespace std;

void MatrixMultiply(
    const vector&lt;vector&lt;uint64_t&gt;&gt;&amp; source_mat1,
    const vector&lt;vector&lt;uint64_t&gt;&gt;&amp; source_mat2,
    int N,
    vector&lt;vector&lt;uint64_t&gt;&gt;* dest_mat) {
  for (int i = 0; i &lt; N; ++i) {
    vector&lt;uint64_t&gt; row;
    for (int j = 0; j &lt; N; ++j) {
      uint64_t sum = source_mat1[i][j];
      for (int k = 0; k &lt; N; ++k) {
        sum += (source_mat1[i][k] * source_mat2[k][j]);
      }
      row.push_back(sum);
    }
    dest_mat-&gt;push_back(row);
  }
}

bool AllVerticesReachable(const vector&lt;vector&lt;uint64_t&gt;&gt;&amp; mat, int N) {
  for (int i = 0; i &lt; N; ++i) {
    for (int j = 0; j &lt; N; ++j) {
      if (mat[i][j] == 0) {
        return false;
      }
    }
  }
  return true;
}

int main(int argc, char* argv[]) {
  int graph_size;
  cin &gt;&gt; graph_size;
  vector&lt;vector&lt;uint64_t&gt;&gt; graph;
  for (int i = 0; i &lt; graph_size; ++i) {
    int num;
    vector&lt;uint64_t&gt; row;
    for (int j = 0; j &lt; graph_size; ++j) {
      cin &gt;&gt; num;
      row.push_back(num);
    }
    graph.push_back(row);
  }

  // Multiply the matrix with itself
  int num_edges = 1;
  vector&lt;vector&lt;uint64_t&gt;&gt; multiplied_graph = graph;
  do {
    vector&lt;vector&lt;uint64_t&gt;&gt; temp_graph;
    MatrixMultiply(graph, multiplied_graph, graph_size, &amp;temp_graph);
    multiplied_graph = temp_graph;

    if (AllVerticesReachable(multiplied_graph, graph_size)) {
      break;
    }

    ++num_edges;
  } while (num_edges &lt; graph_size);
  cout &lt;&lt; &quot;Radius = &quot; &lt;&lt; num_edges + 1 &lt;&lt; endl;
}
</code></pre></noscript></div>
</p>

<p>[I&rsquo;m a little bored of these daily programmer questions now :( I&rsquo;ll do one more hard one and then find a new theme here.]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Fun: Ascii Tree]]></title>
    <link href="http://agam.github.io/blog/2014/01/29/programming-fun-ascii-tree/"/>
    <updated>2014-01-29T02:11:00-08:00</updated>
    <id>http://agam.github.io/blog/2014/01/29/programming-fun-ascii-tree</id>
    <content type="html"><![CDATA[<p>Another <a href="http://www.reddit.com/r/dailyprogrammer/comments/1t0r09/121613_challenge_145_easy_tree_generation/">easy problem</a> (I&rsquo;m not picking easy problems! I&rsquo;m just going in sequence!)</p>

<p>```</p>

<h2>Input Description</h2>

<p>You will be given one line of text on standard-console input: an integer and
two characters, all space-delimited. The integer, N, will range inclusively
from 3 to 21 and always be odd. The next character will be your trunk
character. The next character will be your leaves character. Draw the trunk and
leaves components with these characters, respectively.</p>

<h2>Output Description</h2>

<p>Given the three input arguments, draw a centered-tree. It should follow this
pattern: (this is the smallest tree possible, with a base of 3)
   *</p>

<hr />

<p>  ###
Here&rsquo;s a much larger tree, of base 7:
   *</p>

<hr />

<hr />

<hr />

<p>  ###
```</p>

<p>Is this really programming at all? More like basic <em>arithmetic</em>. Anyway &hellip;</p>

<p><div><script src='https://gist.github.com/8679031.js'></script>
<noscript><pre><code>// Skipped includes

using namespace std;

int main(int argc, char* argv[]) {
  int tree_width;
  char trunk_char, leaf_char;
  cin &gt;&gt; tree_width &gt;&gt; trunk_char &gt;&gt; leaf_char;

  // Since the top of the tree is triangular, if the height is N the base will
  // be 2 * N - 1.
  assert(tree_width % 2 == 1);
  assert(tree_width &gt; 0);
  int tree_height = (tree_width + 1) / 2;

  for (int i = 0; i &lt; tree_height; ++i) {
    // The i_th row will have 2 * i + 1 leaves, in the center
    for (int j = 0; j &lt; (tree_height - i); ++j) {
      cout &lt;&lt; &quot; &quot;;
    }
    for (int j = 0; j &lt; (2 * i + 1); ++j) {
      cout &lt;&lt; leaf_char;
    }
    cout &lt;&lt; endl;
  }
  // Trunk is always of width 3, in the center
  for (int j = 0; j &lt; (tree_height - 1); ++j) {
    cout &lt;&lt; &quot; &quot;;
  }
  for (int j = 0; j &lt; 3; ++j) {
    cout &lt;&lt; trunk_char;
  }
  cout &lt;&lt; endl;
}
</code></pre></noscript></div>
</p>

<p>[Also, I realized I&rsquo;m wasting everyone&rsquo;s time by having all those redundant <code>#include</code> lines, so I got rid of them here]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Fun: Adjacency Matrix]]></title>
    <link href="http://agam.github.io/blog/2014/01/27/programming-fun-adjacency-matrix/"/>
    <updated>2014-01-27T03:55:00-08:00</updated>
    <id>http://agam.github.io/blog/2014/01/27/programming-fun-adjacency-matrix</id>
    <content type="html"><![CDATA[<p>Another &ldquo;intermediate&rdquo; <a href="http://www.reddit.com/r/dailyprogrammer/comments/1t6dlf/121813_challenge_140_intermediate_adjacency_matrix/">problem</a> today.</p>

<p>```</p>

<h2>Input Description</h2>

<p>On standard console input, you will be first given a line with two space-delimited integers N and M. N is the number of nodes / vertices in the graph, while M is the number of following lines of edge-node data. A line of edge-node data is a space-delimited set of integers, with the special &ldquo;&ndash;>&rdquo; symbol indicating an edge. This symbol shows the edge-relationship between the set of left-sided integers and the right-sided integers. This symbol will only have one element to its left, or one element to its right. These lines of data will also never have duplicate information; you do not have to handle re-definitions of the same edges.</p>

<p>An example of data that maps the node 1 to the nodes 2 and 3 is as follows:
1 &ndash;> 2 3</p>

<p>Another example where multiple nodes points to the same node:
3 8 &ndash;> 2</p>

<p>You can expect input to sometimes create cycles and self-references in the graph. The following is valid:
2 &ndash;> 2 3
3 &ndash;> 2</p>

<p>Note that there is no order in the given integers; thus &ldquo;1 &ndash;> 2 3&rdquo; is the same as &ldquo;1 &ndash;> 3 2&rdquo;.</p>

<h2>Output Description</h2>

<p>Print the N x N adjacency matrix as a series of 0&rsquo;s (no-edge) and 1&rsquo;s (edge).
```</p>

<p>Since the C++ Standard Library doesn&rsquo;t have a built-in matrix library (or maybe it does and I&rsquo;m unaware of it), I just used a vector of size <code>M * N</code> to stand in for an <code>M * N</code> matrix.</p>

<p><div><script src='https://gist.github.com/8643006.js'></script>
<noscript><pre><code>#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;

using namespace std;

const static char* kRelationshipMarker = &quot;-&gt;&quot;;

int main(int argc, char* argv[]) {
  int number_nodes, number_relationships;
  string line;
  getline(cin, line);
  istringstream is(line);
  is &gt;&gt; number_nodes &gt;&gt; number_relationships;

  vector&lt;int&gt; connections;
  connections.assign(number_nodes * number_nodes, 0);

  for (int i = 0; i &lt; number_relationships; ++i) {
    getline(cin, line);
    int connectee;
    string marker;
    istringstream ris(line);
    ris &gt;&gt; connectee;
    ris &gt;&gt; marker;
    assert(marker == kRelationshipMarker);
    int connected_node;
    while (ris &gt;&gt; connected_node) {
      connections[connectee * number_nodes + connected_node] = 1;
    }
  }

  for (int i = 0; i &lt; number_nodes; ++i) {
    for (int j = 0; j &lt; number_nodes; ++j) {
      cout &lt;&lt; connections[i * number_nodes + j];
    }
    cout &lt;&lt; endl;
  }
}

</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Fun: Nuts and Bolts]]></title>
    <link href="http://agam.github.io/blog/2014/01/19/programming-fun-nuts-and-bolts/"/>
    <updated>2014-01-19T00:39:00-08:00</updated>
    <id>http://agam.github.io/blog/2014/01/19/programming-fun-nuts-and-bolts</id>
    <content type="html"><![CDATA[<p><a href="http://www.reddit.com/r/dailyprogrammer/comments/1sob1e/121113_challenge_144_easy_nuts_bolts/">This one</a> is <em>too easy</em> but included anyway for completeness (why not?)</p>

<p>```</p>

<h2>Input Description</h2>

<p>The first line of input will be an integer N, which is for the number of rows
in each list. Each list has N-lines of two space-delimited strings: the first
string will be the unique item name (without spaces), the second string will be
the price (in whole-integer cents). The second list, following the same format,
will have the same unique item-names, but with the correct price. Note that the
lists may not be in the same order!</p>

<h2>Output Description</h2>

<p>For each item that has had its price changed, print a row with the item name
and the price difference (in cents). Print the sign of the change (e.g. &lsquo;+&rsquo; for
a growth in price, or &lsquo;&ndash;&rsquo; for a loss in price). Order does not matter for
output.</p>

<p>```</p>

<p><div><script src='https://gist.github.com/8498879.js'></script>
<noscript><pre><code>#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;

using namespace std;

typedef unordered_map&lt;string, int&gt; Inventory;

void ReadInventory(int number_items, Inventory* inventory) {
  for (int i = 0; i &lt; number_items; ++i) {
    string item;
    int quantity;
    cin &gt;&gt; item &gt;&gt; quantity;
    inventory-&gt;insert(make_pair(item, quantity));
  }
}

int main(int argc, char* argv[]) {
  int number_items;
  cin &gt;&gt; number_items;

  Inventory before, after;
  ReadInventory(number_items, &amp;before);
  ReadInventory(number_items, &amp;after);

  for (const auto&amp; it : before) {
    assert(after.find(it.first) != after.end());
    int diff_quantity = after[it.first] - it.second;
    if (diff_quantity != 0) {
      cout &lt;&lt; it.first &lt;&lt; &quot; &quot; &lt;&lt; showpos &lt;&lt; diff_quantity &lt;&lt; endl;
    }
  }
}

</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
</feed>
