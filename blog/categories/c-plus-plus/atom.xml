<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2014-12-23T23:23:37+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Basic HTTP Client with Poco]]></title>
    <link href="http://agam.github.io/blog/2013/09/29/http-client-with-poco/"/>
    <updated>2013-09-29T00:00:00+00:00</updated>
    <id>http://agam.github.io/blog/2013/09/29/http-client-with-poco</id>
    <content type="html"><![CDATA[<p>After my previous terrible experience with <code>cpp-netlib</code>, I was very very pleasantly surprised by how well this went.</p>

<p>You can get the Poco C++ libraries <a href="http://pocoproject.org/">here</a></p>

<p>This is the short <code>wget</code> equivalent &hellip;</p>

<p>```c</p>

<h1>include <algorithm>  // for copy</h1>

<h1>include <iterator></h1>

<h1>include <string></h1>

<h1>include <iostream>   // for cout, istream</h1>

<h1>include &lt;Poco/Exception.h></h1>

<h1>include &lt;Poco/Net/HTTPClientSession.h></h1>

<h1>include &lt;Poco/Net/HTTPRequest.h></h1>

<h1>include &lt;Poco/Net/HTTPResponse.h></h1>

<h1>include &lt;Poco/Path.h></h1>

<h1>include &lt;Poco/URI.h></h1>

<p>using string = std::string;</p>

<p>int main(int argc, char*argv[]) {
  if (argc != 2) {</p>

<pre><code>std::cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " &lt;url&gt;" &lt;&lt; std::endl;
return 1;
</code></pre>

<p>  }</p>

<p>  try {</p>

<pre><code>// Initialize session
Poco::URI uri(argv[1]);
Poco::Net::HTTPClientSession client_session(uri.getHost(), uri.getPort());

// Prepare and send request
string path(uri.getPathAndQuery());
Poco::Net::HTTPRequest req(Poco::Net::HTTPRequest::HTTP_GET,
    path, Poco::Net::HTTPMessage::HTTP_1_1);
client_session.sendRequest(req);

// Get response
Poco::Net::HTTPResponse res;
std::istream&amp; is = client_session.receiveResponse(res);

// Print to standard output
std::copy(std::istream_iterator&lt;char&gt;(is),
    std::istream_iterator&lt;char&gt;(),
    std::ostream_iterator&lt;char&gt;(std::cout));
</code></pre>

<p>  } catch (Poco::Exception&amp; e) {</p>

<pre><code>std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
return 1;
</code></pre>

<p>  }</p>

<p>  std::cout &lt;&lt; &ldquo;Completed communication&rdquo;;
  return 0;
}
```</p>

<p>Thanks to my struggles getting the previous <code>cpp-netlib</code> example to build, I at least got very familiar with <code>cmake</code>. As a result, getting this example to build was a breeze:</p>

<p>```cmake
cmake_minimum_required(VERSION 2.8)
project(hello-world)</p>

<p>add_definitions(-std=c++11)</p>

<h1>Search paths</h1>

<p>include_directories(
  /opt/boost/boost_1_54_0
  /usr/local/include)
link_directories(
  /opt/boost/boost_1_54_0/stage/lib
  /usr/local/lib)</p>

<h1>Boost dependencies</h1>

<p>find_package(Boost 1.51 REQUIRED system regex)
set(BOOST_LIBS
  ${Boost_SYSTEM_LIBRARY}
  ${Boost_REGEX_LIBRARY}
  )</p>

<h1>Other external libraries</h1>

<p>find_package(OpenSSL)
find_library(LIBCRYPTO crypto)
find_library(POCO_FOUNDATION PocoFoundation)
find_library(POCO_NET PocoNet)
set(EXTERNAL_LIBS
  ${OPENSSL_LIBRARIES}
  ${LIBCRYPTO}
  ${POCO_FOUNDATION}
  ${POCO_NET}
  )</p>

<h1>Our final output</h1>

<p>add_executable(hello-world hello-world.cpp)
target_link_libraries(hello-world
  ${BOOST_LIBS}
  ${EXTERNAL_LIBS})
```</p>

<p>And it worked fine too:</p>

<p><code>sh
time ./hello-world http://www.google.com
&lt;html&gt;&lt;head&gt;&lt;metahttp-equiv="content-type"content="text/html;charset= ...(skipped rest)
real    0m0.424s
user    0m0.004s
sys     0m0.012s
</code></p>

<p>I&rsquo;m sure I&rsquo;ll be using more of POCO in the future!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[In which I recall how to build stuff]]></title>
    <link href="http://agam.github.io/blog/2013/08/26/building-boost-clang-gcc/"/>
    <updated>2013-08-26T00:00:00+00:00</updated>
    <id>http://agam.github.io/blog/2013/08/26/building-boost-clang-gcc</id>
    <content type="html"><![CDATA[<p>It all started when I wanted to &ldquo;relearn&rdquo; C++. I use it everyday, but it&rsquo;s been so long since I first came across it 15 years ago that I&rsquo;ve accumulated tons of bad habits and thought patterns etc, so I wanted to get a &ldquo;beginner&rsquo;s mind&rdquo; feel of it again.</p>

<h2>The initial detour</h2>

<p>Ok, I thought, let&rsquo;s read the <a href="http://www.amazon.com/The-Programming-Language-3rd-Edition/dp/0201889544">4th edition</a> of Bjarne&rsquo;s introduction to C++, and meanwhile also get to know <a href="http://www.boost.org/">Boost</a> with some familiarity.</p>

<p>So I downloaded the <a href="http://sourceforge.net/projects/boost/files/boost/1.54.0/boost_1_54_0.tar.bz2/download">Boost libraries</a> (which took a while), and then tried to build this basic example (from the Boost FAQ)</p>

<p>```c</p>

<h1>include <iostream></h1>

<h1>include <algorithm></h1>

<h1>include <iterator></h1>

<p>using boost::lambda::_1;</p>

<p>int main() {
  typedef std::istream_iterator<int> in;
  std::for_each(</p>

<pre><code>  in(std::cin), in(), std::cout &lt;&lt; (_1 * 3) &lt;&lt; " ");
</code></pre>

<p>}
```</p>

<p>using Clang</p>

<p><code>sh
clang -std=c++11 -stdlib=libc++ -I/opt/boost/boost_1_54_0 example.cc -o example
</code></p>

<h2>Fork in the road</h2>

<p>No luck</p>

<p><code>sh
/tmp/example-oWquCX.o: In function `__cxx_global_var_init3':
example.cc:(.text+0x71): undefined reference to `std::ios_base::Init::Init()'
example.cc:(.text+0x79): undefined reference to `std::ios_base::Init::~Init()'
/tmp/example-oWquCX.o: In function `main':
example.cc:(.text+0xb3): undefined reference to `std::cin'
example.cc:(.text+0xf0): undefined reference to `std::cout'
/tmp/example-oWquCX.o: In function `std::istream_iterator&lt;int, char, std::char_traits&lt;char&gt;, long&gt;::_M_read()':
</code></p>

<p>(and more that I&rsquo;ll skip over right now).</p>

<p>Later I realized that this was probably my fault in not linking it correctly, but I immediately, inexplicably, decided &ldquo;Aha! let&rsquo;s build clang from source!&rdquo;</p>

<p>This might also have been because I had gotten bored of <code>sudo apt-get install foo</code> and longed for the (decade ago) days of <code>emerge foo</code>.</p>

<h2>Deep in the woods</h2>

<p>Luckily, this turned out to be <a href="http://solarianprogrammer.com/2013/01/17/building-clang-libcpp-ubuntu-linux/">well-documented</a>, more or less.</p>

<p>So I got up to the point where I got and built <code>clang</code>:</p>

<p><code>sh
$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm
$ cd llvm/tools
$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
$ mkdir build &amp;&amp; cd build
$ ../llvm/configure --prefix=/usr/clang_3_3 \
  --enable-optimized --enable-targets=host
$ make -j 8
</code></p>

<p>And I procedded to then build <code>libcxx</code></p>

<p><code>sh
$ svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx
$ mkdir build_libcxx &amp;&amp; cd build_libcxx
$ CC=clang CXX=clang++ cmake -G "Unix Makefiles" \
  -DLIBCXX_CXX_ABI=libsupc++ \
  -DLIBCXX_LIBSUPCXX_INCLUDE_PATHS="/usr/include/c++/4.6/;\
  /usr/include/c++/4.6/x86_64-linux-gnu/" \
  -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr $HOME/Clang/libcxx
$ make
</code></p>

<h2>Mt. Doom</h2>

<p>At this point I got a compiler error. Very sad. Too bad, I thought, we need to go deeper. Time for building <code>gcc</code>/<code>g++</code> and a new version of the C++ standard library. My Ubuntu version only had <code>gcc</code> upto <code>4.6</code>, and I found <a href="http://lists.cs.uiuc.edu/pipermail/llvmbugs/2013-February/027116.html">a mailing list post</a> which suggested this might be fixed in <code>4.7</code>.</p>

<p>I could have at this point decided to add a PPA repository and got the new libraries and binaries that way, but luckily this was <a href="http://solarianprogrammer.com/2012/04/13/building-gcc-4-7-on-ubuntu-12-04/">also well-documented</a> (thank you, &ldquo;Solarian Programmer&rdquo;, whoever you are!).</p>

<p>So I went ahead and downloaded <a href="http://www.netgull.com/gcc/releases/gcc-4.7.3/gcc-4.7.3.tar.bz2"><code>gcc</code></a>, and what turned out to be its prerequisites, <a href="ftp://ftp.gmplib.org/pub/gmp-5.1.2/gmp-5.1.2.tar.lz"><code>gmp</code></a>, <a href="http://www.mpfr.org/mpfr-current/mpfr-3.1.2.tar.gz"><code>mpfr</code></a> and <a href="http://www.multiprecision.org/mpc/download/mpc-1.0.tar.gz"><code>mpc</code></a>.</p>

<p>These I built in the usual way (<code>configure</code>, <code>make</code>, <code>make install</code>), and then had to refer to them while setting up <code>gcc</code>:</p>

<p><code>sh
$ export LD_LIBRARY_PATH=/usr/gcc_4_7/lib:$LD_LIBRARY_PATH
$ export LIBRARY_PATH=/usr/lib/x86_64-linux-gnu/
$ export C_INCLUDE_PATH=/usr/include/x86_64-linux-gnu
$ export CPLUS_INCLUDE_PATH=/usr/include/x86_64-linux-gnu
$ ../gcc-4.7.2/configure --build=x86_64-linux-gnu --prefix=/usr/gcc_4_7 \
  --with-gmp=/usr/gcc_4_7 --with-mpfr=/usr/gcc_4_7 \
  --with-mpc=/usr/gcc_4_7 --enable-checking=release \
  --enable-languages=c,c++,fortran --disable-multilib \
  --program-suffix=-4.7
</code></p>

<p>Now I could proceed where I left off earlier, with the <code>libcxx</code> build, after setting a couple of path variables:</p>

<p><code>sh
$ export PATH=/usr/gcc_4_7/bin:$PATH
$ export LD_LIBRARY_PATH=/usr/gcc_4_7/lib:/usr/gcc_4_7/lib64:$LD_LIBRARY_PATH
</code></p>

<h2>A ray of hope</h2>

<p>But first, I wanted to see if the new <code>g++</code> could do what I had initially tried to do with <code>clang</code>:</p>

<p><code>sh
$ g++4.7 -std=c++11 -I/opt/boost/boost_1_54_0 example.cc -o example
$ echo 1 2 3 | ./example
3 6 9
</code></p>

<p>Whew, now I was getting somewhere.</p>

<p>I went back and re-ran <code>cmake</code>, and then <code>libcxx</code> built successfully.</p>

<p>And then of course, I retried my original example:</p>

<p><code>sh
$ /usr/clang_3_3/bin/clang++ -std=c++11 -I/opt/boost/boost_1_54_0 example.cc -o example
</code></p>

<p>and that worked too &hellip; Woohoo!!</p>

<p>Finally, since I always measure running time:</p>

<p>```sh
$ time /usr/clang_3_3/bin/clang++ -std=c++11 -I/opt/boost/boost_1_54_0 example.cc -o example</p>

<p>real    0m0.848s
user    0m0.780s
sys     0m0.056s</p>

<p>$ time g++4.7 -std=c++11 -I/opt/boost/boost_1_54_0 example.cc -o example</p>

<p>real    0m0.714s
user    0m0.648s
sys     0m0.044s
```</p>

<p>Now to do something more than this example program &hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comparison of data structures in C++ and Haskell]]></title>
    <link href="http://agam.github.io/blog/2013/06/26/data-structures-haskell-vs-cpp/"/>
    <updated>2013-06-26T00:00:00+00:00</updated>
    <id>http://agam.github.io/blog/2013/06/26/data-structures-haskell-vs-cpp</id>
    <content type="html"><![CDATA[<p>Once again, just to satisfy my curiosity, I want to do a tiny comparison of a basic feature in both languages, trying to see how data structures are implemented. Ok, I&rsquo;m fairly certain how it works for in C++, I&rsquo;m really just curious about Haskell.</p>

<h2>C++ version</h2>

<p>```c</p>

<h1>include <iostream></h1>

<h1>include <memory></h1>

<h1>include <vector></h1>

<p>struct BinaryNode {
  int val;
  BinaryNode <em>leftchild, </em>rightchild;
  BinaryNode(int v, BinaryNode<em> lc = nullptr, BinaryNode</em> rc = nullptr)</p>

<pre><code>: val(v), leftchild(lc), rightchild(rc) {}
</code></pre>

<p>};</p>

<p>struct NaryNode {
  int val;
  std::vector&lt;NaryNode<em>> children;
  NaryNode(int v, std::vector&lt;NaryNode</em>>&amp; c) : val(v), children&copy; {}
};</p>

<p>int binarySum(BinaryNode* node) {
  if (node == nullptr) {</p>

<pre><code>return 0;
</code></pre>

<p>  }
  return node->val + binarySum(node->leftchild) + binarySum(node->rightchild);
}</p>

<p>int narySum(NaryNode* node) {
  if (node == nullptr) {</p>

<pre><code>return 0;
</code></pre>

<p>  }
  int sum = node->val;
  for (const auto it : node->children) {</p>

<pre><code>sum += narySum(it);
</code></pre>

<p>  }
  return sum;
}</p>

<p>// Create dummy binary and n-ary trees and print out their sum
int main() {
  std::unique_ptr<BinaryNode> bnode1(new BinaryNode(4));
  std::unique_ptr<BinaryNode> bnode2(new BinaryNode(5));
  std::unique_ptr<BinaryNode> broot(new BinaryNode(0, bnode1.get(), bnode2.get()));
  std::cout &lt;&lt; &ldquo;BinarySum = &rdquo; &lt;&lt; binarySum(broot.get()) &lt;&lt; std::endl;</p>

<p>  std::vector&lt;NaryNode*> children;
  std::unique_ptr<NaryNode> nnode1(new NaryNode(4, children));
  std::unique_ptr<NaryNode> nnode2(new NaryNode(5, children));
  std::unique_ptr<NaryNode> nnode3(new NaryNode(6, children));
  children.push_back(nnode1.get());
  children.push_back(nnode2.get());
  children.push_back(nnode3.get());
  std::unique_ptr<NaryNode> nroot(new NaryNode(0, children));
  std::cout &lt;&lt; &ldquo;NarySum = &rdquo; &lt;&lt; narySum(nroot.get()) &lt;&lt; std::endl;
}
```</p>

<p>Assembly highlights:</p>

<p>Uploaded the full file as a <a href="https://gist.github.com/agam/5872178">Gist</a> (it&rsquo;s 6437 lines long, we aren&rsquo;t in <em>Hello World</em> territory any more; on the other hand, this program would have been much longer in C.</p>

<p>The function <code>_Z9binarySumP10BinaryNode</code> is defined near the top, and the function <code>_Z7narySumP8NaryNode</code> right under it.</p>

<p>The assembly code follows along almost exactly as the C++ code above (of course all the struct offsets are &ldquo;just added&rdquo; and you don&rsquo;t see the members being accessed directly).</p>

<p>The recursion is more obviously visible for the first function, where you see a pattern of &ldquo;call the function&rdquo;, &ldquo;call the function again&rdquo; and then add the node value to it. For the second function, you can see calls to <code>vector&lt;NaryNode&gt;::begin()</code> and <code>vector&lt;NaryNode&gt;::end()</code> at the beginning of the loop, and the test &lsquo;n&rsquo; jump and the recursive call in the middle of the body.</p>

<p>It is useful also to see how <code>main()</code> works here, you can see three calls to the <code>BinaryNode</code> constructor (<code>_ZN10BinaryNodeC1EiPS_S0_</code>), and then similar stuff for the <code>NaryNode</code> objects. At the end are multiple calls to the destructors (similar to <code>callq _ZNSt10unique_ptrI8NaryNodeSt14default_deleteIS0_EED1Ev</code>).</p>

<p>Most of the rest of the code is the definition of these functions (vector begin/end and unique_ptr delete etc.)</p>

<p>Note: I found a better way to show the assembly &lt;&ndash;> source correspondence, in an interactive way: <a href="http://gcc.godbolt.org/">GCC Explorer</a> and I&rsquo;ll use that next time, it&rsquo;s just way more convenient. Also, I&rsquo;ve been showing unoptimized assembly, which is <em>just noise</em>, will refer to <code>-O2</code> next time.</p>

<h2>Haskell version</h2>

<p>```haskell
data BinaryTree a = BinaryLeaf a | BinaryBranch (BinaryTree a) (BinaryTree a)
data NaryTree a = NaryLeaf a | NaryBranch [NaryTree a]</p>

<p>binarySum :: (Num a) => (BinaryTree a) &ndash;> a
binarySum (BinaryLeaf x) = x
binarySum (BinaryBranch a b) =  (binarySum a) + (binarySum b)</p>

<p>narySum :: (Num a) => NaryTree a &ndash;> a
narySum (NaryLeaf x) = x
narySum (NaryBranch b) = foldl (\acc x &ndash;> acc + (narySum x)) 0 b</p>

<p>&mdash;Create dummy binary and n-ary trees and print out their sum
main = let bt = BinaryBranch (BinaryLeaf 4) (BinaryLeaf 5)</p>

<pre><code>       nt = NaryBranch ((NaryLeaf 4) : (NaryLeaf 5) : (NaryLeaf 6) : [])
   in do
      putStrLn ("BinarySum = " ++ show(binarySum bt))
      putStrLn ("NarySum = " ++ show(narySum nt))
</code></pre>

<p>```</p>

<p>Assembly highlights:</p>

<p>Uploaded the <a href="https://gist.github.com/agam/5974455">full file (core) as a Gist</a></p>

<p><code>main</code> is present as <code>main1</code> near the bottom, which has two calls to <code>Handle.Text.hPutStr2</code></p>

<p>The binary sum is unpacked quite straightforwardly :&ndash;</p>

<p>```haskell
main_$sbinarySum =
  \ (ds_dBk :: BinaryTree Type.Integer) &ndash;></p>

<pre><code>case ds_dBk of _ {
  BinaryLeaf x_aaA -&gt; x_aaA;
  BinaryBranch a_aaB b_aaC -&gt;
    Type.plusInteger
      (main_$sbinarySum a_aaB) (main_$sbinarySum b_aaC)
}
</code></pre>

<p>```</p>

<p>whereas the nary sum is less so :&ndash;</p>

<p>```haskell
main_$snarySum =
  \ (ds_dtA :: NaryTree Type.Integer) &ndash;></p>

<pre><code>case ds_dtA of _ {
  NaryLeaf x_aad -&gt; x_aad;
  NaryBranch b_aae -&gt; lgo_r1MR lvl_r1MQ b_aae
}
</code></pre>

<p>lgo_r1MR =
  \ (z_atM :: Type.Integer)</p>

<pre><code>(ds_atN :: [NaryTree Type.Integer]) -&gt;
case ds_atN of _ {
  [] -&gt; z_atM;
  : x_atS xs_atT -&gt;
    lgo_r1MR
      (Type.plusInteger z_atM (main_$snarySum x_atS))
      xs_atT
}
</code></pre>

<p>```</p>

<p>with the second function being defined for iteration. I uploaded a gist with the <a href="https://gist.github.com/agam/5974501">assembly output</a>, which is of course tedious and quite spaghetti-like.</p>

<p>Here is an example of the nary leaf:</p>

<p>```nasm
.globl Main_NaryLeaf_closure
.type Main_NaryLeaf_closure, @object
Main_NaryLeaf_closure:</p>

<pre><code>.quad   Main_NaryLeaf_info
</code></pre>

<p>.text</p>

<pre><code>.align 8
.quad   4294967301
.quad   0
.quad   15
</code></pre>

<p>Main_NaryLeaf_info:
.LcBb:</p>

<pre><code>addq $16,%r12
cmpq 144(%r13),%r12
ja .LcBg
movq $Main_NaryLeaf_con_info,-8(%r12)
movq %r14,0(%r12)
leaq -7(%r12),%rbx
jmp *0(%rbp)
</code></pre>

<p>.LcBg:</p>

<pre><code>movq $16,192(%r13)
</code></pre>

<p>.LcBe:</p>

<pre><code>movl $Main_NaryLeaf_closure,%ebx
jmp *-8(%r13)
.size Main_NaryLeaf_info, .-Main_NaryLeaf_info
</code></pre>

<p>```</p>

<h2>Running time</h2>

<p>Pretty much on par here:</p>

<p>```sh
$ time ./cpptree
BinarySum = 9
NarySum = 15</p>

<p>real    0m0.005s
user    0m0.000s</p>

<p>$ time ./haskelltree
BinarySum = 9
NarySum = 15</p>

<p>real    0m0.004s
user    0m0.000s
sys 0m0.000s
```</p>

<p>Fast compilation, comparable run-time, shorter code &hellip; we&rsquo;re talking serious competition here :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comparing basic iteration in C++ and Haskell: Part 1]]></title>
    <link href="http://agam.github.io/blog/2013/03/13/basic-iteration-comparison/"/>
    <updated>2013-03-13T00:00:00+00:00</updated>
    <id>http://agam.github.io/blog/2013/03/13/basic-iteration-comparison</id>
    <content type="html"><![CDATA[<h2><code>For loop</code> iteration: C</h2>

<p>First, basic iteration over an array.</p>

<p>C++ Source :</p>

<p>```c</p>

<h1>include <iostream></h1>

<h1>include <vector></h1>

<p>int main(int argc, char**argv) {
  std::vector<int> v { 12, 23, 34 ,45 ,56 ,67 ,78, 89 };
  for (auto i : v) {</p>

<pre><code>std::cout &lt;&lt; i &lt;&lt; std::endl;
</code></pre>

<p>  }
}
```</p>

<p>Compile/Assemble:</p>

<p><code>sh
$ g++ -std=c++0x -S -o simpleloopcpp simpleloop.cpp
</code></p>

<p>I&rsquo;ve stored the result in <a href="https://gist.github.com/agam/5194257">this
gist</a>. As you can see, this is
<em>enormous</em> !! And all because we introduced <code>STL</code> into the picture !!!</p>

<p>So I obviously won&rsquo;t include all 1742 lines here, but let&rsquo;s see if we can
scan some high level features and go a bit deeper into the parts of the
code we&rsquo;ll compare with the haskell version of this.</p>

<p>(Skipping some boiler plate and the initializer list creater )</p>

<p>```nasm</p>

<pre><code>.text
.globl  main
.type   main, @function
</code></pre>

<p>main:
.LFB1490:</p>

<pre><code>.cfi_startproc
.cfi_personality 0x3,__gxx_personality_v0
.cfi_lsda 0x3,.LLSDA1490
pushq   %rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq    %rsp, %rbp
.cfi_def_cfa_register 6
pushq   %rbx
subq    $120, %rsp
movl    %edi, -116(%rbp)
movq    %rsi, -128(%rbp)
leaq    -17(%rbp), %rax
movq    %rax, %rdi
.cfi_offset 3, -24
</code></pre>

<p>```</p>

<p>Here is the
<a href="http://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a> being initialized</p>

<p>```nasm</p>

<pre><code>call    _ZNSaIiEC1Ev
leaq    -80(%rbp), %rax
movl    $8, %edx
movl    $._89, %esi
movq    %rax, %rdi
call    _ZNSt16initializer_listIiEC1EPKim
</code></pre>

<p>```</p>

<p>(It is declared elsewhere)</p>

<p>```nasm</p>

<pre><code>.size   ._89, 32
</code></pre>

<p>._89:</p>

<pre><code>.long   12
.long   23
.long   34
.long   45
.long   56
.long   67
.long   78
.long   89
</code></pre>

<p>```</p>

<p>&hellip; and then the <code>vector</code> initialized from it &hellip;`</p>

<p>```nasm</p>

<pre><code>leaq    -17(%rbp), %rcx
movq    -80(%rbp), %rsi
movq    -72(%rbp), %rdx
leaq    -112(%rbp), %rax
movq    %rax, %rdi
</code></pre>

<p>.LEHB0:</p>

<pre><code>call    _ZNSt6vectorIiSaIiEEC1ESt16initializer_listIiERKS0_
</code></pre>

<p>```</p>

<p>Ignore this, it&rsquo;s just freeing up the <code>std::allocator</code> object that is
passed to the vector (the actual function signature for the constructor is
<code>c std::vector(std::initializer_list, std::allocator const&amp;)</code>)</p>

<p>```nasm
.LEHE0:</p>

<pre><code>leaq    -17(%rbp), %rax
movq    %rax, %rdi
call    _ZNSaIiED1Ev
leaq    -112(%rbp), %rax
movq    %rax, -32(%rbp)
movq    -32(%rbp), %rax
movq    %rax, %rdi
</code></pre>

<p>```</p>

<p>Aha &hellip; finally, the iteration, from beginning</p>

<p>```nasm
.LEHB1:</p>

<pre><code>call    _ZSt5beginISt6vectorIiSaIiEEEDTcldtfp_5beginEERT_
movq    %rax, -64(%rbp)
movq    -32(%rbp), %rax
movq    %rax, %rdi
</code></pre>

<p>```</p>

<p>&hellip; to end</p>

<p>```nasm</p>

<pre><code>call    _ZSt3endISt6vectorIiSaIiEEEDTcldtfp_3endEERT_
movq    %rax, -48(%rbp)
jmp .L3
</code></pre>

<p>```</p>

<p>Beginning of the loop: we take the value of the iterator &hellip;</p>

<p>```nasm
.L4:</p>

<pre><code>leaq    -64(%rbp), %rax
movq    %rax, %rdi
call    _ZNK9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEdeEv
movl    (%rax), %eax
movl    %eax, -24(%rbp)
movl    -24(%rbp), %eax
movl    %eax, %esi
</code></pre>

<p>```</p>

<p>&hellip; and print it out.
(This is the <code>operator &lt;&lt;</code>, being called on the contents of <code>edi</code>,
which is <code>std::cout</code>)</p>

<p>```nasm</p>

<pre><code>movl    $_ZSt4cout, %edi
call    _ZNSolsEi
</code></pre>

<p>```</p>

<p>And this big mangled symbol is <code>std::endl</code>.</p>

<p>```nasm</p>

<pre><code>movl
</code></pre>

<p>$<em>ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6</em>, %esi</p>

<pre><code>movq    %rax, %rdi
call    _ZNSolsEPFRSoS_E
</code></pre>

<p>```</p>

<p>BTW a useful tool to find
unmangled symbols is <code>c++filt</code>, use it as</p>

<p>```sh
$ c++filt <em>ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6</em></p>

<p>std::basic_ostream&lt;char, std::char_traits<char> >&amp; std::endl&lt;char,
std::char_traits<char> >(std::basic_ostream&lt;char, std::char_traits<char></p>

<blockquote><p>&amp;)</p></blockquote>

<p>```</p>

<p>I googled and found an <a href="http://slush.warosu.org/c++filtjs/">online version of the
same</a> but it wasn&rsquo;t always accurate, so
YMMV.</p>

<p>Moving on &hellip; then the iterator advances along the vector &hellip;</p>

<p>```nasm</p>

<pre><code>leaq    -64(%rbp), %rax
movq    %rax, %rdi
call    _ZN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEppEv
</code></pre>

<p>.L3:</p>

<pre><code>leaq    -48(%rbp), %rdx
leaq    -64(%rbp), %rax
movq    %rdx, %rsi
movq    %rax, %rdi
</code></pre>

<p>```</p>

<p>&hellip; and if we haven&rsquo;t reached the end yet, jump back to the beginning of
the loop (the <code>.L4</code> label above)</p>

<p>```nasm</p>

<pre><code>call
</code></pre>

<p><em>ZN9<strong>gnu_cxxneIPiSt6vectorIiSaIiEEEEbRKNS_17</strong>normal_iteratorIT_T0_EESA</em>
.LEHE1:</p>

<pre><code>testb   %al, %al
jne .L4
leaq    -112(%rbp), %rax
movq    %rax, %rdi
</code></pre>

<p>```</p>

<p>When done, destroy the vector (with some error handling, so
<code>nasm _Unwind_Resume</code>)</p>

<p>```nasm
.LEHB2:</p>

<pre><code>call    _ZNSt6vectorIiSaIiEED1Ev
movl    $0, %eax
addq    $120, %rsp
popq    %rbx
popq    %rbp
.cfi_remember_state
.cfi_def_cfa 7, 8
ret
</code></pre>

<p>.L7:</p>

<pre><code>.cfi_restore_state
movq    %rax, %rbx
leaq    -17(%rbp), %rax
movq    %rax, %rdi
call    _ZNSaIiED1Ev
movq    %rbx, %rax
movq    %rax, %rdi
call    _Unwind_Resume
</code></pre>

<p>.LEHE2:
.L8:</p>

<pre><code>movq    %rax, %rbx
leaq    -112(%rbp), %rax
movq    %rax, %rdi
call    _ZNSt6vectorIiSaIiEED1Ev
movq    %rbx, %rax
movq    %rax, %rdi
</code></pre>

<p>.LEHB3:</p>

<pre><code>call    _Unwind_Resume
</code></pre>

<p>.LEHE3:</p>

<pre><code>.cfi_endproc
</code></pre>

<p>```</p>

<p>Now I&rsquo;ve skipped <em>quite</em> a lot of the generated assembly, and you should
look at the gist I mentioned above for the code for each of the function
calls mentioned above, e.g. the code for
the &lsquo;beginning&rsquo; of the iterator:</p>

<p>```nasm
<em>ZSt5beginISt6vectorIiSaIiEEEDTcldtfp_5beginEERT</em>:
.LFB1564:</p>

<pre><code>.cfi_startproc
pushq   %rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq    %rsp, %rbp
.cfi_def_cfa_register 6
subq    $16, %rsp
movq    %rdi, -8(%rbp)
movq    -8(%rbp), %rax
movq    %rax, %rdi
call    _ZNSt6vectorIiSaIiEE5beginEv
leave
.cfi_def_cfa 7, 8
ret
.cfi_endproc
</code></pre>

<p>```</p>

<p>(which wraps around a call to <code>std::vector::begin()</code>)</p>

<h2><code>For loop</code> iteration: Haskell (Basic lists)</h2>

<p>Here&rsquo;s a simple program that uses the standard <code>Prelude</code> list type.</p>

<p>```haskell
x = [ 12, 23, 34, 45, 56, 67, 78 ,89 ]</p>

<p>main = mapM_ print x
```</p>

<p>Full assembly is <a href="https://gist.github.com/agam/5194680">here</a> &hellip; and would
you believe it, it&rsquo;s one-fifth the size of the C++ assembly.</p>

<p>Based on our experience in the <a href="/posts/hello-world-comparison.html">Hello World
example</a>, the Haskell assembly won&rsquo;t
have a linear one-to-one mapping with the source, so let&rsquo;s start with the
<code>haskell main</code> function.</p>

<p>```nasm
.globl Main_main_info
.type Main_main_info, @object
Main_main_info:
.Lcuj:</p>

<pre><code>leaq -16(%rbp),%rax
cmpq %r15,%rax
jb .Lcul
addq $16,%r12
cmpq 144(%r13),%r12
ja .Lcun
movq $stg_CAF_BLACKHOLE_info,-8(%r12)
movq 160(%r13),%rax
movq %rax,0(%r12)
movq %r13,%rdi
movq %rbx,%rsi
leaq -8(%r12),%rdx
</code></pre>

<p>```</p>

<p>Once again, we see the <code>CAF</code> allocation</p>

<p>```nasm</p>

<pre><code>subq $8,%rsp
movl $0,%eax
call newCAF
addq $8,%rsp
testq %rax,%rax
je .Lcuo
</code></pre>

<p>.Lcup:</p>

<pre><code>movq $stg_bh_upd_frame_info,-16(%rbp)
leaq -8(%r12),%rax
movq %rax,-8(%rbp)
</code></pre>

<p>```</p>

<p>Somewhat boring &hellip; it uses <code>Control::MapM</code> and <code>
GHC::Base::IO</code></p>

<p>```nasm</p>

<pre><code>movl $base_ControlziMonad_mapMzu_closure,%ebx
movl $base_GHCziBase_zdfMonadIO_closure,%r14d
movl $stc_closure,%esi
movl $stb_closure+2,%edi
addq $-16,%rbp
jmp stg_ap_ppp_fast
</code></pre>

<p>.Lcun:</p>

<pre><code>movq $16,192(%r13)
</code></pre>

<p>.Lcul:</p>

<pre><code>jmp *-16(%r13)
</code></pre>

<p>.Lcuo:</p>

<pre><code>jmp *(%rbx)
</code></pre>

<p>```</p>

<p>&hellip; which in turn is defined as (skipping the usual paperwork of
<code>haskell newCAF</code> and <code>stg_CAF_BLACKHOLE_info</code>)</p>

<p>```nasm
.Lcu2:</p>

<pre><code>movq $stg_bh_upd_frame_info,-16(%rbp)
leaq -8(%r12),%rax
movq %rax,-8(%rbp)
movl $base_SystemziIO_print_closure,%ebx
movl $base_GHCziShow_zdfShowInteger_closure,%r14d
addq $-16,%rbp
jmp stg_ap_p_fast
</code></pre>

<p>.Lcu0:</p>

<pre><code>movq $16,192(%r13)
</code></pre>

<p>.LctY:</p>

<pre><code>jmp *-16(%r13)
</code></pre>

<p>.Lcu1:</p>

<pre><code>jmp *(%rbx)
</code></pre>

<p>```</p>

<p>(using <code>System::IO::print</code> and <code>GHC::Show::ShowInteger</code>)</p>

<p>So nothing much to directly glean here &mdash; iteration isn&rsquo;t anything special
in haskell, it&rsquo;s another function call.</p>

<p>The assembly for the data is incredibly verbose, on the lines of</p>

<p>```nasm
.data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
ssX_closure:</p>

<pre><code>.quad   integerzmgmp_GHCziIntegerziType_Szh_static_info
.quad   56
</code></pre>

<p>.data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
ssZ_closure:</p>

<pre><code>.quad   ghczmprim_GHCziTypes_ZC_static_info
.quad   ssX_closure+1
.quad   ssW_closure+2
.quad   0
</code></pre>

<p>&hellip;
&hellip;
&hellip;</p>

<p>.data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
st6_closure:</p>

<pre><code>.quad   integerzmgmp_GHCziIntegerziType_Szh_static_info
.quad   23
</code></pre>

<p>.data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
st8_closure:</p>

<pre><code>.quad   ghczmprim_GHCziTypes_ZC_static_info
.quad   st6_closure+1
.quad   st5_closure+2
.quad   0
</code></pre>

<p>```</p>

<h2><code>For loop</code> iteration: Haskell (Other list structures)</h2>

<p>Let&rsquo;s look at a different kind of list in haskell</p>

<p>```haskell
import Prelude hiding (mapM<em>);
import Data.Sequence;
import Data.Foldable (mapM</em>);</p>

<p>x = Data.Sequence.singleton 12 |> 23 |> 34 |> 45 |> 56 |> 67 |> 78  |> 89
main = mapM_  print  x
```</p>

<p>(Assembly <a href="https://gist.github.com/agam/5202781">here</a>)</p>

<p>The cells of this sequence are still constructed in what seems to me a bit
heavyweight manner:</p>

<p>```nasm
sEH_info:
.LcGi:</p>

<pre><code>leaq -16(%rbp),%rax
cmpq %r15,%rax
jb .LcGk
addq $32,%r12
cmpq 144(%r13),%r12
ja .LcGm
movq $stg_upd_frame_info,-16(%rbp)
movq %rbx,-8(%rbp)
movq $integerzmgmp_GHCziIntegerziType_Szh_con_info,-24(%r12)
movq $67,-16(%r12)
movq $sED_info,-8(%r12)
movl $containerszm0zi4zi2zi1_DataziSequence_zbzg_closure,%ebx
leaq -8(%r12),%r14
leaq -23(%r12),%rsi
addq $-16,%rbp
jmp stg_ap_pp_fast
</code></pre>

<p>.LcGm:</p>

<pre><code>movq $32,192(%r13)
</code></pre>

<p>```</p>

<p>(This extract shows the closure that adds <code>67</code> in the list)</p>

<p>It&rsquo;s possible to construct this directly from a finite list, and the same
can be done for the <code>Data.Vector</code> type too :</p>

<p>```haskell
import Prelude hiding (mapM_);
import Data.Vector;</p>

<p>x = Data.Vector.fromList [ 12, 23, 34, 45, 56, 67, 78, 89 ]
main = mapM_  print  x
```</p>

<p>(Assembly <a href="https://gist.github.com/agam/5202839">here</a>)</p>

<p>The vector is still constructed piece by piece though:</p>

<p>```nasm</p>

<pre><code>movq $23,-64(%r12)
movq $ghczmprim_GHCziTypes_ZC_con_info,-56(%r12)
leaq -71(%r12),%rax
movq %rax,-48(%r12)
leaq -94(%r12),%rax
movq %rax,-40(%r12)
movq $integerzmgmp_GHCziIntegerziType_Szh_con_info,-32(%r12)
movq $12,-24(%r12)
movq $ghczmprim_GHCziTypes_ZC_con_info,-16(%r12)
leaq -31(%r12),%rax
movq %rax,-8(%r12)
leaq -54(%r12),%rax
movq %rax,0(%r12)
movl $vectorzm0zi9zi1_DataziVector_fromList_closure,%ebx
leaq -14(%r12),%r14
addq $-16,%rbp
jmp stg_ap_p_fast
</code></pre>

<p>```</p>

<p>(This extract shows the steps for picking up 23 and 12 (skipping similar
steps for the other numbers)</p>

<p>I was curious if there was a way to avoid constructing the list</p>

<p>```haskell
import Data.Vector.Unboxed as U;</p>

<p>x :: U.Vector Double
x = U.fromList [ 12, 23, 34, 45, 56, 67, 78, 89 ]
main = U.foldr ((>>) . print) (return ())  x
```</p>

<p>(Assembly <a href="https://gist.github.com/agam/5203008">here</a>)</p>

<p>```nasm
&hellip;
&hellip; (skipping numbers after 23)
&hellip;</p>

<pre><code>movq $23,-48(%r12)
movq $ghczmprim_GHCziTypes_ZC_con_info,-40(%r12)
leaq -55(%r12),%rax
movq %rax,-32(%r12)
leaq -78(%r12),%rax
movq %rax,-24(%r12)
movq $ghczmprim_GHCziTypes_ZC_con_info,-16(%r12)
movq $stg_INTLIKE_closure+449,-8(%r12)
leaq -38(%r12),%rax
movq %rax,0(%r12)
movl $vectorzm0zi9zi1_DataziVectorziUnboxed_fromList_closure,%ebx
movl
</code></pre>

<p>$vectorzm0zi9zi1_DataziVectorziUnboxedziBase_zdfUnboxInt_closure,%r14d</p>

<pre><code>leaq -14(%r12),%rsi
addq $-16,%rbp
jmp stg_ap_pp_fast
</code></pre>

<p>```</p>

<p>In this case, looking at <code>Core</code> might help.</p>

<p>```haskell</p>

<p>Main.main :: GHC.Types.IO ()
[LclIdX]
Main.main =
  Data.Vector.Unboxed.foldr</p>

<pre><code>@ GHC.Types.Int
@ (GHC.Types.IO ())
Data.Vector.Unboxed.Base.$fUnboxInt
(GHC.Base..
   @ (GHC.Types.IO ())
   @ (GHC.Types.IO () -&gt; GHC.Types.IO ())
   @ GHC.Types.Int
   (GHC.Base.&gt;&gt; @ GHC.Types.IO GHC.Base.$fMonadIO @ () @ ())
   (System.IO.print @ GHC.Types.Int GHC.Show.$fShowInt))
(GHC.Base.return
   @ GHC.Types.IO GHC.Base.$fMonadIO @ () GHC.Tuple.())
(Data.Vector.Unboxed.fromList
   @ GHC.Types.Int
   Data.Vector.Unboxed.Base.$fUnboxInt
   (GHC.Types.:
      @ GHC.Types.Int
      (GHC.Types.I# 12)
      (GHC.Types.:
         @ GHC.Types.Int
         (GHC.Types.I# 23)
         (GHC.Types.:
            @ GHC.Types.Int
            (GHC.Types.I# 34)
            (GHC.Types.:
               @ GHC.Types.Int
               (GHC.Types.I# 45)
               (GHC.Types.:
                  @ GHC.Types.Int
                  (GHC.Types.I# 56)
                  (GHC.Types.:
                     @ GHC.Types.Int
                     (GHC.Types.I# 67)
                     (GHC.Types.:
                        @ GHC.Types.Int
                        (GHC.Types.I# 78)
                        (GHC.Types.:
                           @ GHC.Types.Int
                           (GHC.Types.I# 89)
                           (GHC.Types.[] @ GHC.Types.Int))))))))))
</code></pre>

<p>:Main.main :: GHC.Types.IO ()
[LclIdX]
:Main.main = GHC.TopHandler.runMainIO @ () Main.main
```</p>

<p>But no, even in the case of a <code>Data.Vector.Unboxed</code>, the representation
for the array data is never as compact as the C++ version.</p>

<p>In terms of running speed though (again, printing out tiny lists is a poor,
poor benchmark, but still) it seems close enough:</p>

<p>```sh
$ time (while ((n++ &lt; 100)); do ./simpleloopcpp; done)</p>

<p>real    0m0.312s
user    0m0.016s
sys 0m0.044s</p>

<p>$ time (while ((n++ &lt; 100)); do ./simpleloophaskell; done)</p>

<p>real    0m0.355s
user    0m0.024s
sys 0m0.060s
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comparing "Hello World" in C++ and Haskell]]></title>
    <link href="http://agam.github.io/blog/2013/03/10/hello-world-comparison/"/>
    <updated>2013-03-10T00:00:00+00:00</updated>
    <id>http://agam.github.io/blog/2013/03/10/hello-world-comparison</id>
    <content type="html"><![CDATA[<p>I feel I&rsquo;ve totally forgotten all about assembly, and I was curious anyway about how Haskell differed fundamentally in its basic code generation, so I decided to contrast a basic example against C++.</p>

<p>The choice of C++ here is arbitrary; it just happens to be something I&rsquo;ve used most often, and pretty much all the time for the last decade or so. If it ends up being interesting, I can add similar comparisons for other languages.</p>

<h2>Source Programs</h2>

<p>The C++ version:</p>

<p>```c</p>

<h1>include <iostream></h1>

<p>int main(int argc, char** argv) {
  std::cout &lt;&lt; &ldquo;Hello world\n\n&rdquo;;
}
```</p>

<p>The Haskell version:</p>

<p><code>haskell
main = putStrLn "Hello World"
</code></p>

<h2>Some high-level differences:</h2>

<p>Difference in size of generated binary:</p>

<p><code>sh
$ ls -l
-rwxr-x--- 1 agam eng 8.8K Dec 14 16:10 cpphelloworld
-rwxr-x--- 1 agam eng 1.1M Dec 14 16:16 haskellhelloworld
</code></p>

<p>Difference in number of symbols defined:</p>

<p><code>sh
$ nm cpphelloworld | wc -l
41
$ nm haskellhelloworld | wc -l
6578
</code></p>

<p>Differences in libraries linked in :&ndash;</p>

<p>```sh
$ ldd cpphelloworld</p>

<pre><code>linux-vdso.so.1 =&gt;  (0x00007fffcb5a7000)
libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007ffe35064000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffe34ca5000)
libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007ffe349a8000)
/lib64/ld-linux-x86-64.so.2 (0x00007ffe35381000)
libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007ffe34792000)
</code></pre>

<p>$ ldd haskellhelloworld</p>

<pre><code>linux-vdso.so.1 =&gt;  (0x00007fff681b9000)
libgmp.so.10 =&gt; /usr/lib/x86_64-linux-gnu/libgmp.so.10 (0x00007f427e124000)
libffi.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libffi.so.6 (0x00007f427df1c000)
libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f427dc1f000)
librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f427da17000)
libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f427d813000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f427d453000)
libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f427d236000)
/lib64/ld-linux-x86-64.so.2 (0x00007f427e3af000)
</code></pre>

<p>```</p>

<h2>C++ Object Code</h2>

<p>The C++ version:</p>

<p>Filename, and a static declaration of <code>c std::__ioinit</code> defined in <code>iostream</code>.</p>

<p>```nasm</p>

<pre><code>.file   "helloworld.cpp"
.local  _ZStL8__ioinit
.comm   _ZStL8__ioinit,1,1
</code></pre>

<p>```</p>

<p>Read-only data, containing the string used in our program.</p>

<p>```nasm</p>

<pre><code>.section    .rodata
</code></pre>

<p>.LC0:</p>

<pre><code>.string "Hello world\n\n"
</code></pre>

<p>```</p>

<p>Beginning of the &lsquo;<code>main</code>&rsquo; function, which is globally visible.</p>

<p>```nasm</p>

<pre><code>.text
.globl  main
.type   main, @function
</code></pre>

<p>```</p>

<p>The C++ code has a lot of these <code>cfi_</code> declarations, which is Call Frame Information for the <a href="http://www.logix.cz/michal/devel/gas-cfi/dwarf-2.0.0.pdf">DWARF debugging format</a></p>

<p>```nasm
main:
.LFB966:</p>

<pre><code>.cfi_startproc
</code></pre>

<p>```</p>

<p>Start new frame, Store old stack pointer.</p>

<p>```nasm</p>

<pre><code>pushq   %rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq    %rsp, %rbp
.cfi_def_cfa_register 6
</code></pre>

<p>```</p>

<p>Create space for local variables on the stack.
Copy the value of (empty) EDI and RSI onto this created space.
Copy the string declared above into ESI.
Store the address of the <code>std::cout</code> object into EDI.
Reset EAX to 0.
Call the std::basic_ostream&lt;std::char_traits> operator&lt;&lt;()</p>

<p>```nasm</p>

<pre><code>subq    $16, %rsp
movl    %edi, -4(%rbp)
movq    %rsi, -16(%rbp)
movl    $.LC0, %esi
movl    $_ZSt4cout, %edi
call    _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
movl    $0, %eax
leave
.cfi_def_cfa 7, 8
ret
.cfi_endproc
</code></pre>

<p>```</p>

<p>This part is not particular to the specific program here; gcc creates a <code>static_initialization_and_destruction</code> section for each translation unit that needs any static constructors to be called.</p>

<p>```nasm
.LFE966:</p>

<pre><code>.size   main, .-main
.type   _Z41__static_initialization_and_destruction_0ii, @function
</code></pre>

<p>_Z41__static_initialization_and_destruction_0ii:
.LFB970:</p>

<pre><code>.cfi_startproc
pushq   %rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq    %rsp, %rbp
.cfi_def_cfa_register 6
subq    $16, %rsp
movl    %edi, -4(%rbp)
movl    %esi, -8(%rbp)
cmpl    $1, -4(%rbp)
jne .L2
cmpl    $65535, -8(%rbp)
jne .L2
movl    $_ZStL8__ioinit, %edi
call    _ZNSt8ios_base4InitC1Ev
movl    $_ZNSt8ios_base4InitD1Ev, %eax
movl    $__dso_handle, %edx
movl    $_ZStL8__ioinit, %esi
movq    %rax, %rdi
call    __cxa_atexit
</code></pre>

<p>.L2:</p>

<pre><code>leave
.cfi_def_cfa 7, 8
ret
.cfi_endproc
</code></pre>

<p>```</p>

<p>I&rsquo;m not sure <em>wtf</em> is going on here. When it calls the static initialization function, 1 and 65535 are passed as arguments. Then within the function, it verifies that it did actually get these two arguments, and only if they were passed in, it calls the static constructor <code>ios_base::init</code></p>

<p>```nasm
.LFE970:</p>

<pre><code>.size   _Z41__static_initialization_and_destruction_0ii, .-_Z41__static_initialization_and_destruction_0ii
.type   _GLOBAL__sub_I_main, @function
</code></pre>

<p>_GLOBAL__sub_I_main:
.LFB971:</p>

<pre><code>.cfi_startproc
pushq   %rbp
.cfi_def_cfa_offset 16
.cfi_offset 6, -16
movq    %rsp, %rbp
.cfi_def_cfa_register 6
movl    $65535, %esi
movl    $1, %edi
call    _Z41__static_initialization_and_destruction_0ii
popq    %rbp
.cfi_def_cfa 7, 8
ret
.cfi_endproc
</code></pre>

<p>.LFE971:</p>

<pre><code>.size   _GLOBAL__sub_I_main, .-_GLOBAL__sub_I_main
.section    .ctors,"aw",@progbits
.align 8
.quad   _GLOBAL__sub_I_main
</code></pre>

<p>```</p>

<p>Omitted a bunch of library references that looked like</p>

<p>```nasm</p>

<pre><code>.weakref    _ZL22__gthrw_pthread_createPmPK14pthread_attr_tPFPvS3_ES3_,pthread_create
</code></pre>

<p>```</p>

<h2>Haskell core</h2>

<p>Haskell code generation is <strong>significantly</strong> different, so we&rsquo;ll look at generated <a href="http://www.haskell.org/haskellwiki/Performance/GHC#Looking_at_the_Core"><em>core</em></a> code first.</p>

<p>The best way for this is to use the <code>ghc-core</code> package.</p>

<p><code>sh
$ cabal install ghc-core
$ ~/.cabal/bin/ghc-core --no-cast --no-asm haskellhelloworld.hs
</code></p>

<p>I&rsquo;ve removed the <em>attributes</em> of functions, which look something like</p>

<p>```haskell
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,</p>

<pre><code>     ConLike=False, Cheap=False, Expandable=False,
     Guidance=IF_ARGS [] 60 0}]
</code></pre>

<p>```</p>

<p>The cleaned up core looks like this:</p>

<p><code>haskell
main2 :: [Char]
main2 = unpackCString# "Hello World"
</code></p>

<p>The code seemse full of a lot of <code>#</code>s, these are <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html">primitive types</a>. The &lsquo;raw&rsquo; string is made available as a different type to the program we wrote. Ghci is a good way to explore the type relationships here.</p>

<p>```haskell
Prelude> :t &ldquo;Hello world&rdquo;
&ldquo;Hello world&rdquo; :: [Char]
Prelude> :t putStrLn
putStrLn :: String &ndash;> IO ()</p>

<p>Prelude> :browse GHC.CString
&hellip;
&hellip; (other functions)
&hellip;
GHC.CString.unpackCString# :: GHC.Prim.Addr# &ndash;> [Char]
```</p>

<p>Continuing with our exploration of the core, <code>main1</code> is defined as a lambda function that effectively performs a<code>return</code> on the value returned by <code>Handle.Text.hPutStr2</code></p>

<p>```haskell
main1
  :: State# RealWorld</p>

<pre><code> -&gt; (# State# RealWorld, () #)
</code></pre>

<p>main1 =
  \ (eta_B1 :: State# RealWorld) &ndash;></p>

<pre><code>Handle.Text.hPutStr2
  Handle.FD.stdout main2 True eta_B1
</code></pre>

<p>```</p>

<p>Once again, ghci to the rescue:</p>

<p><code>haskell
Prelude&gt; :m GHC.IO.Handle.Text
Prelude GHC.IO.Handle.Text&gt; :t hPutStrLn
hPutStr :: GHC.IO.Handle.Types.Handle -&gt; String -&gt; IO ()
Prelude GHC.IO.Handle.Text&gt; :m GHC.IO.Handle.FD
Prelude GHC.IO.Handle.FD&gt; :t stdout
stdout :: GHC.IO.Handle.Types.Handle
</code></p>

<p>Also, internally in <a href="http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/src/GHC-IO-Handle-Text.html">the source for this module</a>, <code>hPutStrLn</code> is implemented in terms of <code>hPutStr'</code>, which has the type signature</p>

<p><code>haskell
hPutStr' :: Handle -&gt; String -&gt; Bool -&gt; IO ()
</code></p>

<p>Moving on, a <code>main</code> is defined but never used (perhaps just for correspondence with the user program?). Anywya, that is followed by a <code>main3</code> which actually runs the code.</p>

<p>```
main :: IO ()
main =
  main1</p>

<p>main3
  :: State# RealWorld</p>

<pre><code> -&gt; (# State# RealWorld, () #)
</code></pre>

<p>main3 =
  \ (eta_X9 :: State# RealWorld) &ndash;></p>

<pre><code>runMainIO1
  @ ()
  (main1
   )
  eta_X9
</code></pre>

<p>:main :: IO ()
:main =
  main3
```</p>

<p>Again, internally, the comments for <code>runMainIO</code> in the <a href="http://hackage.haskell.org/packages/archive/base/3.0.1.0/doc/html/src/GHC-TopHandler.html">corresponding source file</a> say:</p>

<p><code>haskell
-- | 'runMainIO' is wrapped around 'Main.main' (or whatever main is
-- called in the program).  It catches otherwise uncaught exceptions,
-- and also flushes stdout\/stderr before exiting.
runMainIO :: IO a -&gt; IO a
runMainIO main = (do a &lt;- main; cleanUp; return a) `catchException` topHandler
</code></p>

<p>Alright &hellip;. we&rsquo;re done with the core, and can look at the assembly, in full now.</p>

<h2>Haskell object code</h2>

<p>As mentioned earlier, the object code here hardly corresponds to our one-line program, but we can read it (sort of !) since we know the core. First off is a declaratoin for the &lsquo;real&rsquo; and &lsquo;dummy&rsquo; <code>main</code> methods.</p>

<p>```nasm
.data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
.globl <strong>stginit_Main
.type </strong>stginit_Main, @object
<strong>stginit_Main:
.globl </strong>stginit_ZCMain
.type <strong>stginit_ZCMain, @object
</strong>stginit_ZCMain:
.section .data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
```</p>

<p>It is common in generated assembly to see functions wrapped in closures. So there will typically be &lsquo;info&rsquo; for the function, a &lsquo;closure&rsquo; for it, and when needed to be called, a &lsquo;jump&rsquo; to it.</p>

<p>```nasm
sfB_srt:</p>

<pre><code>.quad   ghczmprim_GHCziCString_unpackCStringzh_closure
</code></pre>

<p>.data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
sfB_closure:</p>

<pre><code>.quad   sfB_info
.quad   0
.quad   0
.quad   0
</code></pre>

<p>```</p>

<p>BTW I wanted to get the &ldquo;official&rdquo; line on this, so I went to the <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode">haskell wiki</a> and found this:</p>

<p>```text
The goal of the STG machine is to reduce the current expression to a value.</p>

<p>When it has done so, it:</p>

<p>Stores a tagged pointer to evaluated closure in the STG register R1
Jumps to the entry code of the info table pointed to by the value at the top
of the STG stack
This may also be called the info table of the continuation of the expression
The continuation code is responsible for popping its info pointer (and stack-
allocated free variables, if any) from the stack before returning.</p>

<p>Arguments are passed on the stack, and are popped by the callee. Upon a
jump to the entry code for a function, there are always precisely as many
arguments on the stack as the (statically known) arity of that function,
and those arguments will be followed by the info pointer of a continuation.
```</p>

<p>Moving on, this (<code>cf0_str</code>) is our output string, declared byte-by-byte.</p>

<p>```nasm
.section .rodata</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
cfO_str:</p>

<pre><code>.byte   72
.byte   101
.byte   108
.byte   108
.byte   111
.byte   32
.byte   87
.byte   111
.byte   114
.byte   108
.byte   100
.byte   0
</code></pre>

<p>.text</p>

<pre><code>.align 8
.long   sfB_srt-(sfB_info)+0
.long   0
.quad   0
.quad   4294967318
</code></pre>

<p>```</p>

<p>I was totally stumped by <code>newCAF</code> and <code>CAF_BLACKHOLE_info</code> here, so I had to Google around to find <a href="http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html">some helpful info on it</a>.This in turn led me to the <a href="https://github.com/ghc/ghc/blob/master/rts/sm/Storage.c#L262">GHC runtime code</a> which says</p>

<p>```</p>

<p>   The entry code for every CAF does the following:</p>

<pre><code>  - builds a CAF_BLACKHOLE in the heap

  - calls newCaf, which atomically updates the CAF with
    IND_STATIC pointing to the CAF_BLACKHOLE

  - if newCaf returns zero, it re-enters the CAF (see Note [atomic
    CAF entry])

  - pushes an update frame pointing to the CAF_BLACKHOLE
</code></pre>

<p>   Why do we build an BLACKHOLE in the heap rather than just updating
   the thunk directly?  It&rsquo;s so that we only need one kind of update
   frame &ndash; otherwise we&rsquo;d need a static version of the update frame
   too, and various other parts of the RTS that deal with update
   frames would also need special cases for static update frames.</p>

<p>   newCaf() does the following:</p>

<pre><code>  - it updates the CAF with an IND_STATIC pointing to the
    CAF_BLACKHOLE, atomically.

  - it puts the CAF on the oldest generation's mutable list.
    This is so that we treat the CAF as a root when collecting
    younger generations.
</code></pre>

<p>```</p>

<p>If you want to know more about CAFs (Constant Applicative Forms), see <a href="http://www.haskell.org/haskellwiki/Constant_applicative_form">this wiki page</a></p>

<p>So, moving on, what follows is book-keeping (ok, I just really want to skip over these 20 lines)</p>

<p>```haskell
sfB_info:
.LcfS:</p>

<pre><code>leaq -16(%rbp),%rax
cmpq %r15,%rax
jb .LcfU
addq $16,%r12
cmpq 144(%r13),%r12
ja .LcfW
movq $stg_CAF_BLACKHOLE_info,-8(%r12)
movq 160(%r13),%rax
movq %rax,0(%r12)
movq %r13,%rdi
movq %rbx,%rsi
leaq -8(%r12),%rdx
subq $8,%rsp
movl $0,%eax
call newCAF
addq $8,%rsp
testq %rax,%rax
je .LcfX
</code></pre>

<p>```</p>

<p>Closures in action! Here we see the steps: Move the frame info into place, setup the function we want to call (here <code>GHC.String.unpackCString</code>) and its arguments (<code>cfo_str</code> from above) and then <code>jmp</code> to an evaluating function (here <code>stg_ap_n_fast</code>).</p>

<p>```haskell
.LcfY:</p>

<pre><code>movq $stg_bh_upd_frame_info,-16(%rbp)
leaq -8(%r12),%rax
movq %rax,-8(%rbp)
movl $ghczmprim_GHCziCString_unpackCStringzh_closure,%ebx
movl $cfO_str,%r14d
addq $-16,%rbp
jmp stg_ap_n_fast
</code></pre>

<p>.LcfW:</p>

<pre><code>movq $16,192(%r13)
</code></pre>

<p>.LcfU:</p>

<pre><code>jmp *-16(%r13)
</code></pre>

<p>.LcfX:</p>

<pre><code>jmp *(%rbx)
.size sfB_info, .-sfB_info
</code></pre>

<p>```</p>

<p>Setting up the <code>Main_main_closure</code>, which combines <code>base.SystemIO.putStrLn</code> and <code>sfB_closure</code>(above).</p>

<p>```haskell
.section .data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
Main_main_srt:</p>

<pre><code>.quad   base_SystemziIO_putStrLn_closure
.quad   sfB_closure
</code></pre>

<p>.data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
.globl Main_main_closure
.type Main_main_closure, @object
Main_main_closure:</p>

<pre><code>.quad   Main_main_info
.quad   0
.quad   0
.quad   0
</code></pre>

<p>.text</p>

<pre><code>.align 8
.long   Main_main_srt-(Main_main_info)+0
.long   0
.quad   0
.quad   12884901910
</code></pre>

<p>.globl Main_main_info
.type Main_main_info, @object
```</p>

<p>Moving on &hellip; bookkeeping for the main function similar for the functions above</p>

<p>```haskell
Main_main_info:
.Lcgf:</p>

<pre><code>leaq -16(%rbp),%rax
cmpq %r15,%rax
jb .Lcgh
addq $16,%r12
cmpq 144(%r13),%r12
ja .Lcgj
movq $stg_CAF_BLACKHOLE_info,-8(%r12)
movq 160(%r13),%rax
movq %rax,0(%r12)
movq %r13,%rdi
movq %rbx,%rsi
leaq -8(%r12),%rdx
subq $8,%rsp
movl $0,%eax
call newCAF
addq $8,%rsp
testq %rax,%rax
je .Lcgk
</code></pre>

<p>```</p>

<p>Running the <code>main</code> closure &hellip; this is also a demonstration of how functions are connected (one closure is an argument for the other closure)</p>

<p>```haskell
.Lcgl:</p>

<pre><code>movq $stg_bh_upd_frame_info,-16(%rbp)
leaq -8(%r12),%rax
movq %rax,-8(%rbp)
movl $base_SystemziIO_putStrLn_closure,%ebx
movl $sfB_closure,%r14d
addq $-16,%rbp
jmp stg_ap_p_fast
</code></pre>

<p>.Lcgj:</p>

<pre><code>movq $16,192(%r13)
</code></pre>

<p>.Lcgh:</p>

<pre><code>jmp *-16(%r13)
</code></pre>

<p>.Lcgk:</p>

<pre><code>jmp *(%rbx)
.size Main_main_info, .-Main_main_info
</code></pre>

<p>.section .data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
```</p>

<p>Ok, our last round of setting up the &lsquo;running main function&rsquo; and then its associated book-keeping</p>

<p>```haskell
ZCMain_main_srt:</p>

<pre><code>.quad   base_GHCziTopHandler_runMainIO_closure
.quad   Main_main_closure
</code></pre>

<p>.data</p>

<pre><code>.align 8
</code></pre>

<p>.align 1
.globl ZCMain_main_closure
.type ZCMain_main_closure, @object
ZCMain_main_closure:</p>

<pre><code>.quad   ZCMain_main_info
.quad   0
.quad   0
.quad   0
</code></pre>

<p>.text</p>

<pre><code>.align 8
.long   ZCMain_main_srt-(ZCMain_main_info)+0
.long   0
.quad   0
.quad   12884901910
</code></pre>

<p>.globl ZCMain_main_info
.type ZCMain_main_info, @object
ZCMain_main_info:
.LcgC:</p>

<pre><code>leaq -16(%rbp),%rax
cmpq %r15,%rax
jb .LcgE
addq $16,%r12
cmpq 144(%r13),%r12
ja .LcgG
movq $stg_CAF_BLACKHOLE_info,-8(%r12)
movq 160(%r13),%rax
movq %rax,0(%r12)
movq %r13,%rdi
movq %rbx,%rsi
leaq -8(%r12),%rdx
subq $8,%rsp
movl $0,%eax
call newCAF
addq $8,%rsp
testq %rax,%rax
je .LcgH
</code></pre>

<p>```</p>

<p>And finally, this is the <code>GHC.TopHandler.runMainIO</code> closure being called (if you haven&rsquo;t noticed yet, there are no <code>call</code>s in this code at all (except for <code>newCAF</code>), and everything is done by <code>jmp</code> instructions!)</p>

<p>The <code>Main_main_closure</code> above is an argument here to <code>runMainIO</code>.</p>

<p>```nasm
.LcgI:</p>

<pre><code>movq $stg_bh_upd_frame_info,-16(%rbp)
leaq -8(%r12),%rax
movq %rax,-8(%rbp)
movl $base_GHCziTopHandler_runMainIO_closure,%ebx
movl $Main_main_closure,%r14d
addq $-16,%rbp
jmp stg_ap_p_fast
</code></pre>

<p>.LcgG:</p>

<pre><code>movq $16,192(%r13)
</code></pre>

<p>.LcgE:</p>

<pre><code>jmp *-16(%r13)
</code></pre>

<p>.LcgH:</p>

<pre><code>jmp *(%rbx)
.size ZCMain_main_info, .-ZCMain_main_info
</code></pre>

<p>.section .note.GNU-stack,&ldquo;&rdquo;,@progbits
.ident &ldquo;GHC 7.4.1&rdquo;
```</p>

<p>And we&rsquo;re done!</p>

<h2>Running time comparison</h2>

<p>(only because I couldn&rsquo;t help myself, usual disclaimers about &lsquo;this-is-not-a-benchmark&rsquo; apply)</p>

<p>C++:</p>

<p><code>bash
time (while ((n++ &lt; 100)); do ./cpphelloworld; done)
real    0m0.250s
user    0m0.004s
sys 0m0.036s
</code></p>

<p>Haskell:</p>

<p><code>bash
time (while ((n++ &lt; 100)); do ./haskellhelloworld; done)
real    0m0.366s
user    0m0.004s
sys 0m0.048s
</code></p>

<h2>Gists</h2>

<p><em>Update</em>: I&rsquo;ve made the complete assembly version of both &lsquo;Hello World&rsquo; programs available as gists.
So you can look at <a href="https://gist.github.com/agam/5148416">The C++ version</a> or <a href="https://gist.github.com/agam/5148398">The Haskell version</a>.</p>
]]></content>
  </entry>
  
</feed>
