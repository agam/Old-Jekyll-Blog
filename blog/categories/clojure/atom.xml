<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2016-04-21T21:45:31-07:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Some badly written code]]></title>
    <link href="http://agam.github.io/blog/2016/03/11/some-badly-written-code/"/>
    <updated>2016-03-11T12:00:43-08:00</updated>
    <id>http://agam.github.io/blog/2016/03/11/some-badly-written-code</id>
    <content type="html"><![CDATA[<p>Heh, didn&rsquo;t know what else to title this sort of scrapbook/notebook entry. Basically I hadn’t looked at Codewars for a long time, so I went back and tried the next “Kata”.</p>

<p><em>Problem:</em> Given two integers m, n (1 &lt;= m &lt;= n) we want to find all integers between m and n whose sum of squared divisors is itself a square.</p>

<p>(E.g. 42 has divisors: 1,2,3,6,7,14,21,42, the squares of which are 1,4,9,3649,196,441,1764, and sum to 2500, which is a square)</p>

<p>I wrote my trivial solution, tried it and the submission failed because it timed out. So I hacked away, and uglified my solution, until it was using “memoized” divisors.</p>

<p>I ran it locally and it seemed faster, then I submitted it, and … it timed out again. I gave up, and moved on. I guess the lesson to be learnt is that it&rsquo;s always easy to code yourself into a corner?</p>

<p><em>Solution:</em></p>

<p>```haskell
module Codewars.G964.Sumdivsq where</p>

<p>import Data.List
import Data.Map as M</p>

<p>intSqrt :: Int &ndash;> Int
intSqrt = floor . sqrt . fromIntegral</p>

<p>isSquare :: Int &ndash;> Bool
isSquare x = x == (intSqrt x)<sup>2</sup></p>

<p>sumSq :: [Int] &ndash;> Int
sumSq list = sum [x<sup>2</sup> | x &lt;&ndash; list]</p>

<p>multiply :: Int &ndash;> [Int] &ndash;> [Int]
multiply factor oldDivlist = factor : oldDivlist ++ (Data.List.map (* factor) oldDivlist)</p>

<p>divisorHelper :: Int &ndash;> Int &ndash;> Int &ndash;> (Map Int [Int]) &ndash;> [Int] &ndash;> (Map Int [Int], [Int])
divisorHelper n lower upper knownDivs listDivs =
  if lower > upper
  then (M.insert n listDivs knownDivs, listDivs)
  else</p>

<pre><code>let otherDiv = n `div` lower
in
  if (n `rem` lower /= 0)
  then
    -- Keep going till we can divide
    divisorHelper n (lower+1) upper knownDivs listDivs
  else
    if otherDiv == lower
    then
      -- Special case: we reach a square divisor
      (M.insert n (lower : listDivs) knownDivs, lower : listDivs)
      -- Ok, we need to know if we've seen the bigger number before
    else case M.lookup otherDiv knownDivs of
      Just oldDivlist -&gt;
        -- We're done!
        let newDivlist = nub $ (lower : listDivs) ++ (multiply lower oldDivlist)
        in
          (M.insert n newDivlist knownDivs, newDivlist)
      Nothing -&gt; divisorHelper n (lower+1) (otherDiv-1) knownDivs (lower : otherDiv : listDivs)
</code></pre>

<p>divisors :: Int &ndash;> (Map Int [Int]) &ndash;> (Map Int [Int], [Int])
divisors n knownDivs = divisorHelper n 1 n knownDivs []</p>

<p>listSquaredHelper :: Int &ndash;> Int &ndash;> Map Int [Int] &ndash;> [(Int, Int)] &ndash;> [(Int, Int)]
listSquaredHelper lower upper knownDivs sqList =
  if lower > upper
  then</p>

<pre><code>sqList
</code></pre>

<p>  else</p>

<pre><code>let (newKnownDivs, divs) = divisors lower knownDivs
    s = sumSq divs
in
  if isSquare s
  then
    listSquaredHelper (lower+1) upper newKnownDivs  ((lower,s):sqList)
  else
    listSquaredHelper (lower+1) upper newKnownDivs sqList
</code></pre>

<p>listSquared :: Int &ndash;> Int &ndash;> [(Int, Int)]
listSquared m n = reverse $ listSquaredHelper m n M.empty []</p>

<p>```</p>

<p>I clearly have a long way to go in understanding the “why” of Haskell performance. My initial solution was much, uh &hellip; simpler. I didn&rsquo;t save it but I translated that into Clojure, which looks something like this:</p>

<p>```clojure
(ns sumdivsq.core)</p>

<p>(defn is-square
  [n]
  (== n (Math/pow (int (Math/sqrt n)) 2)))</p>

<p>(defn sum-sq
  [lst]
  (int (reduce + (map #(Math/pow % 2) lst))))</p>

<p>(defn divisors
  [n]
  (if (== n 1)</p>

<pre><code>[1]
(conj (filter #(== 0 (mod n %)) (range 1 (inc (/ n 2)))) n)))
</code></pre>

<p>(defn list-squared
  [m n]
  (letfn [(lfh [n]</p>

<pre><code>        (let [ssq (sum-sq (divisors n))]
          (when (is-square ssq)
            [n, ssq])))]
(keep #(lfh %) (range m n))))
</code></pre>

<p>```</p>

<p>Certainly <em>looks</em> very nice, and it passed all the tests, but I was too impatient to begin optimizing it, and left this one behind too &hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Daily programming: simple list stuff]]></title>
    <link href="http://agam.github.io/blog/2016/01/11/daily-programming-simple-list-stuff/"/>
    <updated>2016-01-11T22:36:12-08:00</updated>
    <id>http://agam.github.io/blog/2016/01/11/daily-programming-simple-list-stuff</id>
    <content type="html"><![CDATA[<p>Since I&rsquo;m warming up to Clojure this year, why not get started with the &ldquo;dailyprogrammer&rdquo; subreddit again?</p>

<p>So here&rsquo;s a (noobish) solution to <a href="https://www.reddit.com/r/dailyprogrammer/comments/40h9pd/20160111_challenge_249_easy_playing_the_stock/">this problem</a>:</p>

<p>```clojure
(ns dailyprog.core
  (:gen-class)
  (:require [clojure.string :as str]))</p>

<p>(defn input->float
  [input]
  (map #(Float/parseFloat %) (str/split input #&ldquo; &rdquo;)))</p>

<p>(defn difference
  &ldquo;Given a list of prices, a price in the list and its index, return the best price to sell it at&rdquo;
  [lst index buy-price]
  (let [max-sell-price (apply max (drop index lst))]</p>

<pre><code>{:buy-price buy-price
:sell-price max-sell-price
:difference (- max-sell-price buy-price)}))
</code></pre>

<p>(defn difference-vector
  [lst]
  (map-indexed (partial difference lst) lst))</p>

<p>(defn -main
  [&amp; args]
  (println(&ndash;>> (slurp (first args))</p>

<pre><code>            input-&gt;float
            difference-vector
            (apply max-key :difference))))
</code></pre>

<p>```</p>

<p>and it runs like this:</p>

<p>```sh</p>

<blockquote><p>lein run /tmp/challenge-input
{:buy-price 8.03, :sell-price 10.02, :difference 1.9900007247924805}
```</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure from the ground up]]></title>
    <link href="http://agam.github.io/blog/2016/01/06/clojure-from-the-ground-up/"/>
    <updated>2016-01-06T13:14:57-08:00</updated>
    <id>http://agam.github.io/blog/2016/01/06/clojure-from-the-ground-up</id>
    <content type="html"><![CDATA[<p>It&rsquo;s time for the same old new year resolution again: going to stop randomly skimming new languages and focus on something in depth.</p>

<p>This time, without loss of generality (hopefully!), I picked Clojure (<em>again ?</em>).</p>

<p>Found this nice series of posts called <a href="https://aphyr.com/posts/301-clojure-from-the-ground-up-welcome"><em>&ldquo;Clojure from the ground up&rdquo;</em></a>.</p>

<p>The best part is that unlike other random free tutorials online, this one has exercises.</p>

<p>For example, <a href="https://aphyr.com/posts/306-clojure-from-the-ground-up-state">the post that introduces concurrency primitives</a> asks us to write our own <code>future</code> macro.</p>

<p>I came up with this kludge:</p>

<p><code>``clojure
(defmacro my-future [&amp; body]
 </code>(let [p# (promise)]</p>

<pre><code>(.start (Thread.
  (fn [] (let [f# (fn [] ~@body)
               r# (f#)]
           (deliver p# r#)))))
           p#))
</code></pre>

<p>```</p>

<p>The expansion looks like this:</p>

<p>```clojure
clojure-noob.core> (pprint (macroexpand &lsquo;(my-future (Thread/sleep 5000) (prn &ldquo;Hey &hellip; &rdquo;))))
(let*
  [p<strong>9904</strong>auto__ (clojure.core/promise)]
  (.start</p>

<pre><code>(java.lang.Thread.
  (clojure.core/fn
   []
   (clojure.core/let
    [f__9905__auto__
      (clojure.core/fn [] (Thread/sleep 5000) (prn "Hey ... "))
      r__9906__auto__ (f__9905__auto__)]
    (clojure.core/deliver p__9904__auto__ r__9906__auto__)))))
    p__9904__auto__)
</code></pre>

<p>nil
```</p>

<p>And it seems to work:</p>

<p>```clojure
clojure-noob.core> (def x (my-future (Thread/sleep 5000) (prn &ldquo;Hey &hellip; &rdquo;)))</p>

<h1>&lsquo;clojure-noob.core/x</h1>

<p>clojure-noob.core> (pprint x)</p>

<h1>&lt;Promise@6a1dc62: :not-delivered></h1>

<p>nil
&ldquo;Hey &hellip; &rdquo;
clojure-noob.core>
clojure-noob.core> (pprint x)</p>

<h1>&lt;Promise@6a1dc62: nil></h1>

<p>nil
```</p>

<p>Here&rsquo;s hoping to fun times ahead (and a <em>happy new year</em> to you too!)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stuff I'd like to learn in 2015]]></title>
    <link href="http://agam.github.io/blog/2015/01/06/stuff-id-like-to-learn-in-2015/"/>
    <updated>2015-01-06T22:49:00-08:00</updated>
    <id>http://agam.github.io/blog/2015/01/06/stuff-id-like-to-learn-in-2015</id>
    <content type="html"><![CDATA[<p>Ah yes, the time of New Year&rsquo;s Resolutions. It never ends. Many weeks pass by in a haze of &ldquo;<em>shoulds</em>&rdquo;. So here&rsquo;s something more to add on.</p>

<ul>
<li><p>Keep playing with Go. It&rsquo;s a great, simple language. In particular, I want to try out a whole bunch of crazy experiments.</p></li>
<li><p>Think about the &ldquo;simple text games&rdquo; book. Or bury the idea as soon as possible.</p></li>
</ul>


<p><del>&ndash; Learn a bit more about the JVM (perhaps through Clojure?)</del></p>

<ul>
<li>Stem the atrophy in algorithmic skills</li>
</ul>


<p>&hellip; and there&rsquo;s more I can&rsquo;t remember right now. The first two seem self-evident, so a bit more about the third and fourth. I&rsquo;ve had a deep dislike for all things <em>Microsoft and Java</em> for over ten years now, and I think it&rsquo;s all mostly FUD.</p>

<p>In the case of Microsoft, it was because everything I tried to learn became deprecated as fast as I learnt it, and I quit in disgust (I&rsquo;m told I quit before giving the CLR and C# a fair chance). I was quite naive fifteen years ago and thought that <em>everything</em> that was current <em>then</em> was going to last forever. This extended to such stuff as Frontpage, DDE, COM, RDO &hellip; you get the idea.</p>

<p>For Java it&rsquo;s more vague. I think I never got the <em>hang</em> of it, and then I had a lot of &ldquo;<em>design pattern crap</em>&rdquo; thrown in my face, and my long-last impression was one of incredible, pointless verbosity. Last year though we had someone join our team who had done <em>RealWorkInJava &trade;</em>, and after talking to him it didn&rsquo;t seem all that bad. In particular, the JVM seemed like something worth knowing.</p>

<p>I have pretty much <em>zero</em> experience with hosted languages. One of the reasons for this might be that I always want to know what&rsquo;s &ldquo;really happening underneath&rdquo;, and am deeply suspicious of situations when I <em>cannot</em> know (this is also why I prefer Ocaml/F# over Haskell, but  that&rsquo;s a whole other blog post).</p>

<p><del>Add to this the fact that I&rsquo;ve always been curious about Clojure, to discover all its differences from Common Lisp on my own (there are several rants for and against it online, but there&rsquo;s only one way to find out for sure), and it&rsquo;s a natural outlet for exploration.</del></p>

<p>Which brings me to the fourth point &hellip; I feel I&rsquo;ve seriously forgotten <em>a lot</em> of theory, both in Math and CS, and it&rsquo;s <em>frightening</em>. So I&rsquo;m hoping to weave that (<em>somehow</em>) into my Clojure exploration and kill many birds with one stone.</p>

<p>So yeah, we&rsquo;ll find out how this all worked out, same time next year :)</p>

<p><strong>Update (1/13): This is a bunch of crap</strong> I just realized I wrote a <a href="http://agam.github.io/blog/2014/01/05/resolutions/">similar post</a> last year and did <em>nothing</em> about it (well, ok, I <em>did</em> do the <em>r/dailyprogrammer</em> stuff, more or less), so scratch all of the above. I&rsquo;ll leave it up to remind myself of how foolish this is. I&rsquo;m guessing this will reoccur the same time next year :P. Perhaps the best way out is to make <em>no resolutions</em>.</p>
]]></content>
  </entry>
  
</feed>
