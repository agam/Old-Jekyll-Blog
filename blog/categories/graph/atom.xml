<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: graph, | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/graph/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-01-03T00:51:13+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Ridiculous graph]]></title>
    <link href="http://agam.github.io/blog/2014/09/02/a-ridiculous-graph/"/>
    <updated>2014-09-02T23:44:27+00:00</updated>
    <id>http://agam.github.io/blog/2014/09/02/a-ridiculous-graph</id>
    <content type="html"><![CDATA[<p>Following in the theme of the previous post, <a href="https://gist.github.com/agam/fe8983acccd455fd9510">here (see linked Gist)</a> is a concurrent graph. Again, this is not an efficient way to do something like this, it&rsquo;s just a fun example of showing something that&rsquo;s easy in Go but probably harder or more verbose in other languages.</p>

<p>The basic idea here is that <em>every node is a goroutine</em>. So instead of using some structure like a matrix or an adjacency list to &ldquo;get a handle&rdquo; on all the nodes and their connections, you let the nodes take care of that themselves. Graph algorithms (trivial ones here are self-identification and depth calculation) are then constructed as interactions with the nodes, without an explicit traversal of vertices and edges.</p>

<p>```go
func node_agent(node *Node) {</p>

<pre><code>for {
    cmd := &lt;-node.comm
    switch cmd.cmdtype {
    case NameCmd:
        fmt.Println("I am ", node.name)
    case PingCmd:
        cmd.cmdchan &lt;- PingCmd
    case SetDepthCmd:
        // Ask all neighbors to modify depth, and pass
        // along the notification channel to them
        depth := cmd.cmdarg
        if node.state.depth &gt; 0 {
            break
        }
        node.state.depth = depth
        for _, ch := range node.neighbors {
            ch &lt;- Command{SetDepthCmd, cmd.cmdchan, depth + 1}
        }
        cmd.cmdchan &lt;- 1
    case GetDepthCmd:
        cmd.cmdchan &lt;- node.state.depth
    }
}
</code></pre>

<p>}
```</p>

<p>The &ldquo;Hello world&rdquo; in this scenario is just finding out which nodes exist, which is something as follows:</p>

<p>```go
func IsAlive(node *Node) bool {</p>

<pre><code>// Ping the node with a 10ms timeout
pingchan := make(chan int)
node.comm &lt;- Command{PingCmd, pingchan, 0}
select {
case &lt;-pingchan:
    return true
case &lt;-time.After(10 * time.Millisecond):
    return false
}
</code></pre>

<p>}</p>

<p>func printGraph(g *Graph) {</p>

<pre><code>fmt.Println("Graph :")

for _, node := range g.nodes {
    if IsAlive(node) {
        node.comm &lt;- Command{NameCmd, nil, 0}
    }
}
</code></pre>

<p>}
```</p>

<p>A slightly more complicated operation is finding the depth of all nodes relative to the root node:</p>

<p>```go</p>

<p>func calculateDepths(g *Graph) {</p>

<pre><code>// Recursively trigger computation from root node
notification := make(chan int)
g.nodes["root"].comm &lt;- Command{SetDepthCmd, notification, 1}

for i := 0; i &lt; len(g.nodes); i++ {
    // Wait for every node to receive this atleast once
    &lt;-notification
}

// Now check all the depths
depthchan := make(chan int)
for name, node := range g.nodes {
    node.comm &lt;- Command{GetDepthCmd, depthchan, 0}
    fmt.Println(name, " =&gt; ", &lt;-depthchan)
}
</code></pre>

<p>}
```</p>

<p>This being Go, you can play around with the implementation <a href="http://play.golang.org/p/SBoF_FnsMu">in the playground</a>!</p>
]]></content>
  </entry>
  
</feed>
