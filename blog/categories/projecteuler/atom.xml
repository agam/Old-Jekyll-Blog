<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projecteuler | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/projecteuler/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-03-22T04:39:14+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 41: Pandigital primes]]></title>
    <link href="http://agam.github.io/blog/2015/03/22/euler-41-pandigital-primes/"/>
    <updated>2015-03-22T04:35:08+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/22/euler-41-pandigital-primes</id>
    <content type="html"><![CDATA[<p>Yet another <em>brute-force</em> solution, pushing the line a bit at <em>1991 seconds</em>. But hey, it works, and was quick to write, so &hellip;</p>

<p>```lisp
(defparameter <em>max-num-limit</em> 1000000000)
(defparameter <em>all-numbers</em> (make-array (list <em>max-num-limit</em>) :element-type &lsquo;bit :initial-element 1))</p>

<p>(defun mark-primes (&amp;optional (n <em>max-num-limit</em>))
  ;; 0 and 1 are not prime
  (mark-not-prime 0)
  (mark-not-prime 1)
  ;; Mark 2 as prime, then do the following:
  ;; (1) Mark all multiples of the prime number,
  ;; (2) Find next available prime number, mark it as prime,
  ;; Repeat (1) until n
  (let ((prime 2))</p>

<pre><code>(loop while (&lt; prime n) do
     (mark-prime-multiples prime n)
     (setf prime (find-next-prime prime n)))))
</code></pre>

<p>(defun mark-not-prime (idx)
  (setf (bit <em>all-numbers</em> idx) 0))</p>

<p>(defun mark-prime-multiples (prime limit)
  (do ((i (* prime 2) (+ i prime)))</p>

<pre><code>  ((&gt;= i limit))
(mark-not-prime i)))
</code></pre>

<p>(defun find-next-prime (prev-prime limit)
  (do ((i (1+ prev-prime) (1+ i)))</p>

<pre><code>  ((or (= i limit) (= 1 (bit *all-numbers* i))) i)))
</code></pre>

<p>(defun is-prime (n)
  (= 1 (bit <em>all-numbers</em> n)))</p>

<p>(defun get-num-digits (n)
  (ceiling (log n 10)))</p>

<p>(defun is-pandigital (n)
  (let* ((num-digits (get-num-digits n))</p>

<pre><code>     (digits (make-array num-digits :element-type 'bit :initial-element 0)))
(loop while (and (&gt; n 0)
                 (&gt; (mod n 10) 0)
                 (&lt;= (mod n 10) num-digits)) do
     (setf (bit digits (1- (mod n 10))) 1)
     (setf n (floor (/ n 10))))
(= (length digits) (count 1 digits))))
</code></pre>

<p>(defun euler41 ()
  (mark-primes)
  (do ((n 987654321 (1- n)))</p>

<pre><code>  ((and (is-pandigital n) (is-prime n)) n)))
</code></pre>

<p>```</p>

<p>Everything is wrapped up in the call to <code>(euler41)</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 40: Champernowne's Constant]]></title>
    <link href="http://agam.github.io/blog/2015/03/21/euler-40-champernownes-constant/"/>
    <updated>2015-03-21T19:34:12+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/21/euler-40-champernownes-constant</id>
    <content type="html"><![CDATA[<p>I was too lazy to avoid the brute-force approach here, especially since it took less than a second to run. The following seems longer than it should be, partly because I left in some helper and debugging functions &hellip;</p>

<p><em>Edit</em>: There is obviously a very nice paper-and-pen solution to this &mdash; the 10th place is &lsquo;1&rsquo; (for 10), then the 100th place is &lsquo;5&rsquo; (for 55), and so on &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```lisp
(defparameter <em>max-digits</em> 2000000)</p>

<p>(defun digits (n)
  (declare (type fixnum n))
  (nreverse (loop</p>

<pre><code>           for tmp = n then (floor (/ tmp 10))
           until (= tmp 0)
           collect (mod tmp 10))))
</code></pre>

<p>(defun set-digits (d start all-digits)
  (loop</p>

<pre><code> for elem in d
 for idx = start then (1+ idx) do
   (setf (aref all-digits idx) elem)))
</code></pre>

<p>;; Fills out the array of digits and returns an accessor function
;; Note: the index increments by the length of the number of
;; digits of the <em>previous</em> number.
(let ((all-digits (make-array (list <em>max-digits</em>) :element-type &lsquo;(integer 0 9) :initial-element 0)))
  (defun populate-digits (n)</p>

<pre><code>(progn
  (loop
     for num = 1 then (1+ num)
     for d = (digits num)
     for i = 0 then (+ i (length (digits (1- num))))
     while (&lt; i n) do
       (set-digits d i all-digits))
(lambda (idx)
  (aref all-digits idx)))))
</code></pre>

<p>(defun power-list ()
  (let ((champer (populate-digits 1000000)))</p>

<pre><code>(loop for p from 0 to 6 collect
     (funcall champer (1- (expt 10 p))))))
</code></pre>

<p>(defun euler40 ()
  (apply &lsquo;* (power-list)))</p>

<p>;; Useful debugging tool
(defun scan-list (start end)
  (let ((champer (populate-digits)))</p>

<pre><code>(loop for i from start to end do
     (print (cons i (funcall champer i))))))
</code></pre>

<p>```</p>

<p>The &ldquo;final answer&rdquo; is given by <code>(euler40)</code>, and the intermediate digits themselves by <code>(power-list)</code>. I found <code>(scan-list)</code> useful to debug an embarassing off-by-one error in the loop.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 39: Integer Right Triangles]]></title>
    <link href="http://agam.github.io/blog/2015/03/20/euler-39-integer-right-triangles/"/>
    <updated>2015-03-20T23:09:44+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/20/euler-39-integer-right-triangles</id>
    <content type="html"><![CDATA[<p>Straightfoward, this. An interesting insight into speed difference between <code>SBCL</code> and <code>Clozure</code>: the former took <em>0.75 seconds</em> to run this, while the latter took about <em>4 seconds</em> (without the type annotations, <code>SBCL</code> takes <em>33 seconds</em>).</p>

<p>```lisp
(defun is-right-triangle (n1 n2 n3)
  (declare (type fixnum n1 n2 n3))
  (= (+ (expt n1 2) (expt n2 2)) (expt n3 2)))</p>

<p>(defun triangle-solutions (n)
  (declare (type fixnum n))
  ;; Largest side (hyp) can&rsquo;t be less than a third of the total
  (loop for hyp from (floor (/ n 3)) upto (&ndash; n 2)</p>

<pre><code> ;; Avoid repeating combinations, so WLOG let one side
 ;; be greater than the other
 for sides-sum = (- n hyp)
 when (loop for side1 from (ceiling (/ sides-sum 2)) to (1- sides-sum)
         for side2 = (- sides-sum side1) 
         when (is-right-triangle side1 side2 hyp)
         collect (list side1 side2 hyp))
 collect it))
</code></pre>

<p>(defun max-triangle-solutions (n)
  (declare (type fixnum n))
  ;; n cannot be less than 3
  (let* ((solutions (loop for i from 3 to n</p>

<pre><code>                   collect (length (triangle-solutions i))))
     (max-solution (loop for elem in solutions maximizing elem)))
(cons max-solution (+ 3 (position max-solution solutions)))))
</code></pre>

<p>```</p>

<p>The answer needed is given by <code>(max-triangle-solutions 1000)</code>, while any specific solution can be got by (e.g.) running <code>(triangle-solutions 120)</code> which yields <code>(((40 30 50)) ((45 24 51)) ((48 20 52)))</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 38: Pandigital multiples]]></title>
    <link href="http://agam.github.io/blog/2015/03/19/euler-38-pandigital-multiples/"/>
    <updated>2015-03-19T03:41:10+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/19/euler-38-pandigital-multiples</id>
    <content type="html"><![CDATA[<p>I&rsquo;m embarassed at how ridiculously naive my solution is. In hindsight, it&rsquo;s so <em>obvious</em> that the solution <em>has</em> to be a four-digit number and its double, and that the first digit is going to be a 9.</p>

<p>Still, C++ makes you lazy. This took <code>24 milliseconds</code>, and I didn&rsquo;t feel the need to speed it up :)</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
static const long kMaxNumbers = 10000;</p>

<p>int main() {
  long largestPanDigital = 0;
  for (long num = 2; num &lt; kMaxNumbers; ++num) {</p>

<pre><code>vector&lt;int&gt; pandigits;
int o = 1;
while (o &lt;= 20) {
  long product = num * o;
  vector&lt;int&gt; pd;
  while (product &gt; 0) {
    int d = product % 10;
    if (d == 0 ||
        (std::find(pandigits.begin(), pandigits.end(), d) != pandigits.end()) ||
        (std::find(pd.begin(), pd.end(), d) != pd.end())) {
      break;
    }
    pd.push_back(d);
    product /= 10;
  }
  if (product &gt; 0) {
    // Found an existing digit
    break;
  }
  // We formed a new product; keep going!
  for (auto it = pd.rbegin(); it != pd.rend(); ++it) {
    pandigits.push_back(*it);
  }
  ++o;
}
if (pandigits.size() == 9 &amp;&amp; o &gt; 1) {
  long panDigital = 0L;
  std::cout &lt;&lt; "Found: ";
  for (auto&amp; d : pandigits) {
    std::cout &lt;&lt; d;
    panDigital = panDigital * 10 + d;
  }
  std::cout &lt;&lt; " = " &lt;&lt; num &lt;&lt; " * " &lt;&lt; o-1 &lt;&lt; std::endl;
  if (panDigital &gt; largestPanDigital) {
    largestPanDigital = panDigital;
  }
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;The largest one is &rdquo; &lt;&lt; largestPanDigital &lt;&lt; std::endl;
}
```</p>

<p>It runs as follows:</p>

<p><code>sh
$ ~/cpp/Test
Found: 918273645 = 9 * 5
Found: 192384576 = 192 * 3
Found: 219438657 = 219 * 3
Found: 273546819 = 273 * 3
Found: 327654981 = 327 * 3
Found: 672913458 = 6729 * 2
Found: 679213584 = 6792 * 2
Found: 692713854 = 6927 * 2
Found: 726914538 = 7269 * 2
Found: 729314586 = 7293 * 2
Found: 732914658 = 7329 * 2
Found: 769215384 = 7692 * 2
Found: 792315846 = 7923 * 2
Found: 793215864 = 7932 * 2
Found: 926718534 = 9267 * 2
Found: 927318546 = 9273 * 2
Found: 932718654 = 9327 * 2
The largest one is &lt;redacted&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 37: Truncatable Primes]]></title>
    <link href="http://agam.github.io/blog/2015/03/13/euler-37-truncatable-primes/"/>
    <updated>2015-03-13T07:04:08+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/13/euler-37-truncatable-primes</id>
    <content type="html"><![CDATA[<p>I realize using <em>C++</em> is a bit like cheating since the initial motive of doing ProjectEuler was to explore a new <em>language</em>. But I reserve the right to &ldquo;revise&rdquo; that motive :P. Besides, I find it hard to overrule the part of myself that just wants to know the answer <em>now</em>, <em>quickly</em>.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
static const int kMaxNumbers = 1000000;</p>

<p>void filterPrimes(vector<bool>* numbers) {
  for (int candidate = 2; candidate &lt; kMaxNumbers; ) {</p>

<pre><code>int multiple = candidate * 2;
while (multiple &lt; kMaxNumbers) {
  numbers-&gt;at(multiple) = false;
  multiple += candidate;
}
++candidate;
while (candidate &lt; kMaxNumbers &amp;&amp; !numbers-&gt;at(candidate)) {
  ++candidate;
}
if (candidate == kMaxNumbers) {
  return;
}
</code></pre>

<p>  }
}</p>

<p>int getNumber(const vector<int>&amp; digits, int start, int end) {
  int num = 0;
  for (int i = end; i >= start; &mdash;i) {</p>

<pre><code>num = num * 10 + digits[i];
</code></pre>

<p>  }
  return num;
}</p>

<p>bool isTruncatablePrime(int num, const vector<bool>&amp; primes) {
  if (num == 2 || num == 3 || num == 5 || num == 7) {</p>

<pre><code>return false;
</code></pre>

<p>  }
  assert(primes.size() == kMaxNumbers);
  vector<int> digits;
  for (int t = num; t > 0; t /= 10) {</p>

<pre><code>digits.push_back(t % 10);
</code></pre>

<p>  }
  for (int i = 0; i &lt; digits.size(); ++i) {</p>

<pre><code>int n1 = getNumber(digits, 0, i);
int n2 = getNumber(digits, i, digits.size() - 1);
if (!primes[n1] || !primes[n2]) {
  return false;
}
</code></pre>

<p>  }
  return true;
}</p>

<p>int main() {
  vector<bool> prime_candidates(kMaxNumbers, true);
  prime_candidates[0] = false;
  prime_candidates[1] = false;
  filterPrimes(&amp;prime_candidates);
  int sum_truncatables = 0;
  for (int i = 13; i &lt; kMaxNumbers; ++i) {</p>

<pre><code>if (prime_candidates[i]) {
  if (isTruncatablePrime(i, prime_candidates)) {
    std::cout &lt;&lt; "Debug: found " &lt;&lt; i &lt;&lt; std::endl;
    sum_truncatables += i;
  }
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;The sum is: &rdquo; &lt;&lt; sum_truncatables &lt;&lt; std::endl;
}
```</p>

<p>which runs as</p>

<p><code>sh
Debug: found 23
Debug: found 37
Debug: found 53
Debug: found 73
Debug: found 313
Debug: found 317
Debug: found 373
Debug: found 797
Debug: found 3137
Debug: found 3797
Debug: found 739397
The sum is: &lt;redacted&gt;
</code></p>
]]></content>
  </entry>
  
</feed>
