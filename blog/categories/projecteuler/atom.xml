<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projecteuler | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/projecteuler/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-03-04T07:20:11+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 32: Sum of Pan-digital products]]></title>
    <link href="http://agam.github.io/blog/2015/03/04/euler-32-sum-of-pan-digital-products/"/>
    <updated>2015-03-04T07:10:28+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/04/euler-32-sum-of-pan-digital-products</id>
    <content type="html"><![CDATA[<p>Pretty dumb naive solution.</p>

<p>```c++
using std::vector;
static const int kNumDigits = 9;</p>

<p>int getNumber(const vector<int>&amp; vNum) {
  int result = 0;
  for (int i = 0; i &lt; vNum.size(); ++i) {</p>

<pre><code>result = result * 10 + vNum[i];
</code></pre>

<p>  }
  return result;
}</p>

<p>bool isProduct(const vector<int>&amp; vMultA,</p>

<pre><code>           const vector&lt;int&gt;&amp; vMultB,
           const vector&lt;int&gt;&amp; vProduct) {
</code></pre>

<p>  int multa = getNumber(vMultA);
  int multb = getNumber(vMultB);
  int product = getNumber(vProduct);
  bool result = (multa * multb == product);
  if (result) {</p>

<pre><code>std::cout &lt;&lt; "Debug: Testing " &lt;&lt; multa &lt;&lt; " * " &lt;&lt; multb &lt;&lt; " = " &lt;&lt; product
          &lt;&lt; "  --- MATCH!\n";
</code></pre>

<p>  }
  return result;
}</p>

<p>// Try all possible splits from this combination
void tryPermutation(const vector<int>&amp; p,</p>

<pre><code>                int* total_matches,
                std::unordered_set&lt;int&gt;* products) {
</code></pre>

<p>  assert(p.size() == kNumDigits);
  // There are nine digits, indexed from 0 to 8
  // First number spans 0 to i, the second i + 1 to j, third is from j + 1 to 8
  for (int i = 0; i &lt;= kNumDigits &ndash; 3; ++i) {</p>

<pre><code>for (int j = i+1; j &lt;= kNumDigits - 2; ++j) {
  vector&lt;int&gt; n1, n2, n3;
  for (int k = 0; k &lt;= i; ++k) {
    n1.push_back(p[k]);
  }
  for (int k = i+1; k &lt;= j; ++k) {
    n2.push_back(p[k]);
  }
  for (int k = j+1; k &lt;= kNumDigits-1; ++k) {
    n3.push_back(p[k]);
  }
  if (isProduct(n1,n2,n3)) {
    ++(*total_matches);
    products-&gt;insert(getNumber(n3));
  }
}
</code></pre>

<p>  }
}</p>

<p>int main() {
  vector<int> digits;
  for (int i = 1; i &lt;= kNumDigits; ++i) {</p>

<pre><code>digits.push_back(i);
</code></pre>

<p>  }
  int total_matches = 0;
  std::unordered_set<int> products;
  do {</p>

<pre><code>tryPermutation(digits, &amp;total_matches, &amp;products);
</code></pre>

<p>  } while (std::next_permutation(digits.begin(), digits.end()));
  int products_sum = 0;
  for (const auto&amp; p : products) {</p>

<pre><code>products_sum += p;
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;Number of matches = &rdquo; &lt;&lt; total_matches &lt;&lt; &ldquo;, &rdquo;</p>

<pre><code>        &lt;&lt; "Sum of products = " &lt;&lt; products_sum &lt;&lt; std::endl;
</code></pre>

<p>}</p>

<p>```</p>

<p>Runs as follows:</p>

<p><code>sh
~/cpp $ time ./Test
Debug: Testing 12 * 483 = 5796  --- MATCH!
Debug: Testing 138 * 42 = 5796  --- MATCH!
Debug: Testing 157 * 28 = 4396  --- MATCH!
Debug: Testing 159 * 48 = 7632  --- MATCH!
Debug: Testing 1738 * 4 = 6952  --- MATCH!
Debug: Testing 18 * 297 = 5346  --- MATCH!
Debug: Testing 186 * 39 = 7254  --- MATCH!
Debug: Testing 1963 * 4 = 7852  --- MATCH!
Debug: Testing 198 * 27 = 5346  --- MATCH!
Debug: Testing 27 * 198 = 5346  --- MATCH!
Debug: Testing 28 * 157 = 4396  --- MATCH!
Debug: Testing 297 * 18 = 5346  --- MATCH!
Debug: Testing 39 * 186 = 7254  --- MATCH!
Debug: Testing 4 * 1738 = 6952  --- MATCH!
Debug: Testing 4 * 1963 = 7852  --- MATCH!
Debug: Testing 42 * 138 = 5796  --- MATCH!
Debug: Testing 48 * 159 = 7632  --- MATCH!
Debug: Testing 483 * 12 = 5796  --- MATCH!
Number of matches = 18, Sum of products = 45228
15.517 secs
</code></p>

<p>(Wait, why C++ instead of &hellip; other recent languages? Couple of reasons: (1) I thought I&rsquo;d need to brute force this (though it eventually turned out to take much less time than I anticipated), and (2) I&rsquo;m sort of <em>over</em> the <em>over-experimentation</em> with languages that I&rsquo;m not <em>really</em> going to use, and I&rsquo;m not going to get much out of anyway. Yes, tough. Deal with it)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 31: Coin combinations (and over-engineering)]]></title>
    <link href="http://agam.github.io/blog/2015/02/22/euler-31-coin-combinations-and-over-engineering/"/>
    <updated>2015-02-22T04:44:55+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/22/euler-31-coin-combinations-and-over-engineering</id>
    <content type="html"><![CDATA[<p>I had this one all wrong, and made it way more complex than it really was. I&rsquo;m embarassed to post the final code &hellip; but it is what it is.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```haskell
import Data.Maybe</p>

<p>&mdash; Basic idea is something like this:
&mdash; [<em>] given amount and some coins, pick the largest coin
&mdash; [</em>] there are (floor (total/coin)) ways of using this coin value
&mdash; [*] but &hellip; NOT ALL of these count! Only the ones that leave a total that can be used with the remaining coins!</p>

<p>coins = [1, 2, 5, 10, 20, 50, 100, 200]</p>

<p>sortedCoins :: [Int]
sortedCoins = L.reverse $ L.sort $ coins</p>

<p>combinations :: Int &ndash;> [Int] &ndash;> Maybe Int
combinations total coins =
&mdash;  T.trace (&ldquo;total = &rdquo; ++ show total ++ &ldquo;, coins = &rdquo; ++ show coins) $
  if total == 0
  then Just 1
  else case coins of</p>

<pre><code>    [] -&gt; Nothing
    [c] -&gt; if mod total c == 0 then Just 1 else Nothing
    c:cs -&gt; if total == 0
            then Just 1
            else let newTotal total coin num = total - (coin * num)
                     combs = [combinations (newTotal total c num) cs | num &lt;- [0 .. div total c]]
                     counts = sum $ catMaybes combs
                 in
                  if counts == 0 then Nothing else Just counts
</code></pre>

<p>euler31 :: Int
euler31 = fromJust $ combinations 200 sortedCoins
```</p>

<p>It turns out, I was being overly cautious and could have just used lists in a different way (left in a commented out debug line to show that I needed it).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 30: sums of powers of digits]]></title>
    <link href="http://agam.github.io/blog/2015/02/18/euler-30-sums-of-powers-of-digits/"/>
    <updated>2015-02-18T21:41:02+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/18/euler-30-sums-of-powers-of-digits</id>
    <content type="html"><![CDATA[<p>Another quick and easy solution. This doesn&rsquo;t mean it&rsquo;s an <em>easy problem!</em>; no, it&rsquo;s more like playing a level at the <em>rookie level</em>. The hard and &ldquo;correct&rdquo; solution would be to work it out on pen-and-paper using Number Theory.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```haskell
digits :: Int &ndash;> [Int]
digits n = digitsHelper n []
  where</p>

<pre><code>digitsHelper num dList =
  if num &gt; 0
  then digitsHelper (div num 10) $ (mod num 10) : dList
  else dList
</code></pre>

<p>sumFifthPow :: Int &ndash;> Int
sumFifthPow n = sum $ map (^ 5) $ digits n</p>

<p>euler30 :: Int &ndash;> Int
euler30 limit = sum $ [x | x &lt;&ndash; [2 .. limit], x == sumFifthPow x]
```</p>

<p>Again, this version needs &ldquo;manual intervention&rdquo;, since I used the rough approximation that if <code>euler30 1000000</code> and <code>euler30 10000000</code> gave the same result, this was probably the right answer. It was.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 29: Distinct Powers]]></title>
    <link href="http://agam.github.io/blog/2015/02/18/euler-29-distinct-powers/"/>
    <updated>2015-02-18T00:56:01+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/18/euler-29-distinct-powers</id>
    <content type="html"><![CDATA[<p><strong>Statutory Warning</strong>: <em>Spoilers ahead!</em></p>

<p>Finally, we have a one-liner:</p>

<p><code>haskell
euler29 = length $ L.nub $ [a ^ b | a &lt;- [2 .. 100], b &lt;- [2 .. 100]]
</code></p>

<p>(where <code>L</code> is <code>Data.List</code>)</p>

<p><em>P.S.</em> I did make a dumb error by initiall writing this as two functions, with the second one taking <code>Int</code> instead of <code>Integer</code>, which (I&rsquo;m disappointed to say) resulted in everything silently overflowing to negative numbers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 28: Spiral diagonals]]></title>
    <link href="http://agam.github.io/blog/2015/02/17/euler-28-spiral-diagonals/"/>
    <updated>2015-02-17T19:33:10+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/17/euler-28-spiral-diagonals</id>
    <content type="html"><![CDATA[<p>This problem afforded a chance to be lazy and have fun.</p>

<p>There definitely is a pattern in the diagonals here: for a <code>3 x 3</code> matrix, the elements are 3, 5, 7, 9. For a <code>5 x 5</code> matrix, the additional elements are 13, 17, 21, 25.</p>

<p>You can see these as being (1 + 2), (1 + 4), (1 + 6), (1 + 8), and then (1 + 2 + 2 + 8), (1 + 4 + 4 + 8), (1 + 6 + 6 + 8), (1 + 8 + 8 + 8).</p>

<p>Similarly, for a <code>7 x 7</code> matrix, the numbers are 31, 37, 43, 49, which are (1 + 2 + 2 + 2 + 8 + 8 + 8), (1 + 4 + 4 + 4 + 8 + 8 + 8), (1 + 6 + 6 + 6 + 8 + 8 + 8), (1 + 8 + 8 + 8 + 8 + 8 + 8)</p>

<p>On the other hand, the problem mentions a <code>1001 x 1001</code> matrix, which is <em>tiny</em>, so why bother with these patterns? Just create the matrix and sum up the diagonals directly! (It&rsquo;s <em>just</em> a million elements &hellip; now if it was a few orders of magnitude higher, it would be a different story)</p>

<p><strong>Statutory Warning</strong>: Spoilers ahead!</p>

<p>```haskell
import qualified Data.List as L
import qualified Data.Vector as V
import qualified Data.Matrix as M
import qualified Data.HashMap.Strict as H
import Prelude hiding (Left,Right)</p>

<p>&mdash; Euler 28: spiral int matrix</p>

<p>data Direction = Down | Left | Right | Up deriving Show</p>

<p>move :: (Int,Int) &ndash;> Direction &ndash;> (Int,Int)
move oldPoint@(y,x) dir =
  case dir of Down &ndash;> (y+1,x)</p>

<pre><code>          Left -&gt; (y,x-1)
          Right -&gt; (y,x+1)
          Up -&gt; (y-1,x)
</code></pre>

<p>getSpiralMoves :: Int &ndash;> [Direction]
getSpiralMoves n =
  if n == 3
  then [Down, Right, Up, Up, Left, Left, Down, Down]
  else let prevMoves = getSpiralMoves (n-2)</p>

<pre><code>       firstMove = [Down]
       secondMove = take (n-2) $ repeat Right
       thirdMove = take (n-1) $ repeat Up
       fourthMove = take (n-1) $ repeat Left
       fifthMove = take (n-1) $ repeat Down
   in
    prevMoves ++ firstMove ++ secondMove ++ thirdMove ++ fourthMove ++ fifthMove
</code></pre>

<p>getSpiralCoords :: Int &ndash;> [(Int,Int)]
getSpiralCoords n =
  let mid = div (n+1) 2</p>

<pre><code>  start = (mid,mid)
</code></pre>

<p>  in
   L.scanl move start $ getSpiralMoves n</p>

<p>getCoordHash :: Int &ndash;> H.HashMap (Int,Int) Int
getCoordHash n = H.fromList $ zip (getSpiralCoords n) [1..]</p>

<p>genF :: H.HashMap (Int,Int) Int &ndash;> (Int, Int) &ndash;> Int
genF h (i,j) = h H.! (i,j)</p>

<p>getDiagElems :: M.Matrix Int &ndash;> Int &ndash;> Int
getDiagElems mat n =
  let leftDiag = sum $ [M.getElem i i mat | i &lt;&ndash; [1 .. n]]</p>

<pre><code>  rightDiag = sum $ [M.getElem i (n + 1 - i) mat | i &lt;- [1 .. n]]
  centerElem = let c = div (n+1) 2
               in
                M.getElem c c mat
</code></pre>

<p>  in
   leftDiag + rightDiag &ndash; centerElem</p>

<p>getSpiralMatrix :: Int &ndash;> M.Matrix Int
getSpiralMatrix n = M.matrix n n $ genF $ getCoordHash n</p>

<p>diagSum :: Int &ndash;> Int
diagSum n = getDiagElems (getSpiralMatrix n) n
```</p>

<p>I added type signatures for every function, so here&rsquo;s a quick overview (this is terribly over-engineered, and turned out to be more of a way to get to know various Haskell datatypes than to actually solve this problem!):</p>

<p><code>getSpiralMoves</code> translates the literal pattern of the square spiral into concrete steps and then <code>getSpiralCoords</code> converts these into <code>(i,j)</code> elements within the matrix. Since I use a <em>generating function</em> (in <code>getSpiralMatrix</code>) to create the matrix, I use a hash-map to store the value of each co-ordinate &hellip; and then <code>getDiagElems</code> iterates over the diagonal elements.</p>

<p>The matrix does turn out as expected:</p>

<p><code>haskell
*Main&gt; getSpiralMatrix 7
( 43 42 41 40 39 38 37 )
( 44 21 20 19 18 17 36 )
( 45 22  7  6  5 16 35 )
( 46 23  8  1  4 15 34 )
( 47 24  9  2  3 14 33 )
( 48 25 10 11 12 13 32 )
( 49 26 27 28 29 30 31 )
</code></p>

<p>This was a simple problem but I was surprised by how <em>short</em> the code was; I didn&rsquo;t write overly terse code, added lots of whitespace, indentation, extra lines, etc, and the whole piece was <em>still</em> just 60 lines!</p>

<p><strong>Update</strong>: Fine, here&rsquo;s the simple solution too.</p>

<p>For every <code>N x N</code> matrix (where <code>N</code> is odd), the diagonal elements are all the diagonal elements of the <code>N-2</code>-sized matrix, plus four more. And these four include <code>N^2</code> and three others, each being <code>(N-1)</code> less than the other. The base case is <code>1 x 1</code>, with a value of 1.</p>

<p>```haskell
euler28 :: Int &ndash;> Int
euler28 1 = 1
euler28 n = let sideDiff = n &ndash; 1</p>

<pre><code>            sq = n ^ 2
        in
         euler28 (n-2) + 4 * sq - (1 + 2 + 3) * sideDiff
</code></pre>

<p>```</p>

<p>&hellip; and then <code>euler28 1001</code> gives the same answer.</p>
]]></content>
  </entry>
  
</feed>
