<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projecteuler | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/projecteuler/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-05-04T03:11:58+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 48: Self powers]]></title>
    <link href="http://agam.github.io/blog/2015/05/04/euler-48-self-powers/"/>
    <updated>2015-05-04T03:09:53+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/04/euler-48-self-powers</id>
    <content type="html"><![CDATA[<p>One of the simplest problems, that would be a one-liner in Python or Lisp. Decided to do it in C++ anyway, using the <code>GMP</code> library (verbose, but runs in <code>4 ms</code>)</p>

<p>For this to work, you&rsquo;ll need to add (e.g. for <code>CMake</code>) a line like <code>target_link_libraries(Test gmpxx gmp)</code>, and include <code>gmpxx.h</code>.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```cpp
int main() {
  cout &lt;&lt; &ldquo;Euler #48 &hellip; \n&rdquo;;
  const int kNumTerms = 1000;</p>

<p>  // GMP has a C++ interface, see the following link:
  // <a href="https://gmplib.org/manual/C_002b_002b-Interface-General.html">https://gmplib.org/manual/C_002b_002b-Interface-General.html</a>
  mpz_class sum = 0;</p>

<p>  // Loop from 1 to 1000
  for (int i = 1; i &lt;= kNumTerms; ++i) {</p>

<pre><code>mpz_class term = 0;

// GMP exponentiation function, see documentation at:
// https://gmplib.org/manual/Integer-Exponentiation.html
mpz_ui_pow_ui(term.get_mpz_t(), i, i);

sum = sum + term;
</code></pre>

<p>  }</p>

<p>  mpz_class last_ten_digits;</p>

<p>  // We&rsquo;re looking for sum modulo (10 ^ 10)
  mpz_class divisor;
  mpz_ui_pow_ui(divisor.get_mpz_t(), 10, 10);
  mpz_mod(last_ten_digits.get_mpz_t(), sum.get_mpz_t(), divisor.get_mpz_t());
  cout &lt;&lt; &ldquo;The final answer is : &rdquo; &lt;&lt; last_ten_digits &lt;&lt; endl;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 47: Distinct Prime Factors]]></title>
    <link href="http://agam.github.io/blog/2015/05/04/euler-47-distinct-prime-factors/"/>
    <updated>2015-05-04T01:00:00+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/04/euler-47-distinct-prime-factors</id>
    <content type="html"><![CDATA[<p>This one turned out to be very similar to the previous one (except for the small detail of iterating from the smallest prime upwards, instead of the other way round).</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```cpp
class PrimeIterator {
public:
  PrimeIterator() : prime_index_(-1) {}</p>

<p>  int getNextPrime() {</p>

<pre><code>assert((prime_index_ + 1) &lt; primes_.size());
return primes_[++prime_index_];
</code></pre>

<p>  }</p>

<p>  bool hasMorePrimes() {</p>

<pre><code>assert(prime_index_ &gt;= -1 &amp;&amp; (prime_index_ + 1) &lt;= primes_.size());
return (prime_index_ + 1) &lt; primes_.size();
</code></pre>

<p>  }</p>

<p>  void fillPrimes(int max) {</p>

<pre><code>while (primes_.back() &lt;= max) {
  addPrime();
}
// Reset to before the first element
prime_index_ = -1;
</code></pre>

<p>  }</p>

<p>private:
  static void addPrime() {</p>

<pre><code>assert(primes_.size() &gt; 0);
int n = primes_.back();
while (true) {
  ++n;
  bool is_prime = true;
  for (const int&amp; p : primes_) {
    if (n % p == 0) {
      is_prime = false;
      break;  // Try next number
    }
  }
  if (is_prime) {
    primes_.push_back(n);
    return;
  }
}
</code></pre>

<p>  }</p>

<p>  static vector<int> primes_;</p>

<p>  int prime_index_;
};</p>

<p>vector<int> PrimeIterator::primes_ = {2};</p>

<p>int getNumPrimeFactors(int n) {
  int numPrimeFactors = 0;
  PrimeIterator pit;
  pit.fillPrimes(n);
  while (n > 1 &amp;&amp; pit.hasMorePrimes()) {</p>

<pre><code>int p = pit.getNextPrime();
if (n % p == 0) {
  while (n % p == 0) {
    n /= p;
  }
  ++numPrimeFactors;
}
</code></pre>

<p>  }
  return numPrimeFactors;
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #47 &hellip; \n&rdquo;;</p>

<p>  int runLength = 0;
  for (int n = 2; ; ++n) {</p>

<pre><code>if (getNumPrimeFactors(n) == 4) {
  ++runLength;
} else {
  runLength = 0;
}
if (runLength == 4) {
  cout &lt;&lt; "Found a sequence of four numbers with four prime "
       &lt;&lt; "factors starting at : " &lt;&lt; n - 3 &lt;&lt; endl;
  return 0;
}
</code></pre>

<p>  }
}
```</p>

<p>Runs as follows:</p>

<p>```sh
$ time ./Test
Euler #47 &hellip;
Found a sequence of four numbers with four prime factors starting at : <redacted></p>

<p>real    0m3.814s
user    0m3.812s
sys     0m0.000s
```</p>

<p>(Yep, a noticeable delay, but anything under 5 seconds is good for me &hellip;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 46: Goldbach's Other Conjecture]]></title>
    <link href="http://agam.github.io/blog/2015/05/03/euler-46-goldbacks-other-conjecture/"/>
    <updated>2015-05-03T23:46:24+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/03/euler-46-goldbacks-other-conjecture</id>
    <content type="html"><![CDATA[<p>May the brute force be with you. Here is another one (sorry for the over-engineered code).</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
class PrimeIterator {
public:
  PrimeIterator() : prime_index<em>(primes</em>.size() &ndash; 1) {}</p>

<p>  int getNextPrime() {</p>

<pre><code>assert(prime_index_ &gt; 0);
return primes_[--prime_index_];
</code></pre>

<p>  }</p>

<p>  bool hasMorePrimes() {</p>

<pre><code>return prime_index_ &gt; 0;
</code></pre>

<p>  }</p>

<p>  void fillPrimes(int max) {</p>

<pre><code>while (primes_.back() &lt;= max) {
  addPrime();
}
// Reset to the last element
prime_index_ = primes_.size() - 1;
</code></pre>

<p>  }</p>

<p>private:
  static void addPrime() {</p>

<pre><code>assert(primes_.size() &gt; 0);
int n = primes_.back();
while (true) {
  ++n;
  bool is_prime = true;
  for (const int&amp; p : primes_) {
    if (n % p == 0) {
      is_prime = false;
      break;  // Try next number
    }
  }
  if (is_prime) {
    primes_.push_back(n);
    return;
  }
}
</code></pre>

<p>  }</p>

<p>  static vector<int> primes_;</p>

<p>  int prime_index_;
};</p>

<p>vector<int> PrimeIterator::primes_ = {2};</p>

<p>bool goldbachDecompositionExists(int n) {
  assert(n % 2 == 1);
  // n = p + 2<em>m<sup>2</sup>
  // Since 2</em>m<sup>2</sup> is always even, and n is odd, p must be odd too (so p has to be 3 or greater)</p>

<p>  // Use a generator to get more primes on demand.
  PrimeIterator pit;
  pit.fillPrimes(n);
  while (pit.hasMorePrimes()) {</p>

<pre><code>int p = pit.getNextPrime();
if (p == n) {
  // If n is a prime, then n = p + 2*(0*0)
  return true;
}
double sq = (n - p)/2.0;
if (sqrt(sq) == floor(sqrt(sq))) {
  // n = p + 2*sqrt(sq)
  return true;
}
</code></pre>

<p>  }
  return false;
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #46 &hellip; \n&rdquo;;</p>

<p>  // Loop over odd composite numbers &hellip;
  for (int i = 9; ; i+= 2) {</p>

<pre><code>if (!goldbachDecompositionExists(i)) {
  cout &lt;&lt; "Failed at " &lt;&lt; i &lt;&lt; endl;
  return -1;
}
</code></pre>

<p>  }
}
```</p>

<p>Runs as follows:</p>

<p>```sh
$ time ./Test
Euler #46 &hellip;
Failed at <redacted></p>

<p>real    0m0.007s
user    0m0.004s
sys     0m0.000s
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 45: Triangle, Pengagonal, Hexagonal Numbers]]></title>
    <link href="http://agam.github.io/blog/2015/04/28/euler-44-triangle/"/>
    <updated>2015-04-28T19:41:00+00:00</updated>
    <id>http://agam.github.io/blog/2015/04/28/euler-44-triangle</id>
    <content type="html"><![CDATA[<p>While we&rsquo;re doing brute force solutions, here&rsquo;s another one &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```c++
uint64_t get_triangle(uint64_t n) {
  return n * (n + 1) / 2;
}</p>

<p>bool is_pentagonal(uint64_t num) {
  // y = x * (3*x &ndash; 1) / 2
  // So x is an integral solution of 3x<sup>2</sup> + (-1)x + (-2y) = 0
  // &hellip; or (1 + sqrt(1 + 24y))/6</p>

<p>  double solution = (1 + sqrt(1 + 24 * num)) / 6.0;
  double dummy;
  return (std::modf(solution, &amp;dummy) == 0.0);
}</p>

<p>bool is_hexagonal(uint64_t num) {
  // y = x * (2*x &ndash; 1)
  // So x is an integral solution of 2x<sup>2</sup> + (-1)x + (-y) = 0
  // &hellip; or (1 + sqrt(1 + 8y))/4</p>

<p>  double solution = (1 + sqrt(1 + 8 * num)) / 4.0;
  double dummy;
  return (std::modf(solution, &amp;dummy) == 0.0);
}</p>

<p>void sanity_check() {
  uint64_t t285 = get_triangle(285);
  assert(t285 == 40755);
  assert(is_pentagonal(t285));
  assert(is_hexagonal(t285));
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler # 45 &hellip; \n\n&rdquo;;</p>

<p>  sanity_check();
  // We already now that T_285 is pentagonal and hexagonal, so start
  // from the next index;
  uint64_t i = 286;
  for (; ; ++i) {</p>

<pre><code>uint64_t num = get_triangle(i);
if (is_pentagonal(num) &amp;&amp; is_hexagonal(num)) {
  cout &lt;&lt; "Found triangle# " &lt;&lt; i &lt;&lt; "  (" &lt;&lt; num &lt;&lt; ")" &lt;&lt; endl;
  return 0;
}
if (i % 100000 == 0) {
  cout &lt;&lt; "Done testing " &lt;&lt; i &lt;&lt; endl;
}
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 44: Pentagonal Numbers]]></title>
    <link href="http://agam.github.io/blog/2015/04/28/euler-44-pentagonal-numbers/"/>
    <updated>2015-04-28T18:08:09+00:00</updated>
    <id>http://agam.github.io/blog/2015/04/28/euler-44-pentagonal-numbers</id>
    <content type="html"><![CDATA[<p>I said I&rsquo;d try to work out the next problem on paper, but I gave up and wrote a program for it again :(</p>

<p>I honestly thought it would take a long time to run, with the final answer some grotesquely long number &hellip; but I was mistaken. ProjectEuler agrees with this assessment, since this happens to be officially categorized as among the <em>fifty easiest problems</em> (!)</p>

<p>It took just <code>90ms</code> to run, which is simply too much of a tradeoff to pass up.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```c++
uint64_t get_pentagonal(int n) {
  assert(n > 0);
  return n * (3 * n &ndash; 1) / 2;
}</p>

<p>bool is_pentagonal(uint64_t num) {
  // y = x * (3*x &ndash; 1) / 2
  // So x is an integral solution of 3x<sup>2</sup> + (-1)x + (-2y) = 0
  // &hellip; or (1 + sqrt(1 + 24y))/6</p>

<p>  double solution = (1 + sqrt(1 + 24 * num)) / 6.0;
  double dummy;</p>

<p>  // Check if the solution is an integer
  return (std::modf(solution, &amp;dummy) == 0.0);
}</p>

<p>bool check_pentagonal(int i, int j) {
  assert(i > 0 &amp;&amp; j > 0);
  assert(j &lt; i);
  uint64_t penta_i = get_pentagonal(i);
  uint64_t penta_j = get_pentagonal(j);
  uint64_t sum = penta_i + penta_j;
  uint64_t diff = penta_i &ndash; penta_j;
  if (is_pentagonal(sum) &amp;&amp; is_pentagonal(diff)) {</p>

<pre><code>cout &lt;&lt; "Found match for i = " &lt;&lt; i
     &lt;&lt; " and j = " &lt;&lt; j
     &lt;&lt; ", with diff = " &lt;&lt; diff &lt;&lt; endl;
return true;
</code></pre>

<p>  } else {</p>

<pre><code>return false;
</code></pre>

<p>  }
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler # 44 &hellip; \n\n&rdquo;;
  int i = 0;
  for (int i = 0; ; ++i) {</p>

<pre><code>for (int j = i-1; j &gt; 0; --j) {
  if (check_pentagonal(i,j)) {
    return 0;
  }
}
if (i % 1000 == 0) {
  cout &lt;&lt; "Done testing " &lt;&lt; i &lt;&lt; endl;
}
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
</feed>
