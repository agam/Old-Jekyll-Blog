<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projecteuler | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/projecteuler/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-02-22T04:48:12+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 31: Coin combinations (and over-engineering)]]></title>
    <link href="http://agam.github.io/blog/2015/02/22/euler-31-coin-combinations-and-over-engineering/"/>
    <updated>2015-02-22T04:44:55+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/22/euler-31-coin-combinations-and-over-engineering</id>
    <content type="html"><![CDATA[<p>I had this one all wrong, and made it way more complex than it really was. I&rsquo;m embarassed to post the final code &hellip; but it is what it is.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```haskell
import Data.Maybe</p>

<p>&mdash; Basic idea is something like this:
&mdash; [<em>] given amount and some coins, pick the largest coin
&mdash; [</em>] there are (floor (total/coin)) ways of using this coin value
&mdash; [*] but &hellip; NOT ALL of these count! Only the ones that leave a total that can be used with the remaining coins!</p>

<p>coins = [1, 2, 5, 10, 20, 50, 100, 200]</p>

<p>sortedCoins :: [Int]
sortedCoins = L.reverse $ L.sort $ coins</p>

<p>combinations :: Int &ndash;> [Int] &ndash;> Maybe Int
combinations total coins =
&mdash;  T.trace (&ldquo;total = &rdquo; ++ show total ++ &ldquo;, coins = &rdquo; ++ show coins) $
  if total == 0
  then Just 1
  else case coins of</p>

<pre><code>    [] -&gt; Nothing
    [c] -&gt; if mod total c == 0 then Just 1 else Nothing
    c:cs -&gt; if total == 0
            then Just 1
            else let newTotal total coin num = total - (coin * num)
                     combs = [combinations (newTotal total c num) cs | num &lt;- [0 .. div total c]]
                     counts = sum $ catMaybes combs
                 in
                  if counts == 0 then Nothing else Just counts
</code></pre>

<p>euler31 :: Int
euler31 = fromJust $ combinations 200 sortedCoins
```</p>

<p>It turns out, I was being overly cautious and could have just used lists in a different way (left in a commented out debug line to show that I needed it).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 30: sums of powers of digits]]></title>
    <link href="http://agam.github.io/blog/2015/02/18/euler-30-sums-of-powers-of-digits/"/>
    <updated>2015-02-18T21:41:02+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/18/euler-30-sums-of-powers-of-digits</id>
    <content type="html"><![CDATA[<p>Another quick and easy solution. This doesn&rsquo;t mean it&rsquo;s an <em>easy problem!</em>; no, it&rsquo;s more like playing a level at the <em>rookie level</em>. The hard and &ldquo;correct&rdquo; solution would be to work it out on pen-and-paper using Number Theory.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```haskell
digits :: Int &ndash;> [Int]
digits n = digitsHelper n []
  where</p>

<pre><code>digitsHelper num dList =
  if num &gt; 0
  then digitsHelper (div num 10) $ (mod num 10) : dList
  else dList
</code></pre>

<p>sumFifthPow :: Int &ndash;> Int
sumFifthPow n = sum $ map (^ 5) $ digits n</p>

<p>euler30 :: Int &ndash;> Int
euler30 limit = sum $ [x | x &lt;&ndash; [2 .. limit], x == sumFifthPow x]
```</p>

<p>Again, this version needs &ldquo;manual intervention&rdquo;, since I used the rough approximation that if <code>euler30 1000000</code> and <code>euler30 10000000</code> gave the same result, this was probably the right answer. It was.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 29: Distinct Powers]]></title>
    <link href="http://agam.github.io/blog/2015/02/18/euler-29-distinct-powers/"/>
    <updated>2015-02-18T00:56:01+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/18/euler-29-distinct-powers</id>
    <content type="html"><![CDATA[<p><strong>Statutory Warning</strong>: <em>Spoilers ahead!</em></p>

<p>Finally, we have a one-liner:</p>

<p><code>haskell
euler29 = length $ L.nub $ [a ^ b | a &lt;- [2 .. 100], b &lt;- [2 .. 100]]
</code></p>

<p>(where <code>L</code> is <code>Data.List</code>)</p>

<p><em>P.S.</em> I did make a dumb error by initiall writing this as two functions, with the second one taking <code>Int</code> instead of <code>Integer</code>, which (I&rsquo;m disappointed to say) resulted in everything silently overflowing to negative numbers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 28: Spiral diagonals]]></title>
    <link href="http://agam.github.io/blog/2015/02/17/euler-28-spiral-diagonals/"/>
    <updated>2015-02-17T19:33:10+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/17/euler-28-spiral-diagonals</id>
    <content type="html"><![CDATA[<p>This problem afforded a chance to be lazy and have fun.</p>

<p>There definitely is a pattern in the diagonals here: for a <code>3 x 3</code> matrix, the elements are 3, 5, 7, 9. For a <code>5 x 5</code> matrix, the additional elements are 13, 17, 21, 25.</p>

<p>You can see these as being (1 + 2), (1 + 4), (1 + 6), (1 + 8), and then (1 + 2 + 2 + 8), (1 + 4 + 4 + 8), (1 + 6 + 6 + 8), (1 + 8 + 8 + 8).</p>

<p>Similarly, for a <code>7 x 7</code> matrix, the numbers are 31, 37, 43, 49, which are (1 + 2 + 2 + 2 + 8 + 8 + 8), (1 + 4 + 4 + 4 + 8 + 8 + 8), (1 + 6 + 6 + 6 + 8 + 8 + 8), (1 + 8 + 8 + 8 + 8 + 8 + 8)</p>

<p>On the other hand, the problem mentions a <code>1001 x 1001</code> matrix, which is <em>tiny</em>, so why bother with these patterns? Just create the matrix and sum up the diagonals directly! (It&rsquo;s <em>just</em> a million elements &hellip; now if it was a few orders of magnitude higher, it would be a different story)</p>

<p><strong>Statutory Warning</strong>: Spoilers ahead!</p>

<p>```haskell
import qualified Data.List as L
import qualified Data.Vector as V
import qualified Data.Matrix as M
import qualified Data.HashMap.Strict as H
import Prelude hiding (Left,Right)</p>

<p>&mdash; Euler 28: spiral int matrix</p>

<p>data Direction = Down | Left | Right | Up deriving Show</p>

<p>move :: (Int,Int) &ndash;> Direction &ndash;> (Int,Int)
move oldPoint@(y,x) dir =
  case dir of Down &ndash;> (y+1,x)</p>

<pre><code>          Left -&gt; (y,x-1)
          Right -&gt; (y,x+1)
          Up -&gt; (y-1,x)
</code></pre>

<p>getSpiralMoves :: Int &ndash;> [Direction]
getSpiralMoves n =
  if n == 3
  then [Down, Right, Up, Up, Left, Left, Down, Down]
  else let prevMoves = getSpiralMoves (n-2)</p>

<pre><code>       firstMove = [Down]
       secondMove = take (n-2) $ repeat Right
       thirdMove = take (n-1) $ repeat Up
       fourthMove = take (n-1) $ repeat Left
       fifthMove = take (n-1) $ repeat Down
   in
    prevMoves ++ firstMove ++ secondMove ++ thirdMove ++ fourthMove ++ fifthMove
</code></pre>

<p>getSpiralCoords :: Int &ndash;> [(Int,Int)]
getSpiralCoords n =
  let mid = div (n+1) 2</p>

<pre><code>  start = (mid,mid)
</code></pre>

<p>  in
   L.scanl move start $ getSpiralMoves n</p>

<p>getCoordHash :: Int &ndash;> H.HashMap (Int,Int) Int
getCoordHash n = H.fromList $ zip (getSpiralCoords n) [1..]</p>

<p>genF :: H.HashMap (Int,Int) Int &ndash;> (Int, Int) &ndash;> Int
genF h (i,j) = h H.! (i,j)</p>

<p>getDiagElems :: M.Matrix Int &ndash;> Int &ndash;> Int
getDiagElems mat n =
  let leftDiag = sum $ [M.getElem i i mat | i &lt;&ndash; [1 .. n]]</p>

<pre><code>  rightDiag = sum $ [M.getElem i (n + 1 - i) mat | i &lt;- [1 .. n]]
  centerElem = let c = div (n+1) 2
               in
                M.getElem c c mat
</code></pre>

<p>  in
   leftDiag + rightDiag &ndash; centerElem</p>

<p>getSpiralMatrix :: Int &ndash;> M.Matrix Int
getSpiralMatrix n = M.matrix n n $ genF $ getCoordHash n</p>

<p>diagSum :: Int &ndash;> Int
diagSum n = getDiagElems (getSpiralMatrix n) n
```</p>

<p>I added type signatures for every function, so here&rsquo;s a quick overview (this is terribly over-engineered, and turned out to be more of a way to get to know various Haskell datatypes than to actually solve this problem!):</p>

<p><code>getSpiralMoves</code> translates the literal pattern of the square spiral into concrete steps and then <code>getSpiralCoords</code> converts these into <code>(i,j)</code> elements within the matrix. Since I use a <em>generating function</em> (in <code>getSpiralMatrix</code>) to create the matrix, I use a hash-map to store the value of each co-ordinate &hellip; and then <code>getDiagElems</code> iterates over the diagonal elements.</p>

<p>The matrix does turn out as expected:</p>

<p><code>haskell
*Main&gt; getSpiralMatrix 7
( 43 42 41 40 39 38 37 )
( 44 21 20 19 18 17 36 )
( 45 22  7  6  5 16 35 )
( 46 23  8  1  4 15 34 )
( 47 24  9  2  3 14 33 )
( 48 25 10 11 12 13 32 )
( 49 26 27 28 29 30 31 )
</code></p>

<p>This was a simple problem but I was surprised by how <em>short</em> the code was; I didn&rsquo;t write overly terse code, added lots of whitespace, indentation, extra lines, etc, and the whole piece was <em>still</em> just 60 lines!</p>

<p><strong>Update</strong>: Fine, here&rsquo;s the simple solution too.</p>

<p>For every <code>N x N</code> matrix (where <code>N</code> is odd), the diagonal elements are all the diagonal elements of the <code>N-2</code>-sized matrix, plus four more. And these four include <code>N^2</code> and three others, each being <code>(N-1)</code> less than the other. The base case is <code>1 x 1</code>, with a value of 1.</p>

<p>```haskell
euler28 :: Int &ndash;> Int
euler28 1 = 1
euler28 n = let sideDiff = n &ndash; 1</p>

<pre><code>            sq = n ^ 2
        in
         euler28 (n-2) + 4 * sq - (1 + 2 + 3) * sideDiff
</code></pre>

<p>```</p>

<p>&hellip; and then <code>euler28 1001</code> gives the same answer.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 27: Quadratic Primes]]></title>
    <link href="http://agam.github.io/blog/2015/02/14/euler-27-quadratic-primes/"/>
    <updated>2015-02-14T18:43:24+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/14/euler-27-quadratic-primes</id>
    <content type="html"><![CDATA[<p><strong>Statutory Warning</strong>: Spoilers ahead</p>

<p><em>This turned out to be really simple, though I went through a phase of churning out complicated solutions because of a stupid mistake.</em></p>

<p>I didn&rsquo;t preserve intermediate versions, so here is the final solution:</p>

<p>```haskell
import qualified Data.List as L
import qualified Data.Vector as V
import qualified Data.Function as F</p>

<p>sieve :: Int &ndash;> [Int] &ndash;> [Int]
sieve num list =
  if null list
  then [num]
  else let rest = filter (\x &ndash;> x <code>mod</code> num > 0) list</p>

<pre><code>   in
    num : sieve (head rest) (tail rest)
</code></pre>

<p>eratosthenes :: Int &ndash;> [Int]
eratosthenes maxNum = sieve 2 [3 .. maxNum]</p>

<p>allPrimes :: Int &ndash;> V.Vector Int
allPrimes maxNum = V.fromList $ eratosthenes maxNum</p>

<p>eulerEqn :: Int &ndash;> Int &ndash;> Int &ndash;> Int
eulerEqn a b n = n * n + a * n + b</p>

<p>&mdash; TODO(agam): replace with the &ldquo;standard&rdquo; way to do binary search
binSearch :: V.Vector Int &ndash;> Int &ndash;> Int &ndash;> Int &ndash;> Bool
binSearch arr min max elem =
  let low = arr V.! min</p>

<pre><code>  high = arr V.! max
</code></pre>

<p>  in
   if max &ndash; min &lt; 2
   then if low == elem</p>

<pre><code>    then True
    else False
</code></pre>

<p>   else let mid = div (min + max) 2</p>

<pre><code>        midElem = arr V.! mid
    in
     if midElem &gt; elem
     then binSearch arr min mid elem
     else binSearch arr mid max elem
</code></pre>

<p>consecutivePrimes a b primes start length =
  let p = eulerEqn a b start</p>

<pre><code>  l = V.length primes
  isPrime = binSearch primes 0 l p
</code></pre>

<p>  in
   if isPrime
   then consecutivePrimes a b primes (start + 1) (length + 1)
   else length</p>

<p>numPrimes a b primes = consecutivePrimes a b primes 0 0</p>

<p>euler27 maxNum =
  let ap = allPrimes maxNum</p>

<pre><code>  primeLengths = [(a * b, numPrimes a b ap) | a &lt;- [-1000 .. 1000], b &lt;- [-1000 .. 1000]]
</code></pre>

<p>  in
   L.maximumBy (F.on compare snd) primeLengths
```</p>

<p>When I ran this (i.e. <code>euler27 1000</code>) I got the correct answer the first time! But <em>I didn&rsquo;t see it</em>. Instead, I entered the <em>second</em> value of the tuple, which is <em>not</em> the one asked for, and it was therefore <em>obviously</em> wrong. So I thought &ldquo;hmm, we&rsquo;re looking at some large repeating sequence among really large primes&rdquo;, and tried <code>euler27 100000</code> and <code>euler27 10000000</code>, with no luck.</p>

<p>The last one kept running for hours and I killed it, and then came up with the idea of &ldquo;vectorizing everything&rdquo; &mdash; which was perhaps a good academic exercise but did absolutely <em>nothing</em> for the performance here.</p>

<p>So I forgot about it for a while, then came back and ran <code>euler27 1000</code>, entered the <em>first</em> value of the tuple, and that was the end of this story.</p>
]]></content>
  </entry>
  
</feed>
