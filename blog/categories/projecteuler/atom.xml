<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projecteuler | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/projecteuler/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-04-28T18:13:47+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 44: Pentagonal Numbers]]></title>
    <link href="http://agam.github.io/blog/2015/04/28/euler-44-pentagonal-numbers/"/>
    <updated>2015-04-28T18:08:09+00:00</updated>
    <id>http://agam.github.io/blog/2015/04/28/euler-44-pentagonal-numbers</id>
    <content type="html"><![CDATA[<p>I said I&rsquo;d try to work out the next problem on paper, but I gave up and wrote a program for it again :(</p>

<p>I honestly thought it would take a long time to run, with the final answer some grotesquely long number &hellip; but I was mistaken. ProjectEuler agrees with this assessment, since this happens to be officially categorized as among the <em>fifty easiest problems</em> (!)</p>

<p>It took just <code>90ms</code> to run, which is simply too much of a tradeoff to pass up.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```c++
uint64_t get_pentagonal(int n) {
  assert(n > 0);
  return n * (3 * n &ndash; 1) / 2;
}</p>

<p>bool is_pentagonal(uint64_t num) {
  // y = x * (3*x &ndash; 1) / 2
  // So x is an integral solution of 3x<sup>2</sup> + (-1)x + (-2y) = 0
  // &hellip; or (1 + sqrt(1 + 24y))/6</p>

<p>  double solution = (1 + sqrt(1 + 24 * num)) / 6.0;
  double dummy;</p>

<p>  // Check if the solution is an integer
  return (std::modf(solution, &amp;dummy) == 0.0);
}</p>

<p>bool check_pentagonal(int i, int j) {
  assert(i > 0 &amp;&amp; j > 0);
  assert(j &lt; i);
  uint64_t penta_i = get_pentagonal(i);
  uint64_t penta_j = get_pentagonal(j);
  uint64_t sum = penta_i + penta_j;
  uint64_t diff = penta_i &ndash; penta_j;
  if (is_pentagonal(sum) &amp;&amp; is_pentagonal(diff)) {</p>

<pre><code>cout &lt;&lt; "Found match for i = " &lt;&lt; i
     &lt;&lt; " and j = " &lt;&lt; j
     &lt;&lt; ", with diff = " &lt;&lt; diff &lt;&lt; endl;
return true;
</code></pre>

<p>  } else {</p>

<pre><code>return false;
</code></pre>

<p>  }
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler # 44 &hellip; \n\n&rdquo;;
  int i = 0;
  for (int i = 0; ; ++i) {</p>

<pre><code>for (int j = i-1; j &gt; 0; --j) {
  if (check_pentagonal(i,j)) {
    return 0;
  }
}
if (i % 1000 == 0) {
  cout &lt;&lt; "Done testing " &lt;&lt; i &lt;&lt; endl;
}
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 42: Pandigitals with sub-string divisibility]]></title>
    <link href="http://agam.github.io/blog/2015/03/25/euler-42-pandigitals-with-sub-string-divisibility/"/>
    <updated>2015-03-25T23:33:56+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/25/euler-42-pandigitals-with-sub-string-divisibility</id>
    <content type="html"><![CDATA[<p>These brute force solutions are getting a bit worrying, but here is another one. (I keep promising myself to get out of my comfort zone, but (<em>unfortunately!</em>) code like this is too easy to write).</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```lisp
;; For all 0-9 pandigital numbers, find the ones which have successive
;; substrings of length 3 diisible by 2,3,&hellip;,17.</p>

<p>(defparameter <em>prime-divisors</em> #(17 13 11 7 5 3 2))</p>

<p>;; A number is 0-9 pandigital if it (a) is 10 digits long, and (b) has every digit from 0-9
(defun is-pandigital (num)
  (declare (type fixnum num))
  (let ((digits-seen (make-array 10 :element-type &lsquo;bit :initial-element 0)))</p>

<pre><code>(do* ((n num (floor (/ n 10)))
      (d (mod n 10) (mod n 10))
      (num-digits 0 (1+ num-digits)))
     ((= n 0) (and (= num-digits 10)
                   (every (lambda (x) (= x 1)) digits-seen)))
  (setf (bit digits-seen d) 1))))
</code></pre>

<p>(defun check-divisibility (num div-index)
  (= 0 (mod num (aref <em>prime-divisors</em> div-index))))</p>

<p>(defun get-three-digit-num (num)
  (let ((ones (mod num 10))</p>

<pre><code>    (tens (mod (floor (/ num 10)) 10))
    (hundreds (mod (floor (/ num 100)) 10)))
(+ ones
   (* 10 tens)
   (* 100 hundreds))))
</code></pre>

<p>;; Go backwards in groups of three digits and check divisibility
(defun has-divisible-substrings (num)
  (do* ((n num (floor (/ n 10)))</p>

<pre><code>    (div-index 0 (1+ div-index))
    (dividend (get-three-digit-num n) (get-three-digit-num n))
    (div-p (check-divisibility dividend div-index)
           (and div-p (check-divisibility dividend div-index))))
   ((&lt; n 10000) div-p)))
</code></pre>

<p>(defun check-substring-pandigital-range (start end)
  (declare (type fixnum start end))
  (let ((candidates &lsquo;()))</p>

<pre><code>(loop for num from start to end do
     (if (and (is-pandigital num)
              (has-divisible-substrings num))
         (push num candidates)))
candidates))
</code></pre>

<p>(defun euler43 ()
  (let ((candidates (check-substring-pandigital-range 1234567890 9876543210)))</p>

<pre><code>(print candidates)
(apply #'+ candidates)))
</code></pre>

<p>```</p>

<p>As before, evaluating <code>(euler43)</code> shows the final solution (sum), along with the (six!) candidate numbers making up the sum. This took a whopping <code>4.3 hours</code> to churn through the 8.5 billion numbers. Maybe I need to create a new constraint for these problems: either pen-and-paper, or something <em>slow</em> (like Python ?! :P), so that brute force is never tempting again.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 42: Coded triangle numbers]]></title>
    <link href="http://agam.github.io/blog/2015/03/23/euler-42-coded-triangle-numbers/"/>
    <updated>2015-03-23T01:11:01+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/23/euler-42-coded-triangle-numbers</id>
    <content type="html"><![CDATA[<p>Very straightforward, this one. And I don&rsquo;t need to feel bad that I did it the simple way. If you&rsquo;re wondering where <code>split-sequence-if</code> and <code>read-file</code> came from, the answer is <code>rutils</code>, which is a good general-purpose utility package, a sort of superset of <code>alexandria</code>, and just a <code>(ql:quickload 'rutils)</code> away. As before, the final answer is obtained by evaluating <code>(euler42)</code>.</p>

<p><strong>Statutory Warning</strong>: <em>spoilers ahead</em></p>

<p>```lisp
;; If x = 0.5 * n * (n+1) is a triangle number, then there is an
;; integral solution for n<sup>2</sup> + n &ndash; 2<em>x = 0.
(defun quadratic-solution (a b c)
  (let ((det (sqrt (&ndash; (</em> b b) (* 4 a c))))</p>

<pre><code>    (denom (* 2 a)))
(cons (/ (- (- b) det) denom)
      (/ (+ (- b) det) denom))))
</code></pre>

<p>(defun positive-int (num)
  (and (integerp num)</p>

<pre><code>   (plusp num)))
</code></pre>

<p>(defun is-triangle-number (num)
  (let ((soln (quadratic-solution 1 1 (* (&ndash; 2) num))))</p>

<pre><code>(or (positive-int (car soln))
    (positive-int (cdr soln)))))
</code></pre>

<p>(defun char->number (char)
  (1+ (&ndash; (char-code char) (char-code #\A))))</p>

<p>(defun is-triangle-word (word)
  (let ((value (loop for char across word</p>

<pre><code>              summing (char-&gt;number char))))
(is-triangle-number value)))       
</code></pre>

<p>(defun euler42 ()
  ;; Read in the file, split on the commas, remove the quotes
  (let* ((file-text (read-file &ldquo;/home/agam/Downloads/p042_words.txt&rdquo;))</p>

<pre><code>     (words-with-quotes (split-sequence-if
                         (lambda (char) (eq char #\,))
                         file-text))
     (words (mapcar (lambda (w) (remove #\" w))
                    words-with-quotes)))
(loop for w in words count
     (is-triangle-word w))))
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 41: Pandigital primes]]></title>
    <link href="http://agam.github.io/blog/2015/03/22/euler-41-pandigital-primes/"/>
    <updated>2015-03-22T04:35:08+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/22/euler-41-pandigital-primes</id>
    <content type="html"><![CDATA[<p>Yet another <em>brute-force</em> solution, pushing the line a bit at <em>1991 seconds</em>. But hey, it works, and was quick to write, so &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>spoilers ahead</em></p>

<p>```lisp
(defparameter <em>max-num-limit</em> 1000000000)
(defparameter <em>all-numbers</em> (make-array (list <em>max-num-limit</em>) :element-type &lsquo;bit :initial-element 1))</p>

<p>(defun mark-primes (&amp;optional (n <em>max-num-limit</em>))
  ;; 0 and 1 are not prime
  (mark-not-prime 0)
  (mark-not-prime 1)
  ;; Mark 2 as prime, then do the following:
  ;; (1) Mark all multiples of the prime number,
  ;; (2) Find next available prime number, mark it as prime,
  ;; Repeat (1) until n
  (let ((prime 2))</p>

<pre><code>(loop while (&lt; prime n) do
     (mark-prime-multiples prime n)
     (setf prime (find-next-prime prime n)))))
</code></pre>

<p>(defun mark-not-prime (idx)
  (setf (bit <em>all-numbers</em> idx) 0))</p>

<p>(defun mark-prime-multiples (prime limit)
  (do ((i (* prime 2) (+ i prime)))</p>

<pre><code>  ((&gt;= i limit))
(mark-not-prime i)))
</code></pre>

<p>(defun find-next-prime (prev-prime limit)
  (do ((i (1+ prev-prime) (1+ i)))</p>

<pre><code>  ((or (= i limit) (= 1 (bit *all-numbers* i))) i)))
</code></pre>

<p>(defun is-prime (n)
  (= 1 (bit <em>all-numbers</em> n)))</p>

<p>(defun get-num-digits (n)
  (ceiling (log n 10)))</p>

<p>(defun is-pandigital (n)
  (let* ((num-digits (get-num-digits n))</p>

<pre><code>     (digits (make-array num-digits :element-type 'bit :initial-element 0)))
(loop while (and (&gt; n 0)
                 (&gt; (mod n 10) 0)
                 (&lt;= (mod n 10) num-digits)) do
     (setf (bit digits (1- (mod n 10))) 1)
     (setf n (floor (/ n 10))))
(= (length digits) (count 1 digits))))
</code></pre>

<p>(defun euler41 ()
  (mark-primes)
  (do ((n 987654321 (1- n)))</p>

<pre><code>  ((and (is-pandigital n) (is-prime n)) n)))
</code></pre>

<p>```</p>

<p>Everything is wrapped up in the call to <code>(euler41)</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 40: Champernowne's Constant]]></title>
    <link href="http://agam.github.io/blog/2015/03/21/euler-40-champernownes-constant/"/>
    <updated>2015-03-21T19:34:12+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/21/euler-40-champernownes-constant</id>
    <content type="html"><![CDATA[<p>I was too lazy to avoid the brute-force approach here, especially since it took less than a second to run. The following seems longer than it should be, partly because I left in some helper and debugging functions &hellip;</p>

<p><em>Edit</em>: There is obviously a very nice paper-and-pen solution to this &mdash; the 10th place is &lsquo;1&rsquo; (for 10), then the 100th place is &lsquo;5&rsquo; (for 55), and so on &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```lisp
(defparameter <em>max-digits</em> 2000000)</p>

<p>(defun digits (n)
  (declare (type fixnum n))
  (nreverse (loop</p>

<pre><code>           for tmp = n then (floor (/ tmp 10))
           until (= tmp 0)
           collect (mod tmp 10))))
</code></pre>

<p>(defun set-digits (d start all-digits)
  (loop</p>

<pre><code> for elem in d
 for idx = start then (1+ idx) do
   (setf (aref all-digits idx) elem)))
</code></pre>

<p>;; Fills out the array of digits and returns an accessor function
;; Note: the index increments by the length of the number of
;; digits of the <em>previous</em> number.
(let ((all-digits (make-array (list <em>max-digits</em>) :element-type &lsquo;(integer 0 9) :initial-element 0)))
  (defun populate-digits (n)</p>

<pre><code>(progn
  (loop
     for num = 1 then (1+ num)
     for d = (digits num)
     for i = 0 then (+ i (length (digits (1- num))))
     while (&lt; i n) do
       (set-digits d i all-digits))
(lambda (idx)
  (aref all-digits idx)))))
</code></pre>

<p>(defun power-list ()
  (let ((champer (populate-digits 1000000)))</p>

<pre><code>(loop for p from 0 to 6 collect
     (funcall champer (1- (expt 10 p))))))
</code></pre>

<p>(defun euler40 ()
  (apply &lsquo;* (power-list)))</p>

<p>;; Useful debugging tool
(defun scan-list (start end)
  (let ((champer (populate-digits)))</p>

<pre><code>(loop for i from start to end do
     (print (cons i (funcall champer i))))))
</code></pre>

<p>```</p>

<p>The &ldquo;final answer&rdquo; is given by <code>(euler40)</code>, and the intermediate digits themselves by <code>(power-list)</code>. I found <code>(scan-list)</code> useful to debug an embarassing off-by-one error in the loop.</p>
]]></content>
  </entry>
  
</feed>
