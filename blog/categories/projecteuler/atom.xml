<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projecteuler | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/projecteuler/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2016-02-26T23:58:14-08:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Moving on from Project Euler]]></title>
    <link href="http://agam.github.io/blog/2015/05/29/project-euler-and-learning-programming/"/>
    <updated>2015-05-29T12:37:07-07:00</updated>
    <id>http://agam.github.io/blog/2015/05/29/project-euler-and-learning-programming</id>
    <content type="html"><![CDATA[<p>I started doing Project Euler problems occasionally with the assumption that it was a good way to either (1) learn a new language, or (2) as a healthy way to keep practicing programming. It turns out, however, that what I <em>really</em> end up doing is &ldquo;brute-forcing&rdquo; problems that are really <em>math</em> problems.</p>

<p>So while I really should continue, I should do so by learning more math, instead of banging away at bad implementations. When I looked around for options for these, I realized that (as in so many other things) we&rsquo;re spoilt for choice! Options abound, ranging from the &ldquo;Daily Programmer&rdquo; <a href="https://www.reddit.com/r/dailyprogrammer">subreddit</a>, to dedicated (<em>free!</em>) practice sites like <a href="https://www.codeeval.com/">CodeEval</a>, <a href="https://www.hackerrank.com/">HackerRank</a>, or <a href="http://coderbyte.com/">CoderByte</a>.</p>

<p>Eventually I just picked one at random and decided to start doing roughly one problem a day (I picked <a href="https://www.hackerrank.com/">CodeWars</a>, which has an amusing &ldquo;dojo&rdquo; feel to it). We&rsquo;ll see how long it lasts :)</p>

<p><strong>Edit</strong>: There is a bigger list of &ldquo;coding challenge&rdquo; sites <a href="http://codecondo.com/coding-challenges/">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 50: Consecutive Prime Sum]]></title>
    <link href="http://agam.github.io/blog/2015/05/29/euler-50-consecutive-prime-sum/"/>
    <updated>2015-05-29T12:24:32-07:00</updated>
    <id>http://agam.github.io/blog/2015/05/29/euler-50-consecutive-prime-sum</id>
    <content type="html"><![CDATA[<p>I had posted a grotesque non-working solution to this <a href="/blog/2015/05/17/euler-50-a-non-working-solution/">previously</a>, so here is a grotesque <em>working</em> solution.</p>

<p>Yes, it uses global variables and old-fashioned extra book-keeping, and the <code>main</code> function is just a step-wise procedural function, but it <em>works</em> and it&rsquo;s <em>correct</em>, so I&rsquo;m going to leave it as is.</p>

<p><strong>Statutory warning</strong>: <em>Spoilers ahead</em></p>

<p>```go
const MAX_NUM = 1000000</p>

<p>type Number struct {</p>

<pre><code>isPrime              bool
maxPrimeSum          int
maxConsecutivePrimes int
previousPrimeIndex   int
</code></pre>

<p>}</p>

<p>// Oh noez! A <em>global</em> variable!
var numbers []Number</p>

<p>func markMultiples(p int) {</p>

<pre><code>for n := 2 * p; n &lt; len(numbers); n += p {
    numbers[n].isPrime = false
}
</code></pre>

<p>}</p>

<p>func populatePrimes() {</p>

<pre><code>// First mark all numbers as prime
for i := 0; i &lt; len(numbers); i++ {
    numbers[i].isPrime = true
}

// Bootstrap our loop with the first prime, 2
numbers[0].isPrime = false
numbers[1].isPrime = false

prevPrime := 2
numbers[2].isPrime = true
numbers[2].previousPrimeIndex = -1

// Straightforward sieve
markMultiples(prevPrime)
for p := 3; p &lt; len(numbers); p++ {
    if numbers[p].isPrime {
        numbers[p].previousPrimeIndex = prevPrime
        prevPrime = p
        markMultiples(prevPrime)
    }
}
</code></pre>

<p>}</p>

<p>func calculatePrimeSums() {</p>

<pre><code>// Initialize first prime, then move out from there
numbers[2].maxPrimeSum = 2
numbers[2].maxConsecutivePrimes = 1

// As an upper limit for sums, what's the largest prime we have?
largestPrime := MAX_NUM
for i := MAX_NUM - 1; i &gt; 0; i-- {
    if numbers[i].isPrime {
        largestPrime = i
        break
    }
}
fmt.Println("The largest possible prime to sum to is : ", largestPrime)

for i := 3; i &lt; len(numbers); i++ {
    if !numbers[i].isPrime {
        continue
    }

    sum := 0
    numPrimesTried := 0
    lastPrimeSum := 0
    numPrimesInSum := 0
    // Go back through the sequence of primes, until the
    // sum goes past the largest possible prime. Store the
    // last sum reached that _was_ a prime, and the number
    // of primes involved.
    for p := i; p &gt; 0; p = numbers[p].previousPrimeIndex {
        if !numbers[p].isPrime {
            panic("wtf")
        }
        sum += p
        numPrimesTried++
        if sum &gt; largestPrime {
            // Don't try any more primes!
            break
        } else {
            // Book keeping
            if numbers[sum].isPrime {
                lastPrimeSum = sum
                numPrimesInSum = numPrimesTried
            }
        }
    }
    numbers[i].maxPrimeSum = lastPrimeSum
    numbers[i].maxConsecutivePrimes = numPrimesInSum
    //      fmt.Println("max prime sum for ", i, " = ", numbers[i].maxPrimeSum)
}
</code></pre>

<p>}</p>

<p>func findMaxPrimeSum() {</p>

<pre><code>// Use the pre-calculated primes sums to figure out the maximum and print some summary info
maxConsecutivePrimes := 0
maxPrimeSum := 0
for i := 0; i &lt; MAX_NUM; i++ {
    if numbers[i].isPrime {
        if numbers[i].maxConsecutivePrimes &gt; maxConsecutivePrimes {
            maxConsecutivePrimes = numbers[i].maxConsecutivePrimes
            maxPrimeSum = numbers[i].maxPrimeSum
            fmt.Println("max prime sum = ", maxPrimeSum, ", with ", maxConsecutivePrimes, " primes, ending in ", i)
        }
    }
}
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>numbers = make([]Number, MAX_NUM)
populatePrimes()
calculatePrimeSums()
findMaxPrimeSum()
</code></pre>

<p>}
```</p>

<p>The best part? It ran in <code>0.363 seconds</code>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 50: A non-working solution]]></title>
    <link href="http://agam.github.io/blog/2015/05/16/euler-50-a-non-working-solution/"/>
    <updated>2015-05-16T19:56:08-07:00</updated>
    <id>http://agam.github.io/blog/2015/05/16/euler-50-a-non-working-solution</id>
    <content type="html"><![CDATA[<p>It&rsquo;s worth pointing out things that don&rsquo;t work, roads that lead to dead ends, etc &mdash; so here is a brute force solution that has absolutely no chance of ever working. It&rsquo;s long and verbose because it&rsquo;s a <em>franken-solution</em>, made out of parts of previous solution concatenated together into a terrible mess. Posting it here before I destroy it. The forlorn <code>TODO</code> at the end proved over-optimistic &hellip;</p>

<p>```c++
static const int kMaxNum = 1000000;</p>

<p>void PopulatePrimes(vector<bool><em> numbers, vector<int></em> prime_indices) {
  // Start off with all numbers marked prime.
  for (int i = 2; i &lt; numbers->size(); ++i) {</p>

<pre><code>numbers-&gt;at(i) = true;
</code></pre>

<p>  }</p>

<p>  int prime_index = 2;
  while (true) {</p>

<pre><code>// Store the prime index for future reference
prime_indices-&gt;push_back(prime_index);

if (numbers-&gt;size() &lt; 2 * prime_index) {
  break;
}

// Mark the multiples as not prime
for (int i = prime_index * 2; i &lt; numbers-&gt;size(); i += prime_index) {
  numbers-&gt;at(i) = false;
}

// Repeat with the next prime number
do {
  ++prime_index;
} while (prime_index &lt; numbers-&gt;size() &amp;&amp; !numbers-&gt;at(prime_index));

if (prime_index == numbers-&gt;size()) {
  break;
}
</code></pre>

<p>  }
}</p>

<p>void sanity_check_primes(const vector<bool>&amp; numbers,</p>

<pre><code>                     const vector&lt;int&gt;&amp; prime_indices) {
</code></pre>

<p>  auto check_prime = <a href="int%20n,%20bool%20is_prime">&amp;numbers, &amp;prime_indices</a> {</p>

<pre><code>if (is_prime) {
  assert(numbers[n] == true);
  assert(std::find(prime_indices.begin(), prime_indices.end(), n) !=
         prime_indices.end());
} else {
  assert(numbers[n] == false);
  assert(std::find(prime_indices.begin(), prime_indices.end(), n) ==
         prime_indices.end());
}
</code></pre>

<p>  };</p>

<p>  check_prime(2, true);
  check_prime(3, true);
  check_prime(5, true);
  check_prime(4, false);
  check_prime(6, false);
}</p>

<p>class CombinationIterator {
public:
  CombinationIterator(int n, int m) : n<em>(n), m</em>(m) {</p>

<pre><code>comb_.reserve(m);
for (int i = 0; i &lt; m; ++i) {
  comb_.push_back(i);
}
</code></pre>

<p>  }</p>

<p>  const vector<int>&amp; GetCombination() const {</p>

<pre><code>return comb_;
</code></pre>

<p>  }</p>

<p>  bool Next() {</p>

<pre><code>// The last digit can go up to n, the next-to-last up to n-1, and
// so on. The very first sequence is {0, 1, ..., m-1}, and the
// very last is {n-m+1, ..., n-1, n}.
for (int i = m_ - 1; i &gt;= 0; --i) {
  int max = n_ + i - m_ + 1;
  int val = comb_[i];
  // cout &lt;&lt; "Debug: i = " &lt;&lt; i &lt;&lt; ", val = " &lt;&lt; val &lt;&lt; ", max = " &lt;&lt; max &lt;&lt; endl;
  if (val &lt; max) {
    // Increment this position, and update subsequent indices if
    // necessary.
    for (int j = i; j &lt; m_; ++j) {
      comb_[j] = ++val;
    }
    return true;
  }

  // If we're at the beginning, we're done.
  if (i == 0) {
    return false;
  }

  // Otherwise, fallthrough to the previous index.
}
assert(false);  // Should not reach here!
</code></pre>

<p>  }
private:
  const int n<em>, m</em>;
  vector<int> comb_;
};</p>

<p>void sanity_check_combinator() {
  CombinationIterator cit(9, 4);
  for (int i = 0; i &lt; 20; ++i) {</p>

<pre><code>const auto&amp; v = cit.GetCombination();
cout &lt;&lt; "Debug (" &lt;&lt; v.size() &lt;&lt; ") : ";
for (int n : v) {
  cout &lt;&lt; n &lt;&lt; "  ";
}
cout &lt;&lt; endl;
assert(cit.Next());
</code></pre>

<p>  }
}</p>

<p>enum class Cardinality {
  Zero, One, More
};</p>

<p>Cardinality GetPrimeSum(int num_summands,</p>

<pre><code>                    const vector&lt;bool&gt;&amp; numbers,
                    const vector&lt;int&gt;&amp; prime_indices) {
</code></pre>

<p>  // Try all possible combinations of adding prime numbers
  // together. Either exhaust all combinations, in which case return
  // Zero or One. The moment two are found, return More.</p>

<p>  int num_primes = 0;
  CombinationIterator cit(numbers.size(), num_summands);
  do {</p>

<pre><code>const auto&amp; pv = cit.GetCombination();
int sum = 0;
for (int p : pv) {
  sum += p;
}

// Check if the primes add up to a prime
if (sum &lt; numbers.size() &amp;&amp; numbers[sum]) {
  ++num_primes;
}
if (num_primes == 2) {
  return Cardinality::More;
}
</code></pre>

<p>  } while (cit.Next());
  assert(num_primes == 0 || num_primes == 1);
  if (num_primes == 1) {</p>

<pre><code>return Cardinality::One;
</code></pre>

<p>  } else {</p>

<pre><code>return Cardinality::Zero;
</code></pre>

<p>  }
}</p>

<p>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const Cardinality&amp; c) {
  os &lt;&lt; static_cast&lt;std::underlying_type<Cardinality>::type>&copy;;
  return os;
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #50 &hellip; \n&rdquo;;</p>

<p>  // Get the prime numbers upto 1 million
  vector<bool> numbers(kMaxNum);
  vector<int> prime_indices;
  PopulatePrimes(&amp;numbers, &amp;prime_indices);</p>

<p>  sanity_check_primes(numbers, prime_indices);</p>

<p>  cout &lt;&lt; &ldquo;Debug: number of primes  = &rdquo; &lt;&lt; prime_indices.size() &lt;&lt; endl;
  sanity_check_combinator();</p>

<p>  cout &lt;&lt; &ldquo;Debug : &rdquo; &lt;&lt; GetPrimeSum(10000, numbers, prime_indices);
  // TODO(agam): Uncomment and continue &hellip;
  // int left = 0;
  // int right = 500;  /// random round number
  // do {
  //   Cardinality left_c = GetPrimeSum(left, numbers, prime_indices);
  //   Cardinality right_c = GetPrimeSum(right, numbers, prime_indices);
  // } while (left &lt; right);
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 49: Prime Permutations]]></title>
    <link href="http://agam.github.io/blog/2015/05/04/euler-49-prime-permutations/"/>
    <updated>2015-05-04T23:39:11-07:00</updated>
    <id>http://agam.github.io/blog/2015/05/04/euler-49-prime-permutations</id>
    <content type="html"><![CDATA[<p>This one took way longer than expected. I initially misunderstood the question to require 4-digit numbers <em>unique digits</em> (because that&rsquo;s what the example has!) and I went crazy trying to figure out why the <em>only</em> answer I was getting was the example in the question. Anyway I later realized I&rsquo;d over-complicated my solution and I just needed to look at numbers between <code>1000</code> and <code>9999</code>. Given this, it&rsquo;s <em>absurd</em> to have a class called &ldquo;FourDigits&rdquo; (duh), but I figured there&rsquo;s no point hiding my initial mistake :)</p>

<p>The code fragment below is bloated because I&rsquo;ve left in old code from my first attempt (the functions suffixed with <code>...Old</code>), and half the code here is dead code.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em> (well, not really)</p>

<p>```cpp
bool IsPrime(int n) {
  // Rule out even numbers
  if ((n > 2) &amp;&amp; (n % 2 == 0)) return false;</p>

<p>  // Check divisibility by odd numbers starting from 3, uptil the
  // square root of the number.
  const int lim = sqrt(n);
  for (int i = 3; i &lt;= lim; i+=2) {</p>

<pre><code>if (n % i == 0) {
  return false;
}
</code></pre>

<p>  }
  return true;
}</p>

<p>bool HasArithmeticSequence(const vector<int>&amp; v) {
  assert(v.size() >= 3);
  // Assumes sorted vector of ints
  struct diff {</p>

<pre><code>int n1, n2, d;
</code></pre>

<p>  };
  vector<diff> diffs;
  // Get the diffs between all elements, then find two pairs with the
  // same diff (yes, N<sup>2</sup>, but will do). The two pairs must share a
  // number, i.e. V_i + d = V_j, and V_j + d = V_k.
  for (int i = 0; i &lt; v.size() &ndash; 1; ++i) {</p>

<pre><code>for (int j = i+1; j &lt; v.size(); ++j) {
  assert(v[j] &gt; v[i]);
  diffs.push_back( { v[i], v[j], v[j] - v[i] } );
}
</code></pre>

<p>  }
  std::sort(diffs.begin(), diffs.end(),</p>

<pre><code>        [](const diff&amp; df1, const diff&amp; df2) {
          return df1.d &lt; df2.d;
        });
</code></pre>

<p>  // Now that we have grouped elements by their difference, we can
  // analyze each &lsquo;cluster&rsquo; to find the pairs we want.
  for (int i = 0; i &lt; diffs.size() &ndash; 1; ++i) {</p>

<pre><code>// Yes, it's inefficient, but ...
int d = diffs[i].d;
for (int j = i + 1; diffs[j].d == d; ++j) {
  if (diffs[i].n2 == diffs[j].n1) {
    cout &lt;&lt; "Found arithmetic progression: "
         &lt;&lt; diffs[i].n1 &lt;&lt; " -&gt; "
         &lt;&lt; diffs[i].n2 &lt;&lt; " -&gt; "
         &lt;&lt; diffs[j].n2 &lt;&lt; endl;
    return true;
  }
}
</code></pre>

<p>  }
  return false;
}</p>

<p>class FourDigitCombinator {
public:
  FourDigitCombinator() : digits<em>({0,1,2,3}), number</em>(1000) {}</p>

<p>  string GetDigitsOld() {</p>

<pre><code>std::ostringstream stream;
for (int i = 0; i &lt; kNumDigits; ++i) {
  stream &lt;&lt; digits_[i];
}
return stream.str();
</code></pre>

<p>  }</p>

<p>  bool NextOld() {</p>

<pre><code>sanity_check();
// See if there is a prior number that can be incremented
for (int i = kNumDigits - 1; i &gt;= 0; --i) {
  // The last digit can go up to kMaxDigit, the previous one up to
  // kMaxDigit - 1, and so on ...
  const int digitMax = kMaxDigit - kNumDigits + i + 1;
  int digitValue = digits_[i];
  assert(digitValue &lt;= digitMax);
  if (digitValue == digitMax) {
    // We've hit the limit for this digit. If this is the first
    // digit, we've reached the end.
    if (i == 0) {
      return false;
    }
    // Otherwise, fall through to the previous digit ...
  } else {
    // Increment, and reset subsequent digits, if any.
    for (int j = i; j &lt; kNumDigits; ++j) {
      ++digitValue;
      digits_[j] = digitValue;
    }
    return true;
  }
}
assert(false);  // We should not get here!
</code></pre>

<p>  }</p>

<p>  bool HasPrimePermutationsOld() {</p>

<pre><code>array&lt;int, kNumDigits&gt; mutation = digits_;
vector&lt;int&gt; prime_mutations;
do {
  // Skip permutations with a leading zero.
  if (mutation[0] == 0) continue;

  // Create the corresponding number
  int number = 0;
  for (int i = 0; i &lt; kNumDigits; ++i) {
    number = number * 10 + mutation[i];
  }
  if (IsPrime(number)) {
    prime_mutations.push_back(number);
  }
} while (std::next_permutation(mutation.begin(), mutation.end()));

if ((prime_mutations.size() &gt;= 3) &amp;&amp; HasArithmeticSequence(prime_mutations)) {
  return true;
}
return false;
</code></pre>

<p>  }</p>

<p>  string GetDigits() {</p>

<pre><code>std::ostringstream stream;
stream &lt;&lt; number_;
return stream.str();
</code></pre>

<p>  }</p>

<p>  bool Next() {</p>

<pre><code>if (number_ &lt; 9999) {
  ++number_;
  return true;
}
return false;
</code></pre>

<p>  }</p>

<p>  bool HasPrimePermutations() {</p>

<pre><code>array&lt;int, kNumDigits&gt; mutation;
assert(number_ &gt;= 1000 &amp;&amp; number_ &lt;= 9999);

// Convert number into an array of digits ...
int n = number_;
int digit_index = kNumDigits - 1;
while (n &gt; 0) {
  mutation[digit_index--] = n % 10;
  n /= 10;
}

vector&lt;int&gt; prime_mutations;
do {
  // ... then convert the array of digits back into a number!
  int num = 0;
  for (int i = 0; i &lt; kNumDigits; ++i) {
    num = num * 10 + mutation[i];
  }
  assert(num &gt;= 1000 &amp;&amp; num &lt;= 9999);
  if (IsPrime(num)) {
    prime_mutations.push_back(num);
  }
} while (std::next_permutation(mutation.begin(), mutation.end()));

if ((prime_mutations.size() &gt;= 3) &amp;&amp; HasArithmeticSequence(prime_mutations)) {
  return true;
}
return false;
</code></pre>

<p>  }</p>

<p>private:
  static const int kNumDigits = 4;
  static const int kMaxDigit = 9;
  array&lt;int, kNumDigits> digits<em>;
  int number</em>;</p>

<p>  void sanity_check() {</p>

<pre><code>for (int i = 0; i &lt; kNumDigits - 1; ++i) {
  assert(digits_[i] &lt; digits_[i+1]);
}
</code></pre>

<p>  }
};</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #49 &hellip; \n&rdquo;;</p>

<p>  set<string> candidates;</p>

<p>  // Go over all sets of four digits, and consider the permutations of
  // each to see if any group of three permutations is prime.
  FourDigitCombinator four_digits;
  do {</p>

<pre><code>if (four_digits.HasPrimePermutations()) {
  candidates.insert(four_digits.GetDigits());
}
</code></pre>

<p>  } while (four_digits.Next());</p>

<p>  // Debugging aid &hellip; check if any combinations matched.
  for (const auto&amp; c : candidates) {</p>

<pre><code>cout &lt;&lt; "Debug: found : " &lt;&lt; c &lt;&lt; endl;
</code></pre>

<p>  }
}
```</p>

<p>And it runs as &hellip;</p>

<p>```sh
$ time ./Test
Euler #49 &hellip;
Found arithmetic progression: 1487 &ndash;> 4817 &ndash;> 8147
Found arithmetic progression: 1487 &ndash;> 4817 &ndash;> 8147
Found arithmetic progression: 2969 &ndash;> 6299 &ndash;> 9629
Found arithmetic progression: 2969 &ndash;> 6299 &ndash;> 9629
Debug: found : 1478
Debug: found : 1487
Debug: found : 2699
Debug: found : 2969</p>

<p>real    0m0.019s
user    0m0.016s
sys     0m0.000s
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 48: Self powers]]></title>
    <link href="http://agam.github.io/blog/2015/05/03/euler-48-self-powers/"/>
    <updated>2015-05-03T20:09:53-07:00</updated>
    <id>http://agam.github.io/blog/2015/05/03/euler-48-self-powers</id>
    <content type="html"><![CDATA[<p>One of the simplest problems, that would be a one-liner in Python or Lisp. Decided to do it in C++ anyway, using the <code>GMP</code> library (verbose, but runs in <code>4 ms</code>)</p>

<p>For this to work, you&rsquo;ll need to add (e.g. for <code>CMake</code>) a line like <code>target_link_libraries(Test gmpxx gmp)</code>, and include <code>gmpxx.h</code>.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```cpp
int main() {
  cout &lt;&lt; &ldquo;Euler #48 &hellip; \n&rdquo;;
  const int kNumTerms = 1000;</p>

<p>  // GMP has a C++ interface, see the following link:
  // <a href="https://gmplib.org/manual/C_002b_002b-Interface-General.html">https://gmplib.org/manual/C_002b_002b-Interface-General.html</a>
  mpz_class sum = 0;</p>

<p>  // Loop from 1 to 1000
  for (int i = 1; i &lt;= kNumTerms; ++i) {</p>

<pre><code>mpz_class term = 0;

// GMP exponentiation function, see documentation at:
// https://gmplib.org/manual/Integer-Exponentiation.html
mpz_ui_pow_ui(term.get_mpz_t(), i, i);

sum = sum + term;
</code></pre>

<p>  }</p>

<p>  mpz_class last_ten_digits;</p>

<p>  // We&rsquo;re looking for sum modulo (10 ^ 10)
  mpz_class divisor;
  mpz_ui_pow_ui(divisor.get_mpz_t(), 10, 10);
  mpz_mod(last_ten_digits.get_mpz_t(), sum.get_mpz_t(), divisor.get_mpz_t());
  cout &lt;&lt; &ldquo;The final answer is : &rdquo; &lt;&lt; last_ten_digits &lt;&lt; endl;
}
```</p>
]]></content>
  </entry>
  
</feed>
