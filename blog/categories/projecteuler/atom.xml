<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projecteuler | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/projecteuler/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-03-05T06:12:37+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 36: Palindromic Numbers]]></title>
    <link href="http://agam.github.io/blog/2015/03/05/euler-36-palindromic-numbers/"/>
    <updated>2015-03-05T06:10:59+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/05/euler-36-palindromic-numbers</id>
    <content type="html"><![CDATA[<p>Wha &hellip; this is getting boring.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
using std::vector;
static const int kMaxNumbers = 1000000;</p>

<p>bool isPalindromic(int n, int base) {
  vector<int> digits;
  while (n > 0) {</p>

<pre><code>digits.push_back(n % base);
n /= base;
</code></pre>

<p>  }
  int length = digits.size();
  for (int i = 0; i &lt; length/2; ++i) {</p>

<pre><code>if (digits[i] != digits[length-1-i]) {
  return false;
}
</code></pre>

<p>  }
  return true;
}</p>

<p>int main() {
  int sum = 0;
  for (int i = 1; i &lt; kMaxNumbers; ++i) {</p>

<pre><code>if (isPalindromic(i, 10) &amp;&amp; isPalindromic(i, 2)) {
  sum += i;
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;Sum of palindromic numbers = &rdquo; &lt;&lt; sum &lt;&lt; std::endl;
}
```</p>

<p>(runs in <code>931 milliseconds</code>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 35: Circular Primes]]></title>
    <link href="http://agam.github.io/blog/2015/03/04/euler-35-circular-primes/"/>
    <updated>2015-03-04T23:49:53+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/04/euler-35-circular-primes</id>
    <content type="html"><![CDATA[<p>The easy solutions continue (or, I&rsquo;ve just gotten used to C++ for these)</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
// Euler 35: A number is a circular prime if all the <em>rotations</em> of
// its digits are prime numbers.</p>

<p>using std::vector;</p>

<p>const int kMaxNumbers = 1000000;
typedef std::bitset<kMaxNumbers> AllNumbers;</p>

<p>void markMultiples(AllNumbers* v, int n) {
  const int kStart = 2 * n;
  if (kStart >= kMaxNumbers) {</p>

<pre><code>return;
</code></pre>

<p>  }
  for (int i = kStart; i &lt; kMaxNumbers; i += n) {</p>

<pre><code>v-&gt;set(i, false);
</code></pre>

<p>  }
}</p>

<p>void markPrimes(AllNumbers* v) {
  v->set(0, false);
  v->set(1, false);
  int i = 2;
  while (true) {</p>

<pre><code>markMultiples(v, i);
++i;
for (; i &lt; kMaxNumbers &amp;&amp; !v-&gt;test(i); ++i) {}
if (i == kMaxNumbers) {
  return;
}
</code></pre>

<p>  }
}</p>

<p>vector<int> getDigits(int n) {
  vector<int> v;
  while (n > 0) {</p>

<pre><code>v.push_back(n % 10);
n /= 10;
</code></pre>

<p>  }
  return v;
}</p>

<p>int getNumber(const vector<int>&amp; v) {
  int n = 0;
  for (int i = v.size()-1; i >=0; &mdash;i) {</p>

<pre><code>n = n*10 + v[i];
</code></pre>

<p>  }
  return n;
}</p>

<p>vector<int> getRotatedNumbers(int n) {
  auto v = getDigits(n);
  vector<int> numbers;
  for (int i = 0; i &lt; v.size(); ++i) {</p>

<pre><code>numbers.push_back(getNumber(v));
std::rotate(v.begin(), v.end()-1, v.end());
</code></pre>

<p>  }
  return numbers;
}</p>

<p>int main() {
  AllNumbers v;
  for (int i = 0; i &lt; kMaxNumbers; ++i) {</p>

<pre><code>v.set(i, true);
</code></pre>

<p>  }
  markPrimes(&amp;v);
  int numCircularPrimes = 0;
  for (int i = 0; i &lt; kMaxNumbers; ++i) {</p>

<pre><code>// Fail early
if (!v.test(i)) {
  continue;
}
vector&lt;int&gt; ps = getRotatedNumbers(i);
if (std::all_of(ps.begin(), ps.end(), [&amp;v](int p){return v.test(p);})) {
  ++numCircularPrimes;
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;Number of circular primes = &rdquo; &lt;&lt; numCircularPrimes &lt;&lt; std::endl;
}
```</p>

<p>It runs in <code>335 milliseconds</code> &mdash; though I&rsquo;m not sure if it is a high or a low number.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 34: Curious Numbers]]></title>
    <link href="http://agam.github.io/blog/2015/03/04/euler-34-curious-numbers/"/>
    <updated>2015-03-04T21:33:28+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/04/euler-34-curious-numbers</id>
    <content type="html"><![CDATA[<p><em>Grumble</em> &hellip; I&rsquo;m missing the tougher problems we saw earlier. This is another easy one.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
using std::vector;</p>

<p>vector<int> getDigits(int number) {
  vector<int> v;
  while (number > 0) {</p>

<pre><code>v.push_back(number % 10);
number /= 10;
</code></pre>

<p>  }
  return v;
}</p>

<p>void printVector(const vector<int>&amp; v) {
  std::cout &lt;&lt; &ldquo;[ &rdquo;;
  for (const auto&amp; d : v) {</p>

<pre><code>std::cout &lt;&lt; d &lt;&lt; ", ";
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo; ]\n&rdquo;;
}</p>

<p>int factorial(int n) {
  // Yep, crude, but it works.
  static std::unordered_map&lt;int,int> memos;
  const auto&amp; it = memos.find(n);
  if (it != memos.end()) {</p>

<pre><code>return it-&gt;second;
</code></pre>

<p>  }
  int fact = 1;
  for (int i = 1; i &lt;= n; ++i) {</p>

<pre><code>fact *= i;
</code></pre>

<p>  }
  memos[n] = fact;
  return fact;
}</p>

<p>int sumFactDigits(const vector<int>&amp; v) {
  int sum = 0;
  for (const auto&amp; d : v) {</p>

<pre><code>sum += factorial(d);
</code></pre>

<p>  }
  return sum;
}</p>

<p>int main() {
  static const int kMaxTries = 1000000;
  long sum = 0;
  for (int i = 3; i &lt; kMaxTries; ++i) {</p>

<pre><code>vector&lt;int&gt; d = getDigits(i);
if (i == sumFactDigits(d)) {
  sum += i;
  std::cout &lt;&lt; "Debug: found ";
  std::reverse(d.begin(), d.end());
  printVector(d);
}
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;Required sum = &rdquo; &lt;&lt; sum &lt;&lt; std::endl;
}
```</p>

<p>&hellip; and it runs as</p>

<p><code>sh
Debug: found [ 1, 4, 5,  ]
Debug: found [ 4, 0, 5, 8, 5,  ]
Required sum = &lt;redacted&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 33: Curious Fractions]]></title>
    <link href="http://agam.github.io/blog/2015/03/04/euler-33-curious-fractions/"/>
    <updated>2015-03-04T18:52:31+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/04/euler-33-curious-fractions</id>
    <content type="html"><![CDATA[<p>Hmm .. this is almost too straightforward to post, but here goes &hellip;</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
using std::pair;</p>

<p>pair&lt;int,int> getDigits(int num) {
  return std::make_pair(num / 10, num % 10);
}</p>

<p>int gcd(int a, int b) {
  assert(b &lt;= a);
  if (b == 0) {</p>

<pre><code>return a;
</code></pre>

<p>  } else {</p>

<pre><code>return gcd(b, a % b);
</code></pre>

<p>  }
}</p>

<p>pair&lt;int,int> getReducedForm(int num, int den) {
  int g = gcd(den, num);
  return std::make_pair(num / g, den / g);
}</p>

<p>bool isCuriousFraction(int num, int den) {
  // If (1) the numbers share digits, and (2) they can be reduced,
  // then they form a &lsquo;curious fraction&rsquo;
  auto reducedForm = getReducedForm(num, den);</p>

<p>  auto n = getDigits(num);
  auto d = getDigits(den);</p>

<p>  if ((n.second == 0 &amp;&amp; d.second == 0) || n.first > d.second) {</p>

<pre><code>return false;
</code></pre>

<p>  }</p>

<p>  auto curiousForm = getReducedForm(n.first, d.second);</p>

<p>  if (n.second == d.first &amp;&amp; curiousForm == reducedForm) {</p>

<pre><code>return true;
</code></pre>

<p>  } else {</p>

<pre><code>return false;
</code></pre>

<p>  }
}</p>

<p>int main() {
  int numProduct = 1, denProduct = 1;
  // Go through all pairs of two-digit numbers, where one is smaller than the other.
  for (int den = 10; den &lt; 100; ++den) {</p>

<pre><code>for (int num = 10; num &lt; den; ++num) {
  if (isCuriousFraction(num, den)) {
std::cout &lt;&lt; "Debug: found " &lt;&lt; num &lt;&lt; " / " &lt;&lt; den &lt;&lt; std::endl;
numProduct *= num;
denProduct *= den;
  }
}
</code></pre>

<p>  }
  // For lowest common terms, divide both by GCD
  std::cout &lt;&lt; &ldquo;Denominator of product = &rdquo;</p>

<pre><code>        &lt;&lt; denProduct / gcd(denProduct, numProduct) &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>&hellip; and runs as follows</p>

<p><code>sh
Debug: found 16 / 64
Debug: found 26 / 65
Debug: found 19 / 95
Debug: found 49 / 98
Denominator of product = &lt;redacted&gt;
</code></p>

<p>(<em>Sigh</em> &hellip; yes, its <em>longer</em> than some of the previous solutions, but it really didn&rsquo;t take me long to write it &hellip; I think I&rsquo;m developing a renewed appreciation for C++)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 32: Sum of Pan-digital products]]></title>
    <link href="http://agam.github.io/blog/2015/03/04/euler-32-sum-of-pan-digital-products/"/>
    <updated>2015-03-04T07:10:28+00:00</updated>
    <id>http://agam.github.io/blog/2015/03/04/euler-32-sum-of-pan-digital-products</id>
    <content type="html"><![CDATA[<p>Pretty dumb naive solution.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
using std::vector;
static const int kNumDigits = 9;</p>

<p>int getNumber(const vector<int>&amp; vNum) {
  int result = 0;
  for (int i = 0; i &lt; vNum.size(); ++i) {</p>

<pre><code>result = result * 10 + vNum[i];
</code></pre>

<p>  }
  return result;
}</p>

<p>bool isProduct(const vector<int>&amp; vMultA,</p>

<pre><code>           const vector&lt;int&gt;&amp; vMultB,
           const vector&lt;int&gt;&amp; vProduct) {
</code></pre>

<p>  int multa = getNumber(vMultA);
  int multb = getNumber(vMultB);
  int product = getNumber(vProduct);
  bool result = (multa * multb == product);
  if (result) {</p>

<pre><code>std::cout &lt;&lt; "Debug: Testing " &lt;&lt; multa &lt;&lt; " * " &lt;&lt; multb &lt;&lt; " = " &lt;&lt; product
          &lt;&lt; "  --- MATCH!\n";
</code></pre>

<p>  }
  return result;
}</p>

<p>// Try all possible splits from this combination
void tryPermutation(const vector<int>&amp; p,</p>

<pre><code>                int* total_matches,
                std::unordered_set&lt;int&gt;* products) {
</code></pre>

<p>  assert(p.size() == kNumDigits);
  // There are nine digits, indexed from 0 to 8
  // First number spans 0 to i, the second i + 1 to j, third is from j + 1 to 8
  for (int i = 0; i &lt;= kNumDigits &ndash; 3; ++i) {</p>

<pre><code>for (int j = i+1; j &lt;= kNumDigits - 2; ++j) {
  vector&lt;int&gt; n1, n2, n3;
  for (int k = 0; k &lt;= i; ++k) {
    n1.push_back(p[k]);
  }
  for (int k = i+1; k &lt;= j; ++k) {
    n2.push_back(p[k]);
  }
  for (int k = j+1; k &lt;= kNumDigits-1; ++k) {
    n3.push_back(p[k]);
  }
  if (isProduct(n1,n2,n3)) {
    ++(*total_matches);
    products-&gt;insert(getNumber(n3));
  }
}
</code></pre>

<p>  }
}</p>

<p>int main() {
  vector<int> digits;
  for (int i = 1; i &lt;= kNumDigits; ++i) {</p>

<pre><code>digits.push_back(i);
</code></pre>

<p>  }
  int total_matches = 0;
  std::unordered_set<int> products;
  do {</p>

<pre><code>tryPermutation(digits, &amp;total_matches, &amp;products);
</code></pre>

<p>  } while (std::next_permutation(digits.begin(), digits.end()));
  int products_sum = 0;
  for (const auto&amp; p : products) {</p>

<pre><code>products_sum += p;
</code></pre>

<p>  }
  std::cout &lt;&lt; &ldquo;Number of matches = &rdquo; &lt;&lt; total_matches &lt;&lt; &ldquo;, &rdquo;</p>

<pre><code>        &lt;&lt; "Sum of products = " &lt;&lt; products_sum &lt;&lt; std::endl;
</code></pre>

<p>}</p>

<p>```</p>

<p>Runs as follows:</p>

<p><code>sh
~/cpp $ time ./Test
Debug: Testing 12 * 483 = 5796  --- MATCH!
Debug: Testing 138 * 42 = 5796  --- MATCH!
Debug: Testing 157 * 28 = 4396  --- MATCH!
Debug: Testing 159 * 48 = 7632  --- MATCH!
Debug: Testing 1738 * 4 = 6952  --- MATCH!
Debug: Testing 18 * 297 = 5346  --- MATCH!
Debug: Testing 186 * 39 = 7254  --- MATCH!
Debug: Testing 1963 * 4 = 7852  --- MATCH!
Debug: Testing 198 * 27 = 5346  --- MATCH!
Debug: Testing 27 * 198 = 5346  --- MATCH!
Debug: Testing 28 * 157 = 4396  --- MATCH!
Debug: Testing 297 * 18 = 5346  --- MATCH!
Debug: Testing 39 * 186 = 7254  --- MATCH!
Debug: Testing 4 * 1738 = 6952  --- MATCH!
Debug: Testing 4 * 1963 = 7852  --- MATCH!
Debug: Testing 42 * 138 = 5796  --- MATCH!
Debug: Testing 48 * 159 = 7632  --- MATCH!
Debug: Testing 483 * 12 = 5796  --- MATCH!
Number of matches = 18, Sum of products = 45228
15.517 secs
</code></p>

<p>(Wait, why C++ instead of &hellip; other recent languages? Couple of reasons: (1) I thought I&rsquo;d need to brute force this (though it eventually turned out to take much less time than I anticipated), and (2) I&rsquo;m sort of <em>over</em> the <em>over-experimentation</em> with languages that I&rsquo;m not <em>really</em> going to use, and I&rsquo;m not going to get much out of anyway. Yes, tough. Deal with it)</p>
]]></content>
  </entry>
  
</feed>
