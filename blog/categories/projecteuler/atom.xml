<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projecteuler | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/projecteuler/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-05-17T07:27:33+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 50: A non-working solution]]></title>
    <link href="http://agam.github.io/blog/2015/05/17/euler-50-a-non-working-solution/"/>
    <updated>2015-05-17T02:56:08+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/17/euler-50-a-non-working-solution</id>
    <content type="html"><![CDATA[<p>It&rsquo;s worth pointing out things that don&rsquo;t work, roads that lead to dead ends, etc &mdash; so here is a brute force solution that has absolutely no chance of ever working. It&rsquo;s long and verbose because it&rsquo;s a <em>franken-solution</em>, made out of parts of previous solution concatenated together into a terrible mess. Posting it here before I destroy it. The forlorn <code>TODO</code> at the end proved over-optimistic &hellip;</p>

<p>```c++
static const int kMaxNum = 1000000;</p>

<p>void PopulatePrimes(vector<bool><em> numbers, vector<int></em> prime_indices) {
  // Start off with all numbers marked prime.
  for (int i = 2; i &lt; numbers->size(); ++i) {</p>

<pre><code>numbers-&gt;at(i) = true;
</code></pre>

<p>  }</p>

<p>  int prime_index = 2;
  while (true) {</p>

<pre><code>// Store the prime index for future reference
prime_indices-&gt;push_back(prime_index);

if (numbers-&gt;size() &lt; 2 * prime_index) {
  break;
}

// Mark the multiples as not prime
for (int i = prime_index * 2; i &lt; numbers-&gt;size(); i += prime_index) {
  numbers-&gt;at(i) = false;
}

// Repeat with the next prime number
do {
  ++prime_index;
} while (prime_index &lt; numbers-&gt;size() &amp;&amp; !numbers-&gt;at(prime_index));

if (prime_index == numbers-&gt;size()) {
  break;
}
</code></pre>

<p>  }
}</p>

<p>void sanity_check_primes(const vector<bool>&amp; numbers,</p>

<pre><code>                     const vector&lt;int&gt;&amp; prime_indices) {
</code></pre>

<p>  auto check_prime = <a href="int%20n,%20bool%20is_prime">&amp;numbers, &amp;prime_indices</a> {</p>

<pre><code>if (is_prime) {
  assert(numbers[n] == true);
  assert(std::find(prime_indices.begin(), prime_indices.end(), n) !=
         prime_indices.end());
} else {
  assert(numbers[n] == false);
  assert(std::find(prime_indices.begin(), prime_indices.end(), n) ==
         prime_indices.end());
}
</code></pre>

<p>  };</p>

<p>  check_prime(2, true);
  check_prime(3, true);
  check_prime(5, true);
  check_prime(4, false);
  check_prime(6, false);
}</p>

<p>class CombinationIterator {
public:
  CombinationIterator(int n, int m) : n<em>(n), m</em>(m) {</p>

<pre><code>comb_.reserve(m);
for (int i = 0; i &lt; m; ++i) {
  comb_.push_back(i);
}
</code></pre>

<p>  }</p>

<p>  const vector<int>&amp; GetCombination() const {</p>

<pre><code>return comb_;
</code></pre>

<p>  }</p>

<p>  bool Next() {</p>

<pre><code>// The last digit can go up to n, the next-to-last up to n-1, and
// so on. The very first sequence is {0, 1, ..., m-1}, and the
// very last is {n-m+1, ..., n-1, n}.
for (int i = m_ - 1; i &gt;= 0; --i) {
  int max = n_ + i - m_ + 1;
  int val = comb_[i];
  // cout &lt;&lt; "Debug: i = " &lt;&lt; i &lt;&lt; ", val = " &lt;&lt; val &lt;&lt; ", max = " &lt;&lt; max &lt;&lt; endl;
  if (val &lt; max) {
    // Increment this position, and update subsequent indices if
    // necessary.
    for (int j = i; j &lt; m_; ++j) {
      comb_[j] = ++val;
    }
    return true;
  }

  // If we're at the beginning, we're done.
  if (i == 0) {
    return false;
  }

  // Otherwise, fallthrough to the previous index.
}
assert(false);  // Should not reach here!
</code></pre>

<p>  }
private:
  const int n<em>, m</em>;
  vector<int> comb_;
};</p>

<p>void sanity_check_combinator() {
  CombinationIterator cit(9, 4);
  for (int i = 0; i &lt; 20; ++i) {</p>

<pre><code>const auto&amp; v = cit.GetCombination();
cout &lt;&lt; "Debug (" &lt;&lt; v.size() &lt;&lt; ") : ";
for (int n : v) {
  cout &lt;&lt; n &lt;&lt; "  ";
}
cout &lt;&lt; endl;
assert(cit.Next());
</code></pre>

<p>  }
}</p>

<p>enum class Cardinality {
  Zero, One, More
};</p>

<p>Cardinality GetPrimeSum(int num_summands,</p>

<pre><code>                    const vector&lt;bool&gt;&amp; numbers,
                    const vector&lt;int&gt;&amp; prime_indices) {
</code></pre>

<p>  // Try all possible combinations of adding prime numbers
  // together. Either exhaust all combinations, in which case return
  // Zero or One. The moment two are found, return More.</p>

<p>  int num_primes = 0;
  CombinationIterator cit(numbers.size(), num_summands);
  do {</p>

<pre><code>const auto&amp; pv = cit.GetCombination();
int sum = 0;
for (int p : pv) {
  sum += p;
}

// Check if the primes add up to a prime
if (sum &lt; numbers.size() &amp;&amp; numbers[sum]) {
  ++num_primes;
}
if (num_primes == 2) {
  return Cardinality::More;
}
</code></pre>

<p>  } while (cit.Next());
  assert(num_primes == 0 || num_primes == 1);
  if (num_primes == 1) {</p>

<pre><code>return Cardinality::One;
</code></pre>

<p>  } else {</p>

<pre><code>return Cardinality::Zero;
</code></pre>

<p>  }
}</p>

<p>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const Cardinality&amp; c) {
  os &lt;&lt; static_cast&lt;std::underlying_type<Cardinality>::type>&copy;;
  return os;
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #50 &hellip; \n&rdquo;;</p>

<p>  // Get the prime numbers upto 1 million
  vector<bool> numbers(kMaxNum);
  vector<int> prime_indices;
  PopulatePrimes(&amp;numbers, &amp;prime_indices);</p>

<p>  sanity_check_primes(numbers, prime_indices);</p>

<p>  cout &lt;&lt; &ldquo;Debug: number of primes  = &rdquo; &lt;&lt; prime_indices.size() &lt;&lt; endl;
  sanity_check_combinator();</p>

<p>  cout &lt;&lt; &ldquo;Debug : &rdquo; &lt;&lt; GetPrimeSum(10000, numbers, prime_indices);
  // TODO(agam): Uncomment and continue &hellip;
  // int left = 0;
  // int right = 500;  /// random round number
  // do {
  //   Cardinality left_c = GetPrimeSum(left, numbers, prime_indices);
  //   Cardinality right_c = GetPrimeSum(right, numbers, prime_indices);
  // } while (left &lt; right);
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 49: Prime Permutations]]></title>
    <link href="http://agam.github.io/blog/2015/05/05/euler-49-prime-permutations/"/>
    <updated>2015-05-05T06:39:11+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/05/euler-49-prime-permutations</id>
    <content type="html"><![CDATA[<p>This one took way longer than expected. I initially misunderstood the question to require 4-digit numbers <em>unique digits</em> (because that&rsquo;s what the example has!) and I went crazy trying to figure out why the <em>only</em> answer I was getting was the example in the question. Anyway I later realized I&rsquo;d over-complicated my solution and I just needed to look at numbers between <code>1000</code> and <code>9999</code>. Given this, it&rsquo;s <em>absurd</em> to have a class called &ldquo;FourDigits&rdquo; (duh), but I figured there&rsquo;s no point hiding my initial mistake :)</p>

<p>The code fragment below is bloated because I&rsquo;ve left in old code from my first attempt (the functions suffixed with <code>...Old</code>), and half the code here is dead code.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em> (well, not really)</p>

<p>```cpp
bool IsPrime(int n) {
  // Rule out even numbers
  if ((n > 2) &amp;&amp; (n % 2 == 0)) return false;</p>

<p>  // Check divisibility by odd numbers starting from 3, uptil the
  // square root of the number.
  const int lim = sqrt(n);
  for (int i = 3; i &lt;= lim; i+=2) {</p>

<pre><code>if (n % i == 0) {
  return false;
}
</code></pre>

<p>  }
  return true;
}</p>

<p>bool HasArithmeticSequence(const vector<int>&amp; v) {
  assert(v.size() >= 3);
  // Assumes sorted vector of ints
  struct diff {</p>

<pre><code>int n1, n2, d;
</code></pre>

<p>  };
  vector<diff> diffs;
  // Get the diffs between all elements, then find two pairs with the
  // same diff (yes, N<sup>2</sup>, but will do). The two pairs must share a
  // number, i.e. V_i + d = V_j, and V_j + d = V_k.
  for (int i = 0; i &lt; v.size() &ndash; 1; ++i) {</p>

<pre><code>for (int j = i+1; j &lt; v.size(); ++j) {
  assert(v[j] &gt; v[i]);
  diffs.push_back( { v[i], v[j], v[j] - v[i] } );
}
</code></pre>

<p>  }
  std::sort(diffs.begin(), diffs.end(),</p>

<pre><code>        [](const diff&amp; df1, const diff&amp; df2) {
          return df1.d &lt; df2.d;
        });
</code></pre>

<p>  // Now that we have grouped elements by their difference, we can
  // analyze each &lsquo;cluster&rsquo; to find the pairs we want.
  for (int i = 0; i &lt; diffs.size() &ndash; 1; ++i) {</p>

<pre><code>// Yes, it's inefficient, but ...
int d = diffs[i].d;
for (int j = i + 1; diffs[j].d == d; ++j) {
  if (diffs[i].n2 == diffs[j].n1) {
    cout &lt;&lt; "Found arithmetic progression: "
         &lt;&lt; diffs[i].n1 &lt;&lt; " -&gt; "
         &lt;&lt; diffs[i].n2 &lt;&lt; " -&gt; "
         &lt;&lt; diffs[j].n2 &lt;&lt; endl;
    return true;
  }
}
</code></pre>

<p>  }
  return false;
}</p>

<p>class FourDigitCombinator {
public:
  FourDigitCombinator() : digits<em>({0,1,2,3}), number</em>(1000) {}</p>

<p>  string GetDigitsOld() {</p>

<pre><code>std::ostringstream stream;
for (int i = 0; i &lt; kNumDigits; ++i) {
  stream &lt;&lt; digits_[i];
}
return stream.str();
</code></pre>

<p>  }</p>

<p>  bool NextOld() {</p>

<pre><code>sanity_check();
// See if there is a prior number that can be incremented
for (int i = kNumDigits - 1; i &gt;= 0; --i) {
  // The last digit can go up to kMaxDigit, the previous one up to
  // kMaxDigit - 1, and so on ...
  const int digitMax = kMaxDigit - kNumDigits + i + 1;
  int digitValue = digits_[i];
  assert(digitValue &lt;= digitMax);
  if (digitValue == digitMax) {
    // We've hit the limit for this digit. If this is the first
    // digit, we've reached the end.
    if (i == 0) {
      return false;
    }
    // Otherwise, fall through to the previous digit ...
  } else {
    // Increment, and reset subsequent digits, if any.
    for (int j = i; j &lt; kNumDigits; ++j) {
      ++digitValue;
      digits_[j] = digitValue;
    }
    return true;
  }
}
assert(false);  // We should not get here!
</code></pre>

<p>  }</p>

<p>  bool HasPrimePermutationsOld() {</p>

<pre><code>array&lt;int, kNumDigits&gt; mutation = digits_;
vector&lt;int&gt; prime_mutations;
do {
  // Skip permutations with a leading zero.
  if (mutation[0] == 0) continue;

  // Create the corresponding number
  int number = 0;
  for (int i = 0; i &lt; kNumDigits; ++i) {
    number = number * 10 + mutation[i];
  }
  if (IsPrime(number)) {
    prime_mutations.push_back(number);
  }
} while (std::next_permutation(mutation.begin(), mutation.end()));

if ((prime_mutations.size() &gt;= 3) &amp;&amp; HasArithmeticSequence(prime_mutations)) {
  return true;
}
return false;
</code></pre>

<p>  }</p>

<p>  string GetDigits() {</p>

<pre><code>std::ostringstream stream;
stream &lt;&lt; number_;
return stream.str();
</code></pre>

<p>  }</p>

<p>  bool Next() {</p>

<pre><code>if (number_ &lt; 9999) {
  ++number_;
  return true;
}
return false;
</code></pre>

<p>  }</p>

<p>  bool HasPrimePermutations() {</p>

<pre><code>array&lt;int, kNumDigits&gt; mutation;
assert(number_ &gt;= 1000 &amp;&amp; number_ &lt;= 9999);

// Convert number into an array of digits ...
int n = number_;
int digit_index = kNumDigits - 1;
while (n &gt; 0) {
  mutation[digit_index--] = n % 10;
  n /= 10;
}

vector&lt;int&gt; prime_mutations;
do {
  // ... then convert the array of digits back into a number!
  int num = 0;
  for (int i = 0; i &lt; kNumDigits; ++i) {
    num = num * 10 + mutation[i];
  }
  assert(num &gt;= 1000 &amp;&amp; num &lt;= 9999);
  if (IsPrime(num)) {
    prime_mutations.push_back(num);
  }
} while (std::next_permutation(mutation.begin(), mutation.end()));

if ((prime_mutations.size() &gt;= 3) &amp;&amp; HasArithmeticSequence(prime_mutations)) {
  return true;
}
return false;
</code></pre>

<p>  }</p>

<p>private:
  static const int kNumDigits = 4;
  static const int kMaxDigit = 9;
  array&lt;int, kNumDigits> digits<em>;
  int number</em>;</p>

<p>  void sanity_check() {</p>

<pre><code>for (int i = 0; i &lt; kNumDigits - 1; ++i) {
  assert(digits_[i] &lt; digits_[i+1]);
}
</code></pre>

<p>  }
};</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #49 &hellip; \n&rdquo;;</p>

<p>  set<string> candidates;</p>

<p>  // Go over all sets of four digits, and consider the permutations of
  // each to see if any group of three permutations is prime.
  FourDigitCombinator four_digits;
  do {</p>

<pre><code>if (four_digits.HasPrimePermutations()) {
  candidates.insert(four_digits.GetDigits());
}
</code></pre>

<p>  } while (four_digits.Next());</p>

<p>  // Debugging aid &hellip; check if any combinations matched.
  for (const auto&amp; c : candidates) {</p>

<pre><code>cout &lt;&lt; "Debug: found : " &lt;&lt; c &lt;&lt; endl;
</code></pre>

<p>  }
}
```</p>

<p>And it runs as &hellip;</p>

<p>```sh
$ time ./Test
Euler #49 &hellip;
Found arithmetic progression: 1487 &ndash;> 4817 &ndash;> 8147
Found arithmetic progression: 1487 &ndash;> 4817 &ndash;> 8147
Found arithmetic progression: 2969 &ndash;> 6299 &ndash;> 9629
Found arithmetic progression: 2969 &ndash;> 6299 &ndash;> 9629
Debug: found : 1478
Debug: found : 1487
Debug: found : 2699
Debug: found : 2969</p>

<p>real    0m0.019s
user    0m0.016s
sys     0m0.000s
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 48: Self powers]]></title>
    <link href="http://agam.github.io/blog/2015/05/04/euler-48-self-powers/"/>
    <updated>2015-05-04T03:09:53+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/04/euler-48-self-powers</id>
    <content type="html"><![CDATA[<p>One of the simplest problems, that would be a one-liner in Python or Lisp. Decided to do it in C++ anyway, using the <code>GMP</code> library (verbose, but runs in <code>4 ms</code>)</p>

<p>For this to work, you&rsquo;ll need to add (e.g. for <code>CMake</code>) a line like <code>target_link_libraries(Test gmpxx gmp)</code>, and include <code>gmpxx.h</code>.</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers Ahead</em></p>

<p>```cpp
int main() {
  cout &lt;&lt; &ldquo;Euler #48 &hellip; \n&rdquo;;
  const int kNumTerms = 1000;</p>

<p>  // GMP has a C++ interface, see the following link:
  // <a href="https://gmplib.org/manual/C_002b_002b-Interface-General.html">https://gmplib.org/manual/C_002b_002b-Interface-General.html</a>
  mpz_class sum = 0;</p>

<p>  // Loop from 1 to 1000
  for (int i = 1; i &lt;= kNumTerms; ++i) {</p>

<pre><code>mpz_class term = 0;

// GMP exponentiation function, see documentation at:
// https://gmplib.org/manual/Integer-Exponentiation.html
mpz_ui_pow_ui(term.get_mpz_t(), i, i);

sum = sum + term;
</code></pre>

<p>  }</p>

<p>  mpz_class last_ten_digits;</p>

<p>  // We&rsquo;re looking for sum modulo (10 ^ 10)
  mpz_class divisor;
  mpz_ui_pow_ui(divisor.get_mpz_t(), 10, 10);
  mpz_mod(last_ten_digits.get_mpz_t(), sum.get_mpz_t(), divisor.get_mpz_t());
  cout &lt;&lt; &ldquo;The final answer is : &rdquo; &lt;&lt; last_ten_digits &lt;&lt; endl;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 47: Distinct Prime Factors]]></title>
    <link href="http://agam.github.io/blog/2015/05/04/euler-47-distinct-prime-factors/"/>
    <updated>2015-05-04T01:00:00+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/04/euler-47-distinct-prime-factors</id>
    <content type="html"><![CDATA[<p>This one turned out to be very similar to the previous one (except for the small detail of iterating from the smallest prime upwards, instead of the other way round).</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```cpp
class PrimeIterator {
public:
  PrimeIterator() : prime_index_(-1) {}</p>

<p>  int getNextPrime() {</p>

<pre><code>assert((prime_index_ + 1) &lt; primes_.size());
return primes_[++prime_index_];
</code></pre>

<p>  }</p>

<p>  bool hasMorePrimes() {</p>

<pre><code>assert(prime_index_ &gt;= -1 &amp;&amp; (prime_index_ + 1) &lt;= primes_.size());
return (prime_index_ + 1) &lt; primes_.size();
</code></pre>

<p>  }</p>

<p>  void fillPrimes(int max) {</p>

<pre><code>while (primes_.back() &lt;= max) {
  addPrime();
}
// Reset to before the first element
prime_index_ = -1;
</code></pre>

<p>  }</p>

<p>private:
  static void addPrime() {</p>

<pre><code>assert(primes_.size() &gt; 0);
int n = primes_.back();
while (true) {
  ++n;
  bool is_prime = true;
  for (const int&amp; p : primes_) {
    if (n % p == 0) {
      is_prime = false;
      break;  // Try next number
    }
  }
  if (is_prime) {
    primes_.push_back(n);
    return;
  }
}
</code></pre>

<p>  }</p>

<p>  static vector<int> primes_;</p>

<p>  int prime_index_;
};</p>

<p>vector<int> PrimeIterator::primes_ = {2};</p>

<p>int getNumPrimeFactors(int n) {
  int numPrimeFactors = 0;
  PrimeIterator pit;
  pit.fillPrimes(n);
  while (n > 1 &amp;&amp; pit.hasMorePrimes()) {</p>

<pre><code>int p = pit.getNextPrime();
if (n % p == 0) {
  while (n % p == 0) {
    n /= p;
  }
  ++numPrimeFactors;
}
</code></pre>

<p>  }
  return numPrimeFactors;
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #47 &hellip; \n&rdquo;;</p>

<p>  int runLength = 0;
  for (int n = 2; ; ++n) {</p>

<pre><code>if (getNumPrimeFactors(n) == 4) {
  ++runLength;
} else {
  runLength = 0;
}
if (runLength == 4) {
  cout &lt;&lt; "Found a sequence of four numbers with four prime "
       &lt;&lt; "factors starting at : " &lt;&lt; n - 3 &lt;&lt; endl;
  return 0;
}
</code></pre>

<p>  }
}
```</p>

<p>Runs as follows:</p>

<p>```sh
$ time ./Test
Euler #47 &hellip;
Found a sequence of four numbers with four prime factors starting at : <redacted></p>

<p>real    0m3.814s
user    0m3.812s
sys     0m0.000s
```</p>

<p>(Yep, a noticeable delay, but anything under 5 seconds is good for me &hellip;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 46: Goldbach's Other Conjecture]]></title>
    <link href="http://agam.github.io/blog/2015/05/03/euler-46-goldbacks-other-conjecture/"/>
    <updated>2015-05-03T23:46:24+00:00</updated>
    <id>http://agam.github.io/blog/2015/05/03/euler-46-goldbacks-other-conjecture</id>
    <content type="html"><![CDATA[<p>May the brute force be with you. Here is another one (sorry for the over-engineered code).</p>

<p><strong>Statutory Warning</strong>: <em>Spoilers ahead</em></p>

<p>```c++
class PrimeIterator {
public:
  PrimeIterator() : prime_index<em>(primes</em>.size() &ndash; 1) {}</p>

<p>  int getNextPrime() {</p>

<pre><code>assert(prime_index_ &gt; 0);
return primes_[--prime_index_];
</code></pre>

<p>  }</p>

<p>  bool hasMorePrimes() {</p>

<pre><code>return prime_index_ &gt; 0;
</code></pre>

<p>  }</p>

<p>  void fillPrimes(int max) {</p>

<pre><code>while (primes_.back() &lt;= max) {
  addPrime();
}
// Reset to the last element
prime_index_ = primes_.size() - 1;
</code></pre>

<p>  }</p>

<p>private:
  static void addPrime() {</p>

<pre><code>assert(primes_.size() &gt; 0);
int n = primes_.back();
while (true) {
  ++n;
  bool is_prime = true;
  for (const int&amp; p : primes_) {
    if (n % p == 0) {
      is_prime = false;
      break;  // Try next number
    }
  }
  if (is_prime) {
    primes_.push_back(n);
    return;
  }
}
</code></pre>

<p>  }</p>

<p>  static vector<int> primes_;</p>

<p>  int prime_index_;
};</p>

<p>vector<int> PrimeIterator::primes_ = {2};</p>

<p>bool goldbachDecompositionExists(int n) {
  assert(n % 2 == 1);
  // n = p + 2<em>m<sup>2</sup>
  // Since 2</em>m<sup>2</sup> is always even, and n is odd, p must be odd too (so p has to be 3 or greater)</p>

<p>  // Use a generator to get more primes on demand.
  PrimeIterator pit;
  pit.fillPrimes(n);
  while (pit.hasMorePrimes()) {</p>

<pre><code>int p = pit.getNextPrime();
if (p == n) {
  // If n is a prime, then n = p + 2*(0*0)
  return true;
}
double sq = (n - p)/2.0;
if (sqrt(sq) == floor(sqrt(sq))) {
  // n = p + 2*sqrt(sq)
  return true;
}
</code></pre>

<p>  }
  return false;
}</p>

<p>int main() {
  cout &lt;&lt; &ldquo;Euler #46 &hellip; \n&rdquo;;</p>

<p>  // Loop over odd composite numbers &hellip;
  for (int i = 9; ; i+= 2) {</p>

<pre><code>if (!goldbachDecompositionExists(i)) {
  cout &lt;&lt; "Failed at " &lt;&lt; i &lt;&lt; endl;
  return -1;
}
</code></pre>

<p>  }
}
```</p>

<p>Runs as follows:</p>

<p>```sh
$ time ./Test
Euler #46 &hellip;
Failed at <redacted></p>

<p>real    0m0.007s
user    0m0.004s
sys     0m0.000s
```</p>
]]></content>
  </entry>
  
</feed>
