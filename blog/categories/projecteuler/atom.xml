<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projecteuler | Agam's Mashed-Up Pome]]></title>
  <link href="http://agam.github.io/blog/categories/projecteuler/atom.xml" rel="self"/>
  <link href="http://agam.github.io/"/>
  <updated>2015-02-18T01:01:58+00:00</updated>
  <id>http://agam.github.io/</id>
  <author>
    <name><![CDATA[Agam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Euler 29: Distinct Powers]]></title>
    <link href="http://agam.github.io/blog/2015/02/18/euler-29-distinct-powers/"/>
    <updated>2015-02-18T00:56:01+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/18/euler-29-distinct-powers</id>
    <content type="html"><![CDATA[<p><strong>Statutory Warning</strong>: <em>Spoilers ahead!</em></p>

<p>Finally, we have a one-liner:</p>

<p><code>haskell
euler29 = length $ L.nub $ [a ^ b | a &lt;- [2 .. 100], b &lt;- [2 .. 100]]
</code></p>

<p>(where <code>L</code> is <code>Data.List</code>)</p>

<p><em>P.S.</em> I did make a dumb error by initiall writing this as two functions, with the second one taking <code>Int</code> instead of <code>Integer</code>, which (I&rsquo;m disappointed to say) resulted in everything silently overflowing to negative numbers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 28: Spiral diagonals]]></title>
    <link href="http://agam.github.io/blog/2015/02/17/euler-28-spiral-diagonals/"/>
    <updated>2015-02-17T19:33:10+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/17/euler-28-spiral-diagonals</id>
    <content type="html"><![CDATA[<p>This problem afforded a chance to be lazy and have fun.</p>

<p>There definitely is a pattern in the diagonals here: for a <code>3 x 3</code> matrix, the elements are 3, 5, 7, 9. For a <code>5 x 5</code> matrix, the additional elements are 13, 17, 21, 25.</p>

<p>You can see these as being (1 + 2), (1 + 4), (1 + 6), (1 + 8), and then (1 + 2 + 2 + 8), (1 + 4 + 4 + 8), (1 + 6 + 6 + 8), (1 + 8 + 8 + 8).</p>

<p>Similarly, for a <code>7 x 7</code> matrix, the numbers are 31, 37, 43, 49, which are (1 + 2 + 2 + 2 + 8 + 8 + 8), (1 + 4 + 4 + 4 + 8 + 8 + 8), (1 + 6 + 6 + 6 + 8 + 8 + 8), (1 + 8 + 8 + 8 + 8 + 8 + 8)</p>

<p>On the other hand, the problem mentions a <code>1001 x 1001</code> matrix, which is <em>tiny</em>, so why bother with these patterns? Just create the matrix and sum up the diagonals directly! (It&rsquo;s <em>just</em> a million elements &hellip; now if it was a few orders of magnitude higher, it would be a different story)</p>

<p><strong>Statutory Warning</strong>: Spoilers ahead!</p>

<p>```haskell
import qualified Data.List as L
import qualified Data.Vector as V
import qualified Data.Matrix as M
import qualified Data.HashMap.Strict as H
import Prelude hiding (Left,Right)</p>

<p>&mdash; Euler 28: spiral int matrix</p>

<p>data Direction = Down | Left | Right | Up deriving Show</p>

<p>move :: (Int,Int) &ndash;> Direction &ndash;> (Int,Int)
move oldPoint@(y,x) dir =
  case dir of Down &ndash;> (y+1,x)</p>

<pre><code>          Left -&gt; (y,x-1)
          Right -&gt; (y,x+1)
          Up -&gt; (y-1,x)
</code></pre>

<p>getSpiralMoves :: Int &ndash;> [Direction]
getSpiralMoves n =
  if n == 3
  then [Down, Right, Up, Up, Left, Left, Down, Down]
  else let prevMoves = getSpiralMoves (n-2)</p>

<pre><code>       firstMove = [Down]
       secondMove = take (n-2) $ repeat Right
       thirdMove = take (n-1) $ repeat Up
       fourthMove = take (n-1) $ repeat Left
       fifthMove = take (n-1) $ repeat Down
   in
    prevMoves ++ firstMove ++ secondMove ++ thirdMove ++ fourthMove ++ fifthMove
</code></pre>

<p>getSpiralCoords :: Int &ndash;> [(Int,Int)]
getSpiralCoords n =
  let mid = div (n+1) 2</p>

<pre><code>  start = (mid,mid)
</code></pre>

<p>  in
   L.scanl move start $ getSpiralMoves n</p>

<p>getCoordHash :: Int &ndash;> H.HashMap (Int,Int) Int
getCoordHash n = H.fromList $ zip (getSpiralCoords n) [1..]</p>

<p>genF :: H.HashMap (Int,Int) Int &ndash;> (Int, Int) &ndash;> Int
genF h (i,j) = h H.! (i,j)</p>

<p>getDiagElems :: M.Matrix Int &ndash;> Int &ndash;> Int
getDiagElems mat n =
  let leftDiag = sum $ [M.getElem i i mat | i &lt;&ndash; [1 .. n]]</p>

<pre><code>  rightDiag = sum $ [M.getElem i (n + 1 - i) mat | i &lt;- [1 .. n]]
  centerElem = let c = div (n+1) 2
               in
                M.getElem c c mat
</code></pre>

<p>  in
   leftDiag + rightDiag &ndash; centerElem</p>

<p>getSpiralMatrix :: Int &ndash;> M.Matrix Int
getSpiralMatrix n = M.matrix n n $ genF $ getCoordHash n</p>

<p>diagSum :: Int &ndash;> Int
diagSum n = getDiagElems (getSpiralMatrix n) n
```</p>

<p>I added type signatures for every function, so here&rsquo;s a quick overview (this is terribly over-engineered, and turned out to be more of a way to get to know various Haskell datatypes than to actually solve this problem!):</p>

<p><code>getSpiralMoves</code> translates the literal pattern of the square spiral into concrete steps and then <code>getSpiralCoords</code> converts these into <code>(i,j)</code> elements within the matrix. Since I use a <em>generating function</em> (in <code>getSpiralMatrix</code>) to create the matrix, I use a hash-map to store the value of each co-ordinate &hellip; and then <code>getDiagElems</code> iterates over the diagonal elements.</p>

<p>The matrix does turn out as expected:</p>

<p><code>haskell
*Main&gt; getSpiralMatrix 7
( 43 42 41 40 39 38 37 )
( 44 21 20 19 18 17 36 )
( 45 22  7  6  5 16 35 )
( 46 23  8  1  4 15 34 )
( 47 24  9  2  3 14 33 )
( 48 25 10 11 12 13 32 )
( 49 26 27 28 29 30 31 )
</code></p>

<p>This was a simple problem but I was surprised by how <em>short</em> the code was; I didn&rsquo;t write overly terse code, added lots of whitespace, indentation, extra lines, etc, and the whole piece was <em>still</em> just 60 lines!</p>

<p><strong>Update</strong>: Fine, here&rsquo;s the simple solution too.</p>

<p>For every <code>N x N</code> matrix (where <code>N</code> is odd), the diagonal elements are all the diagonal elements of the <code>N-2</code>-sized matrix, plus four more. And these four include <code>N^2</code> and three others, each being <code>(N-1)</code> less than the other. The base case is <code>1 x 1</code>, with a value of 1.</p>

<p>```haskell
euler28 :: Int &ndash;> Int
euler28 1 = 1
euler28 n = let sideDiff = n &ndash; 1</p>

<pre><code>            sq = n ^ 2
        in
         euler28 (n-2) + 4 * sq - (1 + 2 + 3) * sideDiff
</code></pre>

<p>```</p>

<p>&hellip; and then <code>euler28 1001</code> gives the same answer.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 27: Quadratic Primes]]></title>
    <link href="http://agam.github.io/blog/2015/02/14/euler-27-quadratic-primes/"/>
    <updated>2015-02-14T18:43:24+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/14/euler-27-quadratic-primes</id>
    <content type="html"><![CDATA[<p><strong>Statutory Warning</strong>: Spoilers ahead</p>

<p><em>This turned out to be really simple, though I went through a phase of churning out complicated solutions because of a stupid mistake.</em></p>

<p>I didn&rsquo;t preserve intermediate versions, so here is the final solution:</p>

<p>```haskell
import qualified Data.List as L
import qualified Data.Vector as V
import qualified Data.Function as F</p>

<p>sieve :: Int &ndash;> [Int] &ndash;> [Int]
sieve num list =
  if null list
  then [num]
  else let rest = filter (\x &ndash;> x <code>mod</code> num > 0) list</p>

<pre><code>   in
    num : sieve (head rest) (tail rest)
</code></pre>

<p>eratosthenes :: Int &ndash;> [Int]
eratosthenes maxNum = sieve 2 [3 .. maxNum]</p>

<p>allPrimes :: Int &ndash;> V.Vector Int
allPrimes maxNum = V.fromList $ eratosthenes maxNum</p>

<p>eulerEqn :: Int &ndash;> Int &ndash;> Int &ndash;> Int
eulerEqn a b n = n * n + a * n + b</p>

<p>&mdash; TODO(agam): replace with the &ldquo;standard&rdquo; way to do binary search
binSearch :: V.Vector Int &ndash;> Int &ndash;> Int &ndash;> Int &ndash;> Bool
binSearch arr min max elem =
  let low = arr V.! min</p>

<pre><code>  high = arr V.! max
</code></pre>

<p>  in
   if max &ndash; min &lt; 2
   then if low == elem</p>

<pre><code>    then True
    else False
</code></pre>

<p>   else let mid = div (min + max) 2</p>

<pre><code>        midElem = arr V.! mid
    in
     if midElem &gt; elem
     then binSearch arr min mid elem
     else binSearch arr mid max elem
</code></pre>

<p>consecutivePrimes a b primes start length =
  let p = eulerEqn a b start</p>

<pre><code>  l = V.length primes
  isPrime = binSearch primes 0 l p
</code></pre>

<p>  in
   if isPrime
   then consecutivePrimes a b primes (start + 1) (length + 1)
   else length</p>

<p>numPrimes a b primes = consecutivePrimes a b primes 0 0</p>

<p>euler27 maxNum =
  let ap = allPrimes maxNum</p>

<pre><code>  primeLengths = [(a * b, numPrimes a b ap) | a &lt;- [-1000 .. 1000], b &lt;- [-1000 .. 1000]]
</code></pre>

<p>  in
   L.maximumBy (F.on compare snd) primeLengths
```</p>

<p>When I ran this (i.e. <code>euler27 1000</code>) I got the correct answer the first time! But <em>I didn&rsquo;t see it</em>. Instead, I entered the <em>second</em> value of the tuple, which is <em>not</em> the one asked for, and it was therefore <em>obviously</em> wrong. So I thought &ldquo;hmm, we&rsquo;re looking at some large repeating sequence among really large primes&rdquo;, and tried <code>euler27 100000</code> and <code>euler27 10000000</code>, with no luck.</p>

<p>The last one kept running for hours and I killed it, and then came up with the idea of &ldquo;vectorizing everything&rdquo; &mdash; which was perhaps a good academic exercise but did absolutely <em>nothing</em> for the performance here.</p>

<p>So I forgot about it for a while, then came back and ran <code>euler27 1000</code>, entered the <em>first</em> value of the tuple, and that was the end of this story.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 26: Reciprocal Cycles]]></title>
    <link href="http://agam.github.io/blog/2015/02/11/euler-26-reciprocal-cycles/"/>
    <updated>2015-02-11T18:07:38+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/11/euler-26-reciprocal-cycles</id>
    <content type="html"><![CDATA[<p><strong>Statutory Warning</strong>: Spoilers ahead</p>

<p><em>Problem: find the number less than 1000 with the largest repeating cycle of digits in the decimal expansion of its reciprocal</em></p>

<p>As always, the initial reacion was on the lines of <em>aha! this is obvious!</em>:</p>

<p>```lisp
(defun get-repeated-substring-length (str len)
  (let* ((rev-str (reverse str))</p>

<pre><code> (offset (- (length str) (* 2 len)))
 (match (equal (subseq rev-str 0 len)
           (reverse (subseq str offset (+ offset len))))))
(if match
len
0)))
</code></pre>

<p>(defun get-cycle-length (dec)
  (declare (type double-float dec))
  (let* ((dec-str (princ-to-string dec))</p>

<pre><code> (exp-str (subseq dec-str
          (1+ (position #\. dec-str))
          (position #\d dec-str))))
(do ((i 0 (1+ i))
 (cycle-length 0 (get-repeated-substring-length exp-str i)))
((or (&gt; cycle-length 0) (&gt; i (/ (length exp-str) 2))) cycle-length))))
</code></pre>

<p>(defun inverse-cycle-digits (n)
  (let ((inverse (/ 1.0 (coerce n &lsquo;double-float))))</p>

<pre><code>(do* ((i 0 (1+ i))
 (dec (* 1.0 inverse) (* 10.0 dec))
 (cycle-length 0 (get-cycle-length dec)))
 ((&gt; cycle-length 0) cycle-length))))
</code></pre>

<p>(defun euler-26-fail ()
  (let ((all-cycles (mapcar #&lsquo;inverse-cycle-digits (loop for i from 1 to 1000 collect i))))</p>

<pre><code>(reduce #'max all-cycles)))
</code></pre>

<p>```</p>

<p>But the aptly named <code>euler-26-fail</code> fails to do what we want, because once again, the largest reciprocal when expanded fully, lies beyond the standard <em>double-float</em> range. So, we hand-roll &hellip;</p>

<p>```lisp</p>

<p>(defun inverse (n &amp;key (precision))
  (do* ((i 0 (1+ i))</p>

<pre><code>(numerator 10 (* 10 (mod numerator n)))
(dec (floor (/ 10 n)) (floor (/ numerator n)))
(declist (list dec) (cons dec declist)))
   ((&gt; i precision) (nreverse declist))))
</code></pre>

<p>(defun cycle-length-helper (declist)
  (do ((i 0 (1+ i))</p>

<pre><code>   (cycle-length 0 (get-repeated-substring-length declist i)))
  ((or (&gt; cycle-length 0) (&gt; i (/ (length declist) 2))) cycle-length)))
</code></pre>

<p>(defun cycle-length (declist)
  (loop for length in (loop for i from 1 to (length declist)</p>

<pre><code>         collect (cycle-length-helper (subseq declist 0 i)))
   maximizing length))
</code></pre>

<p>(defun get-all-inverse-lengths (lst max-precision)
  (mapcar #&lsquo;(lambda (n) (cycle-length (inverse n :precision max-precision)))</p>

<pre><code>  lst))
</code></pre>

<p>(defun unique-max (list)
  (let ((max (reduce #&lsquo;max list)))</p>

<pre><code>(if (= 1 (count max list))
max
0)))
</code></pre>

<p>(defun biggest-cycle (max-num prec)
  (let* ((lst (loop for i from 1 to  max-num collect i))</p>

<pre><code> (lengths (get-all-inverse-lengths lst prec))
 (max-len (reduce #'max lengths)))
;;(format t "Debug: lengths = ~A, max = ~A~%" lengths max-len)
(nth (position max-len lengths) lst)))
</code></pre>

<p>```</p>

<p>The idea is to loop over all numbers with a given precision, find the max, then maybe increase the precision and try again. This is a terrible idea, relying on the ability to submit multiple answers at the Project Euler website :(</p>

<p>But more than that, it&rsquo;s terribly slow. It becomes marginally faster if we restrict our search to primes.</p>

<p>```lisp
(defun biggest-cycle (max-num prec)
  (let* ((lst (eratosthenes max-num))</p>

<pre><code> (lengths (get-all-inverse-lengths lst prec))
 (max-len (reduce #'max lengths)))
;;(format t "Debug: lengths = ~A, max = ~A~%" lengths max-len)
(nth (position max-len lengths) lst)))
</code></pre>

<p>(defun sieve (prime list)
  (if (null list)</p>

<pre><code>  (list prime)
  (cons prime (sieve (first list)
         (remove-if #'(lambda (n)
                (= 0 (mod n prime)))
                (rest list))))))
</code></pre>

<p>(defun eratosthenes (max-num)
  (let ((all-numbers (loop for i from 2 to max-num collect i)))</p>

<pre><code>(sieve (first all-numbers) (rest all-numbers))))
</code></pre>

<p>```</p>

<p>With this change, <code>(biggest-cycle 1000 1000)</code> yielded <code>499</code> (in <em>211 seconds</em>), but it turned out to be incorrect. <code>(biggest-cycle 1000 10000)</code> took <em>22810 seconds</em>, which is shameful, but yielded the right answer.</p>

<h3>Update</h3>

<p>Here is an effort to redeem myself:</p>

<p>```haskell
import qualified Data.List as L
import qualified Data.Vector as V</p>

<p>eratosthenes :: Int &ndash;> [Int]
&mdash; ^Get a list of prime numbers less than the given number.              <br/>
eratosthenes n =
  let x = [2 .. n] in
  sieve (head x) (tail x)</p>

<p>sieve :: Int &ndash;> [Int] &ndash;> [Int]
sieve p nums =
  let rest = filter (\x &ndash;> x <code>mod</code> p > 0) nums
  in if null rest</p>

<pre><code> then [p]
 else p : sieve (head rest) (tail rest)
</code></pre>

<p>inverse :: Int &ndash;> Int &ndash;> V.Vector Int      <br/>
&mdash; ^Given a number and the required precision, calculate the decimal expansion of its reciprocal.
inverse n prec =
  let truncate x y = (x <code>div</code> y, x <code>mod</code> y)</p>

<pre><code>  nextDigit x count
    | count == 0 = []
    | otherwise = let (d,m) = truncate (x * 10) n
                  in d : nextDigit m (count - 1)
</code></pre>

<p>  in
   V.fromList $ nextDigit 1 prec</p>

<p>getInverses :: Int &ndash;> Int &ndash;> [V.Vector Int]
&mdash; ^Get a list of all the inverses of all numbers upto a given number, for a given precision
getInverses maxNum maxPrec = [inverse x maxPrec | x &lt;&ndash; [1 .. maxNum]]</p>

<p>checkRepeatLength :: V.Vector Int &ndash;> Int &ndash;> Int &ndash;> Int
checkRepeatLength expansion end len =
  let s1 = V.slice (end &ndash; len) len expansion</p>

<pre><code>  s2 = V.slice (end - len - len) len expansion
  c = V.zipWith (==) s1 s2
</code></pre>

<p>  in
   if V.and c
   then len
   else 0</p>

<p>checkCycles :: V.Vector Int &ndash;> Int &ndash;> Int
&mdash; ^Check if a cycle exists at a given end point with a given length; if it does, returns the length itself, otherwise 0
checkCycles expansion end =
  let l = quot end 2</p>

<pre><code>  cycles = filter (&gt; 0) $ map (checkRepeatLength expansion end) [1 .. l]
</code></pre>

<p>  in
   case cycles of</p>

<pre><code>x:xs -&gt; x
otherwise -&gt; 0
</code></pre>

<p>findCycleLength :: V.Vector Int &ndash;> Int
&mdash; ^Get the length of a cycle at a certain end point; if none found, returns 0
findCycleLength expansion =
  let l = V.length expansion</p>

<pre><code>  minEnd = quot l 2
  cycles = filter (&gt; 0) $ map (checkCycles expansion) [l, l-1 .. minEnd]
</code></pre>

<p>  in
   case cycles of</p>

<pre><code>x:xs -&gt; x
otherwise -&gt; 0
</code></pre>

<p>euler26 :: Int &ndash;> Int
&mdash; ^Attempts to solve Euler Problem #26 for a given precision
euler26 prec =
  let nums = [2 .. 1000]</p>

<pre><code>  cycles = map (\x -&gt; findCycleLength $ inverse x prec) nums
  maxPos = L.elemIndex (maximum cycles) cycles
</code></pre>

<p>  in
   case maxPos of</p>

<pre><code>Just n -&gt; nums !! n
_ -&gt; 0
</code></pre>

<p>```</p>

<p>This gives the same answer (<code>euler26 10000</code>) in <code>7.5 seconds</code> (which is a 3000x speedup). Just to make sure you don&rsquo;t jump to that conclusion, it isn&rsquo;t a Haskell vs Lisp thing, it&rsquo;s just <em>calculating less stuff</em>, and doing it with <em>vectors instead of lists</em>.</p>

<p>In particular, the first version was running for <em>12 hours</em> before I killed it out of disgust, and realized that instead of checking if the <code>length</code> of the list was greater than 0, I should do a <code>case</code> match instead since I only needed the first element. This made a <em>big</em> difference. Also, this is the first time I <em>didn&rsquo;t</em> have to rely on <code>Debug.Trace</code>, so I feel good about that :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Euler 25: Fibonacci Digits]]></title>
    <link href="http://agam.github.io/blog/2015/02/10/euler-25-fibonacci-digits/"/>
    <updated>2015-02-10T18:43:52+00:00</updated>
    <id>http://agam.github.io/blog/2015/02/10/euler-25-fibonacci-digits</id>
    <content type="html"><![CDATA[<p><strong>Statutory Warning</strong>: spoilers ahead</p>

<p><em>Problem: find the first fibonacci number with 1000 digits</em></p>

<p>First though: hah, I can get the Nth fibonacci number in O(1) time!</p>

<p>```lisp
(defun fib (n)
  (let ((inv-sq-5 (/ 1 (sqrt 5)))</p>

<pre><code>(phi (/ (1+ (sqrt 5)) 2)))
(floor (+ 0.5 (* inv-sq-5 (expt phi n))))))
</code></pre>

<p>(defun digits (n)
  (round (1+ (log n 10))))</p>

<p>(defun log-fib-10 (n)
  (let ((log-10 (log 10))</p>

<pre><code>(log-phi (log (/ (1+ (sqrt 5)) 2)))
(log-k (log (/ 1 (sqrt 5)))))
(* log-10 (+ log-k (* n log-phi)))))
</code></pre>

<p>```</p>

<p>Nope, floating point numbers don&rsquo;t go beyond 308 digits or so</p>

<p><code>lisp
CL-USER&gt; most-positive-double-float
1.7976931348623157d308
</code></p>

<p>Perhaps there was a clever way to workaround this, but I wasn&rsquo;t feeling clever enough at the time. So, back to brute force.</p>

<p>```lisp
(defun fib (n)
  (cond ((= n 0) 0)</p>

<pre><code>((= n 1) 1)
(t (+ (fib (- n 1)) (fib (- n 2))))))
</code></pre>

<p>```</p>

<p>Well, this just takes <em>too long</em> (<code>(fib 40)</code> takes <code>3.883</code> seconds, and that has just 9 digits, so forget about anything bigger). Next step: memoization.</p>

<p>```lisp
(let ((memo-table (make-hash-table)))
  (defun memo-fib (n)</p>

<pre><code>(multiple-value-bind (hash-val exists) (gethash n memo-table)
  (if exists
  hash-val
  (let ((new-val (cond ((= n 0) 0)
                       ((= n 1) 1)
                       (t (+ (memo-fib (- n 1)) (memo-fib (- n 2)))))))
    (setf (gethash n memo-table) new-val)
    new-val)))))
</code></pre>

<p>(defun digits-num (n)
  (length (princ-to-string n)))
```</p>

<p>(yeah just to be even less clever, I get the digits by seeing the length of the string representation of the number &hellip; works)</p>

<p><code>(memo-fib 40)</code> is instantaneous, so is <code>(memo-fib 1000)</code>, and <code>(memo-fib 10000)</code> takes <code>3 ms</code>, so this should do it.</p>

<p>I used this to manually guess my way around and found the answer. Woohoo!</p>

<p>But this last part felt a bit &hellip; dirty, so before quitting this problem, I decided to automate it this way:</p>

<p>```lisp
(defun bin-search-range (fn target)
  (do<em> ((i 1 (</em> 2 i))</p>

<pre><code>   (val (funcall fn 1) (funcall fn i)))
   ((&gt;= val target) (values i (/ i 2)))
(format t "Debug: Trying (~A, ~A)~%" i val)))
</code></pre>

<p>(defun bin-search (fn low high target)
  (let* ((mid (round (/ (+ low high) 2)))</p>

<pre><code> (mid-val (funcall fn mid)))
(format t "Debug: Searching b/w (~A, ~A), found (~A, ~A)~%" low high mid mid-val)
(cond ((= high mid) mid)
  ((&gt;= mid-val target) (bin-search fn low mid target))
  ((&lt; mid-val target) (bin-search fn mid high target)))))
</code></pre>

<p>(defun solve (fn target)
  &ldquo;Two-phase search; first, exponentially increase argument until target is exceeded, then begin binary search with last argument&rdquo;
  (multiple-value-bind (high low) (bin-search-range fn target)</p>

<pre><code>(bin-search fn low high target)))
</code></pre>

<p>(defun target-function (n)
  (digits-num (memo-fib n)))</p>

<p>(defun euler-25 ()
  (solve #&lsquo;target-function 1000))
```</p>

<p>Yes, it does work. I left in my original debug statements (BTW the initial version had not one but <em>two</em> off-by-one errors! I learn slowly &hellip;), so the working is illustrated as follows:</p>

<p><code>lisp
CL-USER&gt; (euler-25)
Debug: Trying (1, 1)
Debug: Trying (2, 1)
Debug: Trying (4, 1)
Debug: Trying (8, 2)
Debug: Trying (16, 3)
Debug: Trying (32, 7)
Debug: Trying (64, 14)
Debug: Trying (128, 27)
Debug: Trying (256, 54)
Debug: Trying (512, 107)
Debug: Trying (1024, 214)
Debug: Trying (2048, 428)
Debug: Trying (4096, 856)
Debug: Searching b/w (4096, 8192), found (6144, 1284)
Debug: Searching b/w (4096, 6144), found (5120, 1070)
Debug: Searching b/w (4096, 5120), found (4608, 963)
Debug: Searching b/w (4608, 5120), found (4864, 1017)
Debug: Searching b/w (4608, 4864), found (4736, 990)
Debug: Searching b/w (4736, 4864), found (4800, 1003)
Debug: Searching b/w (4736, 4800), found (4768, 997)
Debug: Searching b/w (4768, 4800), found (4784, 1000)
Debug: Searching b/w (4768, 4784), found (4776, 998)
Debug: Searching b/w (4776, 4784), found (4780, 999)
Debug: Searching b/w (4780, 4784), found (4782, 1000)
Debug: Searching b/w (4780, 4782), found (4781, 999)
Debug: Searching b/w (4781, 4782), found (4782, 1000)
4782
</code></p>

<p>The whole thing took <code>6 ms</code>. Not bad, eh?</p>
]]></content>
  </entry>
  
</feed>
